/**
 * @file ubc日志打点
 *
 * @author changyuqing@baidu.com
 */

import {getUrlQuery, getUrl, getCookieByName, isBox, merge, isSwan} from './utils/utils';
import {CONFIG, CONFIG_MERGE} from './config';
import {smartSend} from './utils/send';
import {regestPageVisibilityEvent} from './utils/pageVisibility';
import {version as sdkVersion} from '../package.json';
import {getAppByName} from './utils/ua';
import {MergeLogger} from './MergeLogger';
import {TimeLogger} from './TimeLogger';
import {RetryLogger} from './RetryLogger';
import {sha256} from './utils/sha';
import {isBeta} from './utils/isBeta';

/**
 *
 * @constructor ubc业务日志类
 * @description ubc业务日志类
 *
 * @example
 * new Ubclogger({
 *     serverId:123,
 *     idfrom:'res_fuli',
 *     page:'index'
 * })
 */
export class UbcLogger {

    /**
     * Create a UbcLogger
     *
     * @class UbcLogger
     * @param {Object} [options]                        初始化入参
     * @param {number} [options.serverId]               活动serverId
     * @param {string} [options.page]                   页面page名称
     * @param {string} [options.type]                   打点type
     * @param {string} [options.from]                   日志类型
     * @param {Object} [options.queryParams]            ubcUrl上的query(appname,from,cfrom,smfw)
     * @param {boolean} [options.testMode=false]        true走线下地址; false或者为空走线上ubc地址，目前日志平台采用新校验方式，不需要走线下地址
     * @param {string} [options.testUrl]                打点数据上传地址;传入后，打点数据将发送至该地址
     * @param {string} [options.source]                 资源位source
     * @param {string} [options.idfrom]                 资源位idfrom(等价于资源位source，优先级更高)
     * @param {boolean} [options.ifHeartbeatTime=true]  时长打点是否为心跳点，默认为true
     * @param {boolean} [options.useSendBeacon=false]   使用SendBeacon API进行打点
     * @param {Object} [options.logMergeOpt]            日志合并参数配置
     * @param {Object} [options.logMergeOpt.ifAutoMerge] 是否开启自动合并，默认不开启
     * @param {Object} [options.logMergeOpt.mergeNumMax] 最大日志合并数量
     * @param {Object} [options.logMergeOpt.mergeInterval] 合并时间间隔
     * @param {boolean} [options.logErrRetry]            是否开启日志重试
     * @param {Object} [options.ext]               公共的ext参数，会被send的传参覆盖
     *
     *
     */
    constructor(options = {}) {
        // ubcLog
        this.ubcParams = {};
        // 是否初始化
        this.logInited = false;
        // set后的options
        this.options = {};

        // 时长打点
        this.timerMap = new Map();
        // 合并打点
        this.mergeLogger = null;
        // 打点重试机制
        this.retryLogger = null;

        // 当前宿主端是否是beta包
        this.isBeta = false;

        this._initUbcParams();
        // 初始化设置参数
        this.set(Object.assign({
            duration: 3,
            ifHeartbeatTime: true,
            testMode: false,
            useSendBeacon: false,
            useXhr: false,
            sendMethod: 'get',
            apptype: getAppByName().appid
        }, options));

        // 注册页面可见性
        this._registerPageVisibility();
        this._registerBeta();
    }

    /**
     * _initUbcParams
     *
     * @private
     */
    _initUbcParams() {
        this.ubcParams = {};
        this.ubcDefaultLogData = CONFIG.DEFAULT_LOG_DATA;
        // merge默认数据
        this.ubcParams = merge(
            this.ubcParams,
            this.ubcDefaultLogData
        );
    }

    _initCookie(options = {}) {
        // 设置cookie
        if (options.testMode) {
            document.cookie = 'bd_logap_verify=1;domain=.baidu.com;path=/';
        }
    }


    /**
     * _initUbcUrl
     *
     * @private
     * @param {Object} options  options入参
     */
    _initUbcUrl(options = {}) {
        // 获取ubcUrl
        let query = options.queryParams || {};
        if (this.isBeta) {
            query = {
                beta: 1,
                ...query
            }
        }

        // 线下环境带上debug标示
        if (options.testMode) {
            query = {
                debug: 1,
                ...query
            }
        }

        // beta=1
        this.ubcUrl = getUrl(
            options.testMode ? (options.testUrl ? options.testUrl : CONFIG.UBC_URL) : CONFIG.UBC_URL,
            merge(CONFIG.DEFAULT_QUERY, query)
        );
        this.ubcMergeUrl = getUrl(
            options.testMode ? (options.testUrl ? options.testUrl : CONFIG_MERGE.UBC_URL) : CONFIG_MERGE.UBC_URL,
            merge(CONFIG_MERGE.DEFAULT_QUERY, query)
        );
    }

    /**
     * set
     * options可不填，缺省字段会以上次设置的为准
     * @example
     * ubclogger.set({
     *     serverId:123,
     *     idfrom:'res_fuli',
     *     page:'index'
     * })
     * @param {Object} [options]                  初始化入参
     * @param {number} [options.serverId]               活动serverId
     * @param {string} [options.page]                   页面page名称
     * @param {string} [options.from]                   日志类型
     * @param {Object} [options.queryParams]            ubcUrl上的query(appname,from,cfrom,smfw)
     * @param {string} [options.testMode]         true走校验模式; false或者为空走线上ubc地址
     * @param {string} [options.testUrl]                打点数据上传地址;传入后，打点数据将发送至该地址（需要testMode=true）
     * @param {string} [options.source]                 资源位source
     * @param {string} [options.idfrom]                 资源位idfrom(等价于资源位source，优先级更高)
     * @param {boolean} [options.ifHeartbeatTime]  时长打点是否为心跳点
     * @param {boolean} [options.useSendBeacon]   使用SendBeacon API进行打点，默认false
     * @param {boolean} [options.useXhr]   使用xhr进行打点,默认false
     * @param {string} [options.sendMethod]   单条请求发送方式 get/post，默认get，配合useXhr使用
     * @param {Object} [options.logMergeOpt]            日志合并参数配置
     * @param {boolean} [options.logMergeOpt.ifAutoMerge] 是否开启自动合并，默认不开启
     * @param {number} [options.logMergeOpt.mergeNumMax] 最大日志合并数量。默认5条
     * @param {number} [options.logMergeOpt.mergeInterval] 合并时间间隔，默认5s,单位s
     * @param {boolean} [options.logErrRetry]            是否开启日志重试
     * @param {Object} [options.ext]               公共的ext参数，会被send的传参覆盖
     *
     */
    set(options = {}) {
        this.options = {
            ...this.options,
            ...options
        };

        this._initCookie(this.options);
        this._initUbcUrl(this.options);

        // 配置serverId,source(idfrom),page
        this.ubcParams = merge(this.ubcParams, {
            actiondata: {
                id: this.options.serverId,
                content: {
                    source: this.options.source || this.options.idfrom || getUrlQuery('source') || getUrlQuery('idfrom'),
                    page: this.options.page,
                    from: this.options.from,
                    type: this.options.type,
                    ext: {
                        apptype: this.options.apptype,
                        ...this.options.ext
                    }
                }
            }
        });
        if (+this.options.serverId) {
            this.logInited = true;
        }
        // 初始化mergeLogger
        if (!this.mergeLogger) {
            this.mergeLogger = new MergeLogger({
                logFn: (paramsList) => {
                    return this._sendMerge(paramsList, {
                        useXhr: true,
                        sendMethod: 'post'
                    });
                }
            });
        }
        if (this.options.logMergeOpt) {
            // 修改mergeLogger选项
            this.mergeLogger.set(this.options.logMergeOpt);
        }

        // 初始化retryLogger
        if (this.options.logErrRetry && !this.retryLogger) {
            this.retryLogger = new RetryLogger({
                logFn: (url, logData) => {
                    logData.actiondata.metadata.uploadTimeStamp = Date.now();
                    return smartSend(url, logData, {useXhr: true});
                }
            });
        }
    }

    /**
     * 发送普通点
     * @private
     * @param  {Object} params  打点自定义参数
     * @param  {Object} options 额外参数
     * @param  {boolean} options.useSendBeacon 是否使用SendBeacon API发送请求
     * @param  {boolean} [options.useXhr] 是否使用Xhr发送请求
     * @param  {string} [options.sendMethod] 单条请求发送方式 get/post，默认get，配合useXhr使用
     * @return {Promise} promise 打点成功发送返回then
     */
    _send(params = {}, options = {}) {
        let logData = {};
        let now = Date.now();
        // 事件打点正常处理
        let baiduId = getCookieByName('BAIDUID');
        if (baiduId && this.options.logErrRetry) {
            // 获得没有加metadata的logData
            logData = merge(this.ubcParams, {
                actiondata: {
                    timestamp: now,
                    content: params
                }
            });
            // 通过baiduId和logData计算摘要值（logData里面已经包含了当前时间戳）
            let loggerId = sha256(baiduId + JSON.stringify(logData));
            logData.actiondata.metadata = {
                md5: loggerId,
                uploadTimeStamp: now
            };

            return smartSend(this.ubcUrl, logData, {...options, useXhr: true}).then(data => {
                // 打点成功后通知retryLogger
                this.retryLogger.active();
                return data;
            }).catch(err => {
                //向队列中加一条日志
                this.retryLogger.addLog({url: this.ubcUrl, loggerData: logData, loggerId});
                return Promise.reject(err);
            });
        } else {
            logData = merge(this.ubcParams, {
                actiondata: {
                    timestamp: now,
                    content: params
                }
            });
            return smartSend(this.ubcUrl, logData, options);
        }

    }

    /**
     * 发送合并点
     * @private
     * @param  {Array} paramsList  打点自定义参数
     * @param  {Object} options 额外参数
     * @param  {boolean} [options.useSendBeacon] 是否使用SendBeacon API发送请求
     * @param  {boolean} [options.useXhr] 是否使用Xhr发送请求
     * @param  {string} [options.sendMethod] 单条请求发送方式 get/post，默认get，配合useXhr使用
     * @return {Promise} promise 打点成功发送返回then
     */
    _sendMerge(paramsList = [], options = {}) {
        let logData = {};
        let now = Date.now();
        // 事件打点正常处理
        let {actiondata} = this.ubcParams;
        let data = paramsList.map(params => {
            let tempLogData = merge(actiondata, {
                timestamp: now,
                content: params
            });
            return tempLogData;
        });
        logData = {
            ...CONFIG_MERGE.DEFAULT_LOG_DATA,
            data
        };
        return smartSend(this.ubcMergeUrl, logData, options);
    }

    /**
     * 发送流式点
     * @private
     * @param  {Object} params  打点自定义参数
     * @param  {Object} timing  时长相关参数
     * @param  {Object} options 额外参数
     * @param  {boolean} options.useSendBeacon 是否使用SendBeacon API发送请求
     * @return {Promise} promise 打点成功发送返回then
     */
    _sendFlow(params = {}, timing = {}, options = {}) {
        // 流式打点参数处理
        let logData = this._getFlowData(params, timing);
        return smartSend(this.ubcUrl, logData, options);
    }

    /**
     * send
     * @example
     * ubclogger.send({
     *     page: 'y_ent_login',
     *     type: 'login_clk',
     *     value: 'login',
     *     ext: {
     *         p1: 'login'
     *     }
     * })
     * @param  {Object} params  打点自定义参数
     * @param  {Object} [options] 额外选项
     * @param  {boolean} [options.useSendBeacon] 是否使用SendBeacon API发送请求
     * @param  {boolean} [options.useXhr] 是否使用Xhr发送请求
     * @param  {string} [options.sendMethod] 单条请求发送方式 get/post，默认get，配合useXhr使用
     * @return {Promise} promise 打点成功发送返回then
     */
    send(params = {}, options) {
        if (!this.logInited) {
            throw 'UBC SDK serverId can not be empty!';
        }
        options = {
            useSendBeacon: this.options.useSendBeacon,
            useXhr: this.options.useXhr,
            options: this.options.sendMethod,
            ...options
        };
        if (this.options?.logMergeOpt?.ifAutoMerge) {
            this.mergeLogger.add(params);
            return Promise.resolve();
        } else {
            return this._send(params, options);
        }
    }

    /**
     * sendMergeLog
     * @example
     * ubclogger.sendMergeLog({
     *     page: 'y_ent_login',
     *     type: 'login_clk',
     *     value: 'login',
     *     ext: {
     *         p1: 'login'
     *     }
     * })
     * @param  {Object} params  打点自定义参数
     * @return {Promise} promise 打点成功发送返回then
     */
    sendMergeLog(params = {}) {
        if (!this.logInited) {
            throw 'UBC SDK serverId can not be empty!';
        }
        this.mergeLogger.add(params);
        return Promise.resolve();
    }

    /**
     * _getFlowData
     *
     * @private
     * @see 流式打点字段格式：http://wiki.baidu.com/pages/viewpage.action?pageId=337347739#id-%E6%97%A5%E5%BF%97%E8%A7%84%E8%8C%83-2.3.3%E6%B5%81%E7%B1%BB%E5%9E%8B%E6%97%A5%E5%BF%97%E5%AD%97%E6%AE%B5%E8%A7%84%E8%8C%83%E2%80%94%E6%97%B6%E9%95%BF
     * @param {Object} content 打点自定义参数
     * @param {Object} timing 时长相关参数
     * @return {Object} logData 打点数据
     */
    _getFlowData(content, timing) {
        let resultLogData = {};
        let {starttime, duration, endtime} = timing;
        let now = Date.now();

        // 将this.ubcParams?.actiondata?.content 里面 向下移动到 resultLogData.actiondata?.content.option
        resultLogData = merge(this.ubcParams, {actiondata: {content: '-'}});
        resultLogData = merge(resultLogData, {
            actiondata: {
                timestamp: now,
                starttime,
                endtime,
                type: 1,
                content: {
                    duration,
                    option: merge(this.ubcParams?.actiondata?.content, content)
                }
            }
        })
        return resultLogData;
    }

    /**
     * startTimingLog 开始
     * @example
     * ubclogger.startTimingLog('timing1',{
     *     page: 'y_ent_login',
     *     type: 'login_clk',
     *     value: 'login',
     *     ext: {
     *         p1: 'login'
     *     }
     * })
     * @example
     * ubclogger.startTimingLog('timing1',{
     *     page: 'y_ent_login',
     * },{
     *     useSendBeacon: true
     * }
     * @param  {*} [label=default]  时长打点必须拥有唯一的名字，默认default
     * @param  {Object} [params]  打点自定义参数
     * @param  {Object} [options]  打点设置，覆盖全局设置
     * @param  {boolean} [options.ifHeartbeatTime]  是否通过心跳打点
     * @param  {boolean} [options.useSendBeacon]  是否使用 SendBeacon API
     * @param  {number} [options.duration]  心跳打点的间隔，单位s
     */
    startTimingLog(label = 'default', params = {}, options) {
        let timer = this.timerMap.get(label);
        // 如果不存在时长打点，则创建一个打点
        if (!timer) {
            timer = new TimeLogger({
                ifHeartbeatTime: this.options.ifHeartbeatTime,
                duration: this.options.duration,
                // 覆盖全局设置
                ...options,
                // 根据时长相关参数，发送打点
                logFn: timing => {
                    this._sendFlow(params, timing, {
                        useSendBeacon: this.options.useSendBeacon,
                        ...options
                    });
                }
            });
            this.timerMap.set(label, timer);
        }

        if (timer.flag === 'RUNNING') {
            console.warn(`timeLogger[${label}] is running`);
            return;
        }

        timer.start();
    }

    /**
     * pauseTimingLog 停止打点,保留该时长点的参数,可被重新启动
     * @example
     * ubclogger.pauseTimingLog('timing1');
     * @param {*} [label=default]  时长打点必须拥有唯一的名字，默认default
     */
    pauseTimingLog(label = 'default') {
        let timer = this.timerMap.get(label);
        if (timer) {
            timer.stop();
        }
    }

    /**
     * stopTimingLog 停止时长计算
     * @example
     * ubclogger.stopTimingLog('timing1');
     * @param {*} [label=default]  时长打点必须拥有唯一的名字，默认default
     */
    stopTimingLog(label = 'default') {
        let timer = this.timerMap.get(label);
        if (timer) {
            timer.stop();
            this.timerMap.delete(label);
        }
    }

    /**
     * _registerPageVisibility 在页面切换时暂停时长计算
     * @private
     * @desc 页面展现begin
     * @desc 页面离开/切后台end
     */
    _registerPageVisibility() {
        regestPageVisibilityEvent((isHidden) => {
            if (isHidden) {
                this.timerMap.forEach(timer => {
                    if (timer && timer.flag === 'RUNNING') {
                        timer.autoStop();
                    }
                });
                this.mergeLogger && this.mergeLogger.clearAll();
            } else {
                this.timerMap.forEach(timer => {
                    if (timer && timer.flag === 'AUTO_STOP') {
                        timer.start();
                    }
                });
            }
        });
    }

    /**
     * getVersion 获得当前sdk版本
     * @return {string} 当前sdk版本
     */
    getVersion() {
        return sdkVersion;
    }

    _registerBeta() {
        // 只在手百中加入判断灰度包的逻辑
        if (isBox() && !isSwan()) {
            isBeta().then((res) => {
                if (res?.isBeta) {
                    this.isBeta = true;
                    // 修改ubc url
                    this.set();
                }
            }).catch(() => {
                // safe
                // 不支持这个schema，或者非手百，不做任何操作
            })
        }
    }

}
