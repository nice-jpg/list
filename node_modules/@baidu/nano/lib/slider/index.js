"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

require("./style/index.less");

var _san = require("san");

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var prefixCls = 's-slider';

function clamp(value, min, max) {
  if (value < min) {
    return min;
  }

  if (value > max) {
    return max;
  }

  return value;
}

function valueToPercent(value, min, max) {
  return (value - min) * 100 / (max - min);
}

var Slider =
/*#__PURE__*/
function (_Component) {
  _inherits(Slider, _Component);

  function Slider() {
    _classCallCheck(this, Slider);

    return _possibleConstructorReturn(this, _getPrototypeOf(Slider).apply(this, arguments));
  }

  _createClass(Slider, [{
    key: "initData",
    value: function initData() {
      return {
        disabled: false,
        lead: '',
        max: 100,
        min: 0,
        marks: [],
        showbar: true,
        step: 1,
        tail: '',
        value: 0,
        vertical: false
      };
    }
  }, {
    key: "attached",
    value: function attached() {
      var that = this;
      var $slider = this.el;
      var $button = this.ref('button');
      var handelTouch = {
        handleEvent: function handleEvent(event) {
          if (that.disabled) {
            return;
          }

          var handler = event.type;

          if (typeof this[handler] === 'function') {
            event.preventDefault();
            return this[handler](event);
          }
        },
        reset: function reset() {
          this.startX = 0;
          this.startY = 0;
          this.deltaX = 0;
          this.deltaY = 0;
          this.offsetX = 0;
          this.offsetY = 0;
        },
        touchstart: function touchstart(event) {
          var _this = this;

          this.reset();
          this.startX = event.touches[0].clientX;
          this.startY = event.touches[0].clientY;
          this.startValue = that.data.get('value');
          var events = ['touchmove', 'touchend'];
          events.forEach(function (type) {
            return $button.addEventListener(type, _this, false);
          });
        },
        touchmove: function touchmove(event) {
          var touch = event.touches[0];
          this.deltaX = touch.clientX - this.startX;
          this.deltaY = touch.clientY - this.startY;
          this.offsetX = Math.abs(this.deltaX);
          this.offsetY = Math.abs(this.deltaY);
          var rect = $slider.getBoundingClientRect();
          var delta = that.vertical ? this.deltaY : this.deltaX;
          var total = that.vertical ? rect.height : rect.width;
          var diff = delta / total * that.range;
          that.updateValue(this.startValue + diff);
        },
        touchend: function touchend() {
          var _this2 = this;

          var events = ['touchmove', 'touchend'];
          events.forEach(function (type) {
            return $button.removeEventListener(type, _this2);
          });
        }
      };

      if ($button) {
        $button.addEventListener('touchstart', handelTouch, false);
      }
    }
  }, {
    key: "format",
    value: function format(value) {
      var _this$data$get = this.data.get(),
          max = _this$data$get.max,
          min = _this$data$get.min,
          step = _this$data$get.step;

      return Math.round(Math.max(min, Math.min(value, max)) / step) * step;
    }
  }, {
    key: "handleClick",
    value: function handleClick(event) {
      event.stopPropagation();

      var _this$data$get2 = this.data.get(),
          disabled = _this$data$get2.disabled,
          max = _this$data$get2.max,
          min = _this$data$get2.min,
          vertical = _this$data$get2.vertical;

      if (disabled) {
        return;
      }

      var rect = this.el.getBoundingClientRect();
      var delta = vertical ? event.clientY - rect.top : event.clientX - rect.left;
      var total = vertical ? rect.height : rect.width;
      var value = delta / total * (max - min) + min;
      this.updateValue(value);
    }
  }, {
    key: "updateValue",
    value: function updateValue(value) {
      var newValue = this.format(value);
      var oldValue = this.data.get('value');
      this.data.set('value', newValue);

      if (newValue !== oldValue) {
        this.fire('change', newValue);
      }
    }
  }, {
    key: "disabled",
    // eslint-disable-next-line
    get: function get() {
      return this.data.get('disabled');
    }
  }, {
    key: "range",
    get: function get() {
      var _this$data$get3 = this.data.get(),
          max = _this$data$get3.max,
          min = _this$data$get3.min;

      return max - min;
    }
  }, {
    key: "vertical",
    get: function get() {
      return this.data.get('vertical');
    }
  }]);

  return Slider;
}(_san.Component);

exports.default = Slider;

_defineProperty(Slider, "template",
/*html*/
"\n        <div class=\"{{wrapClass}}\" on-click=\"handleClick\">\n            <slot name=\"lead\">\n                <div s-if=\"lead\" class=\"".concat(prefixCls, "-lead\">{{lead}}</div>\n            </slot>\n            <div class=\"").concat(prefixCls, "\">\n                <div class=\"").concat(prefixCls, "-foo\" style=\"{{value | getStyle('foo')}}\">\n                    <div\n                        class=\"").concat(prefixCls, "-bar\"\n                        style=\"{{value | getStyle('bar')}}\"\n                    />\n                </div>\n                <div\n                    s-for=\"mark in marks\"\n                    class=\"").concat(prefixCls, "-mark\"\n                    style=\"{{mark.value | getStyle('mark')}}\"\n                >\n                    <div class=\"").concat(prefixCls, "-mark-label {{mark.value === value ? 'active' : ''}}\">{{mark.label}}</div>\n                    <div class=\"").concat(prefixCls, "-mark-value\"></div>\n                </div>\n                <div\n                    s-ref=\"button\"\n                    class=\"").concat(prefixCls, "-button-wrap\"\n                    style=\"{{value | getStyle('btn')}}\"\n                >\n                    <slot name=\"button\"><div class=\"").concat(prefixCls, "-button\"/></slot>\n                </div>\n            </div>\n            <slot name=\"tail\">\n                <div s-if=\"tail\" class=\"").concat(prefixCls, "-tail\">{{tail}}</div>\n            </slot>\n        </div>\n    "));

_defineProperty(Slider, "dataTypes", {
  disabled: _san.DataTypes.bool,
  lead: _san.DataTypes.string,
  max: _san.DataTypes.number,
  min: _san.DataTypes.number,
  marks: _san.DataTypes.array,
  showbar: _san.DataTypes.bool,
  step: _san.DataTypes.number,
  tail: _san.DataTypes.string,
  value: _san.DataTypes.number,
  vertical: _san.DataTypes.bool
});

_defineProperty(Slider, "computed", {
  wrapClass: function wrapClass() {
    var disabled = this.data.get('disabled');
    var vertical = this.data.get('vertical');
    return ["".concat(prefixCls, "-wrap"), disabled && "".concat(prefixCls, "-disabled"), vertical && "".concat(prefixCls, "-vertical")].filter(function (c) {
      return c;
    });
  }
});

_defineProperty(Slider, "filters", {
  getStyle: function getStyle(value, type) {
    var _Object$assign;

    var ret = {};

    var _this$data$get4 = this.data.get(),
        showbar = _this$data$get4.showbar,
        max = _this$data$get4.max,
        min = _this$data$get4.min,
        vertical = _this$data$get4.vertical;

    var val = clamp(value, min, max);
    var offset = valueToPercent(val, min, max) + '%';

    switch (type) {
      case 'bar':
        Object.assign(ret, (_Object$assign = {}, _defineProperty(_Object$assign, vertical ? 'height' : 'width', offset), _defineProperty(_Object$assign, 'background-color', !showbar && 'transparent'), _Object$assign));
        break;

      case 'btn':
      case 'mark':
        Object.assign(ret, _defineProperty({}, vertical ? 'top' : 'left', offset));
        break;
    }

    return ret;
  }
});