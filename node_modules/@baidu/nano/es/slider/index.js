/**
 * @file 组件 slider 滑块
 * @author baozhixin <baozhixin@baidu.com>
 */

import './style/index.less';
import {Component, DataTypes} from 'san';

const prefixCls = 's-slider';

function clamp(value, min, max) {
    if (value < min) {
        return min;
    }
    if (value > max) {
        return max;
    }
    return value;
}

function valueToPercent(value, min, max) {
    return (value - min) * 100 / (max - min);
}

export default class Slider extends Component {
    // eslint-disable-next-line
    static template = /*html*/ `
        <div class="{{wrapClass}}" on-click="handleClick">
            <slot name="lead">
                <div s-if="lead" class="${prefixCls}-lead">{{lead}}</div>
            </slot>
            <div class="${prefixCls}">
                <div class="${prefixCls}-foo" style="{{value | getStyle('foo')}}">
                    <div
                        class="${prefixCls}-bar"
                        style="{{value | getStyle('bar')}}"
                    />
                </div>
                <div
                    s-for="mark in marks"
                    class="${prefixCls}-mark"
                    style="{{mark.value | getStyle('mark')}}"
                >
                    <div class="${prefixCls}-mark-label {{mark.value === value ? 'active' : ''}}">{{mark.label}}</div>
                    <div class="${prefixCls}-mark-value"></div>
                </div>
                <div
                    s-ref="button"
                    class="${prefixCls}-button-wrap"
                    style="{{value | getStyle('btn')}}"
                >
                    <slot name="button"><div class="${prefixCls}-button"/></slot>
                </div>
            </div>
            <slot name="tail">
                <div s-if="tail" class="${prefixCls}-tail">{{tail}}</div>
            </slot>
        </div>
    `;

    static dataTypes = {
        disabled: DataTypes.bool,
        lead: DataTypes.string,
        max: DataTypes.number,
        min: DataTypes.number,
        marks: DataTypes.array,
        showbar: DataTypes.bool,
        step: DataTypes.number,
        tail: DataTypes.string,
        value: DataTypes.number,
        vertical: DataTypes.bool
    };

    static computed = {
        wrapClass() {
            const disabled = this.data.get('disabled');
            const vertical = this.data.get('vertical');
            return [
                `${prefixCls}-wrap`,
                disabled && `${prefixCls}-disabled`,
                vertical && `${prefixCls}-vertical`
            ].filter(c => c);
        }
    };

    static filters = {
        getStyle(value, type) {
            let ret = {};
            const {showbar, max, min, vertical} = this.data.get();
            const val = clamp(value, min, max);
            const offset = valueToPercent(val, min, max) + '%';
            switch (type) {
                case 'bar':
                    Object.assign(ret, {
                        [vertical ? 'height' : 'width']: offset,
                        ['background-color']: !showbar && 'transparent'
                    });
                    break;
                case 'btn':
                case 'mark':
                    Object.assign(ret, {
                        [vertical ? 'top' : 'left']: offset
                    });
                    break;
            }
            return ret;
        }
    };

    get disabled() {
        return this.data.get('disabled');
    }

    get range() {
        const {max, min} = this.data.get();
        return max - min;
    }

    get vertical() {
        return this.data.get('vertical');
    }

    initData() {
        return {
            disabled: false,
            lead: '',
            max: 100,
            min: 0,
            marks: [],
            showbar: true,
            step: 1,
            tail: '',
            value: 0,
            vertical: false
        };
    }

    attached() {
        const that = this;
        const $slider = this.el;
        const $button = this.ref('button');
        const handelTouch = {
            handleEvent(event) {
                if (that.disabled) {
                    return;
                }
                let handler = event.type;
                if (typeof this[handler] === 'function') {
                    event.preventDefault();
                    return this[handler](event);
                }
            },
            reset() {
                this.startX = 0;
                this.startY = 0;
                this.deltaX = 0;
                this.deltaY = 0;
                this.offsetX = 0;
                this.offsetY = 0;
            },
            touchstart(event) {
                this.reset();
                this.startX = event.touches[0].clientX;
                this.startY = event.touches[0].clientY;
                this.startValue = that.data.get('value');
                const events = ['touchmove', 'touchend'];
                events.forEach(type => $button.addEventListener(type, this, false));
            },
            touchmove(event) {
                const touch = event.touches[0];
                this.deltaX = touch.clientX - this.startX;
                this.deltaY = touch.clientY - this.startY;
                this.offsetX = Math.abs(this.deltaX);
                this.offsetY = Math.abs(this.deltaY);

                const rect = $slider.getBoundingClientRect();
                const delta = that.vertical ? this.deltaY : this.deltaX;
                const total = that.vertical ? rect.height : rect.width;
                const diff = (delta / total) * that.range;

                that.updateValue(this.startValue + diff);
            },
            touchend() {
                const events = ['touchmove', 'touchend'];
                events.forEach(type => $button.removeEventListener(type, this));
            }
        };
        if ($button) {
            $button.addEventListener('touchstart', handelTouch, false);
        }
    }

    format(value) {
        const {max, min, step} = this.data.get();
        return Math.round(Math.max(min, Math.min(value, max)) / step) * step;
    }

    handleClick(event) {
        event.stopPropagation();
        const {disabled, max, min, vertical} = this.data.get();

        if (disabled) {
            return;
        }

        const rect = this.el.getBoundingClientRect();
        const delta = vertical ? event.clientY - rect.top : event.clientX - rect.left;
        const total = vertical ? rect.height : rect.width;
        const value = (delta / total) * (max - min) + min;

        this.updateValue(value);
    }

    updateValue(value) {
        const newValue = this.format(value);
        const oldValue = this.data.get('value');
        this.data.set('value', newValue);
        if (newValue !== oldValue) {
            this.fire('change', newValue);
        }
    }
}
