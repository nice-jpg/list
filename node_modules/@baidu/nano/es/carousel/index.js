/**
 * @file 组件 carousel 轮播图
 * @author baozhixin <baozhixin@baidu.com>
 * @see http://soy.baidu-int.com/component/Carousel
 */

import './style/index.less';
import {Component, DataTypes} from 'san';
import Image from '../image';
import Indicator from './indicator';

const prefixCls = 's-carousel';
const initTouchData = {
    startX: 0,
    startY: 0,
    deltaX: 0,
    deltaY: 0,
    offsetX: 0,
    offsetY: 0,
    direction: '',
    startTime: 0
};
const MIN_DISTANCE = 10;
function getDirection(x, y) {
    if (x > y && x > MIN_DISTANCE) {
        return 'horizontal';
    }
    if (y > x && y > MIN_DISTANCE) {
        return 'vertical';
    }
    return '';
}
const calcWidth = Math.min(window.innerWidth, 750);
// const halfWidth = calcWidth / 2;

export default class Carousel extends Component {
    // eslint-disable-next-line
    static template = /*html*/ `
        <div s-ref="carousel"
            class="${prefixCls}-wrap"
            style="{{wrapStyle}}"
            on-touchstart="handleTouchStart"
            on-touchmove="handleTouchMove"
            on-touchend="handleTouchEnd"
        >
            <div
                class="{{calcClass}}"
                style="{{calcStyle}}"
                on-transitionend="fixIndex"
            >
                <div
                    s-for="item, index in listData"
                    class="${prefixCls}-item"
                    on-click="handleItemClick(item, index)"
                >
                    <s-image
                        size="full"
                        url="{{item.imgSrc}}"
                    />
                </div>
            </div>
            <slot name="info">
                <div class="{{infoClass}}">
                    <div s-if="title" class="${prefixCls}-mask"/>
                    <div s-if="title" class="${prefixCls}-title">{{title}}</div>
                    <s-indicator
                        s-if="showIndicator"
                        index="{{curIndex}}"
                        count="{{count}}"
                        type="{{indicatorType}}"
                    />
                </div>
            </slot>
        </div>
    `;

    static components = {
        's-image': Image,
        's-indicator': Indicator
    };

    static dataTypes = {
        activeIndex: DataTypes.number,
        curIndex: DataTypes.number,
        animating: DataTypes.bool,
        autoplay: DataTypes.bool,
        delay: DataTypes.number,
        delta: DataTypes.string,
        height: DataTypes.number,
        indicatorType: DataTypes.oneOf(['dot', 'num']),
        indicatorPlacement: DataTypes.oneOf(['left', 'center', 'right']),
        list: DataTypes.array,
        loop: DataTypes.bool,
        showIndicator: DataTypes.bool,
        speedThreshold: DataTypes.number,
        touchable: DataTypes.bool,
        title: DataTypes.string
    };

    static computed = {
        wrapStyle() {
            const height = this.data.get('height');
            return {
                ['padding-top']: height > 0 && `${height / 12.42}%`
            };
        },

        calcStyle() {
            const delta = this.data.get('delta');
            const transform = `translateX(${delta}) scale(1)`;
            return {
                ['-webkit-transform']: transform,
                ['transform']: transform
            };
        },

        calcClass() {
            const animating = this.data.get('animating');
            const loop = this.data.get('loop');
            return [
                prefixCls,
                animating && `${prefixCls}-animate`,
                loop && `${prefixCls}-loop`
            ].filter(c => c);
        },

        infoClass() {
            const title = this.data.get('title');
            const placement = this.data.get('indicatorPlacement');
            return [
                `${prefixCls}-info`,
                !!title && `${prefixCls}-with-title`,
                (!title && placement) && `align-${placement}`
            ].filter(c => c);
        },

        count() {
            return this.data.get('list.length') || 0;
        },

        listData() {
            const list = this.data.get('list') || [];
            const loop = this.data.get('loop');
            return list.length && loop ? [list[list.length - 1], ...list, list[0]] : list;
        }
    };

    initData() {
        return {
            activeIndex: 0, // loop为true时：-1 ~ list.length
            curIndex: 0,
            animating: false,
            autoplay: true,
            delay: 3000,
            delta: '0',
            height: 0,
            list: [],
            loop: true,
            showIndicator: true,
            speedThreshold: 0.25,
            touchable: true,
            title: ''
        };
    }

    get activeIndex() {
        return this.data.get('activeIndex');
    }

    get touchable() {
        return this.data.get('touchable');
    }

    inited() {
        if (this.data.get('count') < 2) {
            this.data.set('touchable', false);
            this.data.set('loop', false);
        }
    }

    attached() {
        this.autoplay();
    }

    disposed() {
        this.stopAutoplay();
    }

    handleItemClick(item, index) {
        const {list, listData} = this.data.get()
        this.fire('item-click', {
            item,
            index: list.length === listData.length ? index : index - 1,
        });
    }

    handleTouchStart(e) {
        if (!this.touchable || e.changedTouches.length > 1) {
            return;
        }
        this.stopAutoplay();
        this.resetTouchData();
        this.swiping = true;
        this.fixIndex();
        this.data.set('animating', false);
        const touch = e.touches[0];
        Object.assign(this.touchData, {
            startX: touch.clientX,
            startY: touch.clientY,
            startTime: +new Date()
        });
    }

    handleTouchMove(e) {
        if (!this.touchable || !this.swiping) {
            return;
        }
        const {activeIndex, loop, count} = this.data.get();
        const touch = e.touches[0];
        const deltaX = touch.clientX - this.touchData.startX;
        const deltaY = touch.clientY - this.touchData.startY;
        const target = {
            deltaX,
            deltaY,
            offsetX: Math.abs(deltaX),
            offsetY: Math.abs(deltaY)
        };
        target.direction = this.touchData.direction || getDirection(target.offsetX, target.offsetY);
        if (target.direction === 'horizontal') {
            e.preventDefault();
            if (!loop && (activeIndex === 0 && deltaX > 0 || (activeIndex === count - 1) && deltaX < 0)) {
                this.swiping = false;
            }
            else {
                let delta = (deltaX - calcWidth * this.activeIndex) / calcWidth * 100;
                this.data.set('delta', `${delta}%`);
            }
        }
        Object.assign(this.touchData, target);
    }

    handleTouchEnd() {
        if (!this.touchable || !this.swiping) {
            return;
        }
        if (this.touchData.direction === 'horizontal') {
            let index = this.activeIndex;
            let speedThreshold = this.data.get('speedThreshold');
            let speed = this.touchData.offsetX / (+new Date() - this.touchData.startTime);
            if (this.touchData.offsetX >= calcWidth / 5 || speed >= speedThreshold) {
                this.touchData.deltaX > 0 ? --index : ++index;
            }
            this.moveTo(index);
        }
        this.swiping = false;
        this.autoplay();
    }

    moveTo(index, immediate = false) {
        let delta = -index * 100;
        this.data.set('animating', !immediate);
        this.data.set('activeIndex', index);
        this.data.set('delta', delta ? `${delta}%` : '0');

        const {count, curIndex} = this.data.get();
        if (index !== curIndex) {
            if (index > count - 1) {
                index = 0;
            }
            if (index < 0) {
                index = count - 1;
            }
            this.fire('change', {from: curIndex, to: index});
            this.data.set('curIndex', index);
        }
    }

    autoplay() {
        const {autoplay, delay, loop} = this.data.get();
        if (!autoplay || !loop) {
            return;
        }
        this.stopAutoplay();
        this.interval = setInterval(() => {
            this.moveTo(this.activeIndex + 1);
        }, delay);
    }

    stopAutoplay() {
        this.interval && clearInterval(this.interval);
    }

    resetTouchData() {
        this.touchData = Object.assign({}, initTouchData);
    }

    fixIndex() {
        let {count, activeIndex} = this.data.get();
        if (activeIndex >= count) {
            activeIndex = 0;
        }
        else if (activeIndex <= -1) {
            activeIndex = count - 1;
        }
        this.data.set('animating', false);
        this.moveTo(activeIndex, true);
    }
}
