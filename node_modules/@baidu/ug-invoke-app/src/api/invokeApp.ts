/**
 * @file invoke
 * @author zhangsiyuan(zhangsiyuan@baidu.com)
 */
import {appConfigMap, AppConfigName, AppName} from '../config/app/appConfigMap';
import {Browser} from '../config/app/browserMap';
import {Brand} from '../config/app/brandMap';
import {execInvoke} from './execInvoke';
import {Status} from '../config/Status';
import {getHostInfo, Os} from '../utils/detect/getHostInfo';
import {isHit} from '../utils/log/errorLog';

export interface InvokeConfig {
    appName: AppConfigName;
    token?: string;
    scheme?: string;
    toStore?: boolean;
    toYYB?: boolean;
    ulink?: string;
    timeout?: number;
    iosStoreUrl?: string;
    apkUrl?: string;
    failedUrl?: string;
    useDeeplink?: boolean;
    useNotTryList?: boolean;
    checkTokenCopied?: boolean;
    statRatio?: 0 | 10 | 20 | 50 | 100;
}

type Overwrite<T, U> = { [P in Exclude<keyof T, keyof U>]: T[P] } & U;

export interface InnerInvokeConfig extends Overwrite<Required<InvokeConfig>, {appName: AppName}> {
    browser: Browser;
    brand: Brand;
    os: Os;
    isHitStat: boolean;
    pkgName: string;
    marketScheme?: string;
}

export async function invokeApp({
    appName,
    token = '',
    scheme = '',
    toStore = true,
    toYYB = true,
    ulink,
    timeout = 2500,
    useDeeplink = false,
    apkUrl = '',
    failedUrl = '',
    useNotTryList = true,
    checkTokenCopied = true,
    iosStoreUrl = '',
    statRatio = 10,
}: InvokeConfig): Promise<Status> {

    // 不支持的端appName，应该直接抛错，不能用百度做回退
    if (!Object.keys(appConfigMap).includes(appName)) {
        return Promise.reject(Status.APPNAME_NOT_SUPPORT);
    }

    // 处理下参数
    const {appStoreUrl, pkgName, scheme: defaultScheme, getUlink} = appConfigMap[appName];
    const finalScheme = scheme || defaultScheme;
    const finalAppStoreUrl = iosStoreUrl || appStoreUrl;
    const finalUlink = ulink ?? getUlink(finalScheme, toStore ? finalAppStoreUrl : failedUrl);
    const isHitStat = isHit(statRatio);
    return execInvoke({
        ...getHostInfo(),
        isHitStat,
        appName,
        token,
        apkUrl,
        failedUrl,
        pkgName,
        scheme: finalScheme,
        iosStoreUrl: finalAppStoreUrl,
        toStore,
        toYYB,
        timeout,
        useDeeplink,
        ulink: finalUlink,
        useNotTryList,
        checkTokenCopied,
        statRatio,
    });
}

export interface InvokeTpConfig {
    token?: string;
    scheme: string;
    pkgName: string;
    failedUrl: string;
    iosStoreUrl?: string;
    apkUrl?: string;
    toStore?: boolean;
    toYYB?: boolean;
    ulink?: string;
    timeout?: number;
    checkTokenCopied?: boolean;
}

export async function invokeTpApp({
    token = '',
    scheme,
    toStore = false,
    toYYB = false,
    ulink = '',
    timeout = 2500,
    apkUrl = '',
    failedUrl = '',
    checkTokenCopied = true,
    iosStoreUrl = '',
    pkgName,
}: InvokeTpConfig): Promise<Status> {
    if (!scheme || (toStore || toYYB) && !pkgName) {
        console.error('invokeTpApp参数错误，请检查！');
        return Promise.reject(Status.PARAMS_ERROR);
    }
    const statRatio = 10;
    const isHitStat = isHit(statRatio);

    return execInvoke({
        ...getHostInfo(),
        isHitStat,
        appName: 'tp',
        token,
        apkUrl,
        failedUrl,
        pkgName,
        scheme,
        iosStoreUrl,
        toStore,
        toYYB,
        timeout,
        useDeeplink: false,
        ulink,
        useNotTryList: false,
        checkTokenCopied,
        statRatio,
    });
}
