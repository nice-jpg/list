/**
 * 事件代理，用法同Zepto.delegate
 * @namespace delegate
 * @author wangyongqing01
 * @version $Id: delegate.js 286585 2016-03-15 11:57:15Z wangyongqing01
 */

 /* globals tempParent, slice, matcher*/

import each from './each';
import guid from './guid';

const classSelectorRE = /^\.([\w-]+)$/;
const idSelectorRE = /^#([\w-]*)$/;
const tagSelectorRE = /^[\w-]+$/;
const hover = {
    mouseenter: 'mouseover',
    mouseleave: 'mouseout'
};
let handlers = {};
let returnTrue = function () {
    return true;
};
let returnFalse = function () {
    return false;
};
const ignoreProperties = /^([A-Z]|layer[XY]$)/;
const eventMethods = {
    preventDefault: 'isDefaultPrevented',
    stopImmediatePropagation: 'isImmediatePropagationStopped',
    stopPropagation: 'isPropagationStopped'
};

/**
 * on方法
 * @param  {element}   parentNode 父节点
 * @param  {string}   selector   选择器
 * @param  {string}   event      事件类型
 * @param  {Function} callback   回调函数
 */
export function on(parentNode, selector, event, callback) {
    return add(parentNode, event, callback, selector, fn => {
        return (e, ...args) => {
            let evt;
            let match = closest(e.target, selector, parentNode);
            if (match) {
                evt = createProxy(e);
                evt.currentTarget = match;
                evt.liveFired = parentNode;
                return fn.apply(match, [evt].concat(args));
            }
        };
    });
}
/**
 * off方法
 * @param  {Element}   parentNode 父节点
 * @param  {string}   selector   选择器
 * @param  {string}   event      事件类型
 * @param  {Function} callback   回调函数
 */

export function off(parentNode, selector, event, callback) {
    return remove(parentNode, event, callback, selector);
}

function bid(element) {
    return element._bid || (element._bid = guid());
}

function createProxy(event) {
    let key;
    let proxy = {
        originalEvent: event
    };
    for (key in event) {
        if (!ignoreProperties.test(key) && event[key] !== undefined) {
            proxy[key] = event[key];
        }
    }
    each(eventMethods, function (predicate, name) {
        proxy[name] = function () {
            this[predicate] = returnTrue;
            return event[name].apply(event, arguments); // eslint-disable-line
        };
        proxy[predicate] = returnFalse;
    });
    return proxy;
}

function parse(event) {
    let parts = ('' + event).split('.');
    return {
        e: parts[0],
        ns: parts.slice(1).sort().join(' ')
    };
}

function add(element, events, fn, selector, getDelegate, capture) {
    let id = bid(element);
    let set = (handlers[id] || (handlers[id] = []));

    eachEvent(events, fn, function (event, fn) {
        let handler = parse(event);
        handler.fn = fn;
        handler.sel = selector;
        // emulate mouseenter, mouseleave
        if (handler.e in hover) {
            fn = function (e) {
                let related = e.relatedTarget;
                if (!related || (related !== this && !contains(this, related))) {
                    return handler.fn.apply(this, arguments); // eslint-disable-line
                }
            };
        }
        handler.del = getDelegate && getDelegate(fn, event);
        let callback = handler.del || fn;
        handler.proxy = function (e) {
            let result = callback.apply(element, [e].concat(e.data));
            if (result === false) {
                e.preventDefault();
                e.stopPropagation();
            }
            return result;
        };
        handler.i = set.length;
        set.push(handler);
        if ('addEventListener' in element) {

            element.addEventListener(realEvent(handler.e), handler.proxy, eventCapture(handler, capture));
        }
    });
}

function realEvent(type) {
    return hover[type] || type;
}

function eventCapture(handler, captureSetting) {
    return handler.del
    && (handler.e === 'focus' || handler.e === 'blur') || !! captureSetting;
}

function eachEvent(events, fn, iterator) {
    events.split(/\s/).forEach(function (type) {
        iterator(type, fn);
    });
}

function remove(element, events, fn, selector, capture) {
    let id = bid(element);
    eachEvent(events || '', fn, function (event, fn) {
        findHandlers(element, event, fn, selector).forEach(function (handler) {
            delete handlers[id][handler.i];
            if ('removeEventListener' in element) {
                element.removeEventListener(realEvent(handler.e), handler.proxy, eventCapture(handler, capture));
            }
        });
    });
}



function findHandlers(element, event, fn, selector) {
    let eventFormat = parse(event);
    let matcher;
    if (eventFormat.ns) {
        matcher = matcherFor(eventFormat.ns);
    }
    return (handlers[bid(element)] || []).filter(function (handler) {
        return handler
        && (!eventFormat.e || handler.e === eventFormat.e)
        && (!eventFormat.ns || matcher.test(handler.ns))
        && (!fn || bid(handler.fn) === bid(fn))
        && (!selector || handler.sel === selector);
    });
}

function closest(node, selector, context) {
    let collection = false;

    while (node && !(collection ? collection.indexOf(node) >= 0 : matches(node, selector))) {
        node = node !== context && !isDocument(node) && node.parentNode;
    }
    return node;
}

function isDocument(obj) {
    return obj != null && obj.nodeType === obj.DOCUMENT_NODE;
}

function matcherFor(ns) {
    return new RegExp('(?:^| )' + ns.replace(' ', ' .* ?') + '(?: |$)');
}

function matches(element, selector) {
    if (!element || element.nodeType !== 1) {
        return false;
    }
    let matchesSelector = element.webkitMatchesSelector || element.matchesSelector;
    if (matchesSelector) {
        return matchesSelector.call(element, selector);
    }
    // fall back to performing a selector:
    let match;
    let parent = element.parentNode;
    let temp = !parent;
    if (temp) {
        parent = tempParent;
        parent.appendChild(element);
    }
    match = ~qsa(parent, selector).indexOf(element);
    temp && tempParent.removeChild(element);
    return match;
}

function qsa(element, selector) {
    let found;
    return (isDocument(element) && idSelectorRE.test(selector))
        ? ((found = element.getElementById(RegExp.$1))
        ? [found] : []) : (element.nodeType !== 1 && element.nodeType !== 9)
        ? [] : slice.call(classSelectorRE.test(selector)
            ? element.getElementsByClassName(RegExp.$1) : tagSelectorRE.test(selector)
            ? element.getElementsByTagName(selector) : element.querySelectorAll(selector));
}

function contains(parent, node) {
    return parent !== node && parent.contains(node);
}
