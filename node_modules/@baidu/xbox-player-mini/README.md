# @baidu/xbox-player

播放器jssdk，创建并控制video视频播放器，在手百端内创建同层渲染播放器

## 下载

通过npm拉取包如下：

```bash
npm install @baidu/xbox-player --registry http://registry.npm.baidu-int.com
```

拉取的包目录结构如下：

```js
@baidu/xbox-player
├── README.md
├── dist
      ├── player.amd.js // amd版本
      ├── player.min.js // umd压缩版
│     └── player.umd.js // 未压缩版
├── package.json        // 默认导出amd版本，esm引用方式参见下方
├── index.js
└── ...
```

> 最新版本：

> 完整版：@baidu/xbox-player@1.0.0，前端gzip后为9.8k

> 精简版：@baidu/xbox-player-mini@1.0.0 ，前端gzip后为8.41k

> demo参考：[http://zhangtingting.bcc-bdbl.baidu.com:8091/xbox-player/index.html](http://zhangtingting.bcc-bdbl.baidu.com:8091/xbox-player/index.html)

## 安装
### script

拉取到的npm目录下`dist`文件夹内，是使用umd模块规范导出的压缩版`player.min.js`和未压缩版`player.umd.js`
可通过`script`标签内置到项目中引用，引用时：若页面上没有AMD环境，将会在页面上注册全局变量`XPlayer`

```js
var Player = window.XPlayer.default;
var player = new XPlayer({...})
```

### AMD
使用AMD方式引入，需要先配置好 packages 或 paths 项

```js
require.config({
    packages: [
        {
            name: 'XPlayer',
            location: 'xbox-player-path/dist/player.amd.js'
        }
    ]
});
```


### ESNext

在支持 ESNext 的环境中，可以直接引用

```js
import XPlayer from '@baidu/xbox-player/index';

```

## 使用

- Step 1:

    ```html
    <div id="video1"></div>
    ```

- Step 2:

    ```js
    import XPlayer from '@baidu/xbox-player/index';
    // 初始化一个实例
    let player = new XPlayer({
        id: 'video1',
        vid: 'sv_1111',
        src: 'https://b.bdstatic.com/miniapp/development_tool/Smartprogram.mp4',
        poster: 'https://gss0.bdstatic.com/5foIcy0a2gI2n2jgoY3K/static/smartprogram-developer/img/video_cover.90f71a8.png',
        prepareInvokePlayerTime: +new Date
        // 这里可以填写初始化参数，例如autoplay等，具体参见下节
    });
    // 生命周期的ready事件需要在创建前提前监听
    player.on('ready', (data) => {
        console.log('ready event');
        if (data.mode === 'na') {
            console.log('创建的是同层播放器')
        }
        if (data.mode === 'h5') {
            console.log('创建的是h5播放器')
        }
    });
    // 真正开始创建
    player.create();
    ```

    这是最简单的播放器配置方法，更多详细功能可查阅下面api,并参考[demo](http://zhangtingting.bcc-bdbl.baidu.com:8091/xbox-player/index.html)

同层播放器需要在手百调试，页面调试工具推荐：

- [san-devtools](https://www.npmjs.com/package/san-devtools)
- [devtools-pro](https://www.npmjs.com/package/devtools-pro)

## Player API

> 同层渲染支持：iOS百度APP12.9 轻框架+搜索框架，Android百度APP12.10搜索框架。

> 双端属性和方法有所差异，支持情况详见具体api；在不满足百度APP版本或同层失败的情况下，jssdk内会创建h5的video播放器，当前播放器类型，可见下文ready事件返回的data；若业务方需要在NA播放器无法创建时自行处理，只需在new实例指定创建参数`customizedVideo`为true

### 属性

将播放器的属性分为以下三类：
- **初始化参数**: 在`var player = new XPlayer(options)`时，仅可在options中传递的播放器配置的参数，实例生成后不可修改
- **可读属性**：仅可在播放器实例存在期间通过`player.${属性名}`来进行读取，不可赋值，如：`player.ended`、`player.duration`
- **可读可写属性**：既可在在player实例上获取，又可设置的属性，部分属性支持在初始化参数传入，如：`player.src`、`player.muted` 使用方式与h5 的video同名属性相同，例如静音`player.muted = true;`

接下来逐一介绍各个分类下的属性

#### 1.初始化参数

|名称|含义|类型|是否必选|ios|android|h5|
| -- | -- | -- | -- | -- | -- | -- |
|width|视频宽度，不传默认为外层占位div的大小|number|否|✔️|✔️|✔️|
|height|视频宽度，不传默认为外层占位div的大小|number|否|✔️|✔️|✔️|
|precreate|预创建播放器，默认值为false|boolean|否|✔️|-|-|
|customizedVideo|若业务方需在同层失败时指定自身处理逻辑，将此值置为true，jssdk不会创建退化方案的h5 video|boolean|否|✔️|✔️|-|
|vid|视频id|string|是|✔️|✔️|✔️|
|prepareInvokePlayerTime|用户点击按钮开始创建播放器的时间戳，用于起播性能统计|string/number|是|✔️|✔️|-|
|from|视频日志ubc打点来源，如未传入，则默认为："samelrPlayer"|string|否|✔️|✔️|-|
|page|视频日志ubc打点当前页面类型，如未传入，则默认值为："samelrPage"|string|否|✔️|✔️|-|
|value|视频日志ubc打点详细场景，如未传入，则默认值为空|string|否|✔️|✔️|-|
|ext|视频日志透传字段|object|否|✔️|✔️|-|
|needReadLocalProgress|是否读取本地进度（从本地存储的进度开始播放）默认不读取，若需读取置为true 双端12.9开始支持|boolean|否|✔️|✔️|-|
|ignore4gToast|是否忽略4G提示，默认提示，若需屏蔽提示置为true，双端12.9开始支持|boolean|否|✔️|✔️|-|
|title|播放器标题|string|否|✔️|-|-|
|pageUrl|播放器对应网页地址|string|否|✔️|✔️|-|
|seekSeconds|从第几秒开始启播|number|否|✔️|-|-|
|isDefaultBackgroundClearColor|是否清除背景色（默认为灰色）默认为false|boolean|否|✔️|-|-|
|isHiddenDefaultBgImage|是否隐藏默认背景图（带有百度logo的图片）默认为false|boolean|否|✔️|-|-|
|videoGravity|ios视图填充模式：0：铺满整个视图1：等比缩放 ( 默认 )2: 等比填充，默认为1，当取2时，sdk内通过设置安卓标签样式实现铺满全屏|number|否|✔️|✔️|-|
|isIgnoreVolumeChange|是否忽略物理声音变化，默认为false不忽略，若为true忽略，则系统声音变化不会影响静音状态|boolean|否|✔️|-|-|
|playerControlType|ios播放器控件层类型0：只有一个播放画面, 不显示任何控件，1：仅显示底部沉浸式进度条 2：显示默认的控件层，默认0|number|否|✔️|-|-|
|syncPlayerCacheProgress|是否向前端播放器缓存进度，默认0，此参数控制cachetimechange是否触发|number|否|✔️|-|-|
|isPlayerCanEnterEndPage|ios端是否显示结束的重新播放蒙层，默认1显示，传为0时，可屏蔽结束的蒙层|number|否|✔️|-|-|
|preload|页面载入后自动加载，默认false|bollean|否|-|✔️|✔️|
| clarityUrl |清晰度参数，12.23增加，参数格式见：http://wiki.baidu.com/pages/viewpage.action?pageId=504577788，注意：传入正确的数组数据或者空字符串|array|否|✔️|✔️|-|
| mpd |清晰度参数，12.23增加，参数格式见：http://wiki.baidu.com/pages/viewpage.action?pageId=1522277714，优先级：mpd > clairty > videoUrl > src，在安卓端mpd和clarityUrl同时存在时，不再传递clarityUrl，注意：传入正确的对象数据或者空字符串|object|否|✔️|✔️|-|
| passThrough |12.23增加，安卓通过该参数配置透传的key，通过videoInfo透传，例如：["title"]|array|否|-|✔️|-|
| useAutoVolume |搜索场景，安卓使用端上控制音量参数，13.2增加，默认false |boolean|否|-|✔️|-|



#### 2.可读属性

|名称|含义|类型|ios|android|h5|
| -- | -- | -- | -- | -- | -- |
|src|视频播放地址，支持在初始化参数传入|string|是|✔️|✔️|✔️|
|poster|播放器封面图，支持在初始化参数传入|string|是|✔️|✔️|✔️|
|duration|播放时长 单位(秒)|number|✔️|✔️|✔️|
|ended|是否结束true or false|boolean|✔️|✔️|✔️|
|fullscreen|是否全屏true or false|boolean|✔️|✔|✔️|
|networkState|表示音频/视频元素的当前网络状态：ios同层场景只有0和2|0 = NETWORK_EMPTY - 音频/视频尚未初始化 1 = NETWORK_IDLE - 音频/视频是活动的且已选取资源，但并未使用网络 2 = NETWORK_LOADING - 浏览器正在下载数据 3 = NETWORK_NO_SOURCE - 未找到音频/视频来源|number|✔️|✔|✔️|
|error|错误信息||✔️|✔|✔️|
|paused|是否暂停|boolean|✔️|✔|✔️|
|readyState|就绪状态|在ios中只有0 没有音视频数据 1开始准备播放 4 准备播放缓冲成功|number|✔️|✔|✔️|
|isExistSuspense|是否存在小窗 true or false,在ios中返回promise|boolean/promise|✔️|✔|✔️|
|suspenseType|若存在小窗则返回类型：supense:手百应用内小窗，pip:系统画中画小窗,默认supense |number|✔️|-|-|

> 1. 对于src和poster属性，仅支持读取，如需更改可调用统一的reset方法：

```js
player.reset({
    src: 'xxx',
    poster: 'xxx'
})
```

> 对于isExistSuspense属性在ios端内会返回一个promise，取值可参考如下

```js
    var isExistSuspense = player.isExistSuspense;
    var result = 0;
    if (Object.prototype.toString.call(isExistSuspense).slice(8, -1).toLowerCase() === 'promise') {
        isExistSuspense.then(function(data) {
            result = data;
        });
    }
    else {
        var result = isExistSuspense;
    }
    console.log(isExistSuspense);

```

#### 3.可读可写属性

既可在初始化参数传入，又可在player实例上获取并设置的属性，例如muted属性：

```js
    let player = new XPlayer({
        id: 'video1',
        vid: 'sv_1111',
        src: 'https://b.bdstatic.com/miniapp/development_tool/Smartprogram.mp4',
        poster: 'https://gss0.bdstatic.com/5foIcy0a2gI2n2jgoY3K/static/smartprogram-developer/img/video_cover.90f71a8.png',
        muted: false
    });

    player.muted = true
```

|名称|含义|类型|是否必选|ios|android|h5|
| -- | -- | -- | -- | -- | -- | -- |
|autoplay|是否自动播放，默认false，支持在初始化参数传入|boolean|否|✔️|✔️|✔️|
|loop|是否循环播放，默认false，支持在初始化参数传入|boolean|否|✔️|✔️|✔️|
|muted|是否静音，默认false，支持在初始化参数传入，双端已和系统静音态同步，业务方可以直接获取和设置muted即可，不需要额外处理|boolean|否|✔️|✔️|✔️|
|currentTime|播放时长 单位(秒)|number|否|✔️|✔️|✔️|
|playbackRate|播放倍速 0.75~3，支持在初始化参数传入|number|否|✔️|✔️|✔️|
|volume|音量设置，支持在初始化参数传入，双端已和系统音量同步，业务方可以直接获取和设置volume即可，不需要额外处理|number|否|✔️|✔️|✔️|
|fullScreenType|播放器默认进入全屏类型"h5FullScreen" ：进入H5页面全屏（前端绘制全屏控件）"windowFullScreen"：进入window全屏 （客户端绘制全屏控件），默认：1.半屏使用playerControlType = 2（半屏使用NA控件时），默认全屏为windowFullScreen（使用window全屏-即全屏也是NA控件）2.半屏使用前端自定义控件时，默认全屏为h5FullScreen（使用H5全屏-即使用前端自定义全屏），支持在初始化参数传入，配合全屏方法使用|string|否|✔️|-|-|
|isIgnoreDeviceOrientation|是否忽略随设备转屏事件。true：忽略转屏事件（默认）false: 随设备转屏，播放器进行转屏，默认true，支持在初始化参数传入|number|否|✔️|-|-|
|timeInterval|ios端timeupdate回调的时间间隔，默认1|number|否|✔️|-|-|


## Player提供的方法

|方法名|含义|使用方法|
|--|--|--|
|create|创建播放器|`player.create()`，可通过create传参数，改变jssdk行为，第一个参数指定ios端同层的重试次数（默认为6），第二个参数指定仅创建h5 video，例如：`player.create(6)`|
|play|播放，暂停之后可使用该方法继续播放|`player.play()`|
|pause|暂停|`player.pause()`|
|replay|重新开始播放|`player.replay()`|
|destroy|销毁player实例|`player.destroy()`|
|enterFullscreen|进入全屏，双端差异：ios可选h5全屏和widow全屏（区别是：widow全屏的控件层不可定制，通过设置fullScreenType值使用）且区分方向：90顺时针、-90逆时针、0竖全屏；android全屏只有系统全屏（控件默认）同时全屏方向根据当前框架的不同而不同|`player.enterFullscreen(90)`|
|exitFullscreen|退出全屏|`player.exitFullscreen()`|
|enterSuspense|进入小窗，对应的进入小窗事件|`player.enterSuspense()`|
|exitSuspense|退出小窗->恢复落地页，会触发对应退出小窗、小窗点击事件，恢复落地页的动作需要业务方在监听到退出小窗事件后，自行invoke页面|`player.exitSuspense()`|
|closeSuspense|关闭小窗，配会触发对应关闭小窗事件|`player.closeSuspense()`|
|enterSystemSuspense|ios进入系统小窗，ios14+可用，触发对应事件，android无此方法|`player.enterSystemSuspense()`|
|closeSystemSuspense|ios退出系统小窗，ios14+可用，触发对应事件，android无此方法|`player.closeSystemSuspense()`|
|reset|重置播放器参数，只适用于修改width和height等参数，在涉及到修改src时请使用destroy后重新new的方式，此方法完成后会触发reset事件|
|prefetch|双端支持视频预取，可直接调用例如：`import {prefetch} from 'xbox-player';`,预取的视频信息{allNets, maxSize, prefetchInfo},其中prefetchInfo作为参数传入，视频格式参见：[参数](http://tekes.baidu-int.com/web/#/doc?doc=%2Freferences%2Ftopics%2Fmultimedia%2Fpublic%2Fvideoplayer%2Fseniormanual%2Fprefetch)|

播放器自身方法

|方法名|含义|使用方法|
|--|--|--|
|registryPlugin| 注册一个插件|`player.registryPlugin(pluginKey, pluginClass)`|
|registryPlugins| 注册一组插件|`player.registryPlugin(plugins = {key1: Plugin1, key2: Plugin2})`|
|on|注册事件监听|`player.on(eventname, callback)`|
|once|仅监听一次|`player.once(eventname, callback)`|
|off|移除事件监听|`player.off(eventname, callback)`|
|emit|触发事件|`player.emit(eventname, data)`|


## Player提供的事件
播放器事件变化时会触发一些固定事件

|事件名|含义|说明|ios|android|h5|
|--|--|--|--|--|--|
|init|sdk初始化开始||✔️|✔️|✔️|
|ready|sdk创建播放器完毕|该方法会返回播放器当前模式mode：na(同层播放器)/h5(原生标签)，isIOS是否ios系统,isAndroid是否安卓系统，当mode为h5代表创建的标签是原生的video，所有控制方法均为对原生video标签的控制，使用方式:`player.on('ready', function({mode, isIOS,isAndroid}){})`|✔️|✔️|✔️|
|reset|调用reset方法后，会触发此事件|该方法会返回新的options，使用方式:`player.on('reset', function(options){})` |✔️|-|-|
|destroy|sdk创建的播放器销毁，会触发此事件|使用方式:`player.on('destroy', function(){})` |✔️|✔️|✔️|
|prepare|开始准备播放|ios特定事件|✔️|-|-|
|play|播放|ios中是启播成功|✔️|✔️|✔️|
|pause|暂停||✔️|✔️|✔️|
|ended|结束||✔️|✔️|✔️|
|error|错误||✔️|✔️|✔️|
|closed|播放器关闭|ios特定事件|✔️|-|-|
|canplay|视频可以播放|ios中是准备播放缓冲成功|✔️|✔️|✔️|
|timeupdate| 播放进度改变 |ios可使用timeInterval改变回调时间间隔|✔️|✔️|✔️|
|volumechange| 声音变化 |双端已和系统音量同步，业务方可以直接获取和设置volume即可，不需要额外处理|✔️|✔️|✔️|
|mutedchange| 静音状态变化 |双端已和系统静音态同步，业务方可以直接获取和设置muted即可，不需要额外处理|✔️|✔️|✔️|
|loadingchange|加载状态变化|ios特定事件|✔️|-|-|
|cachetimechange|缓存进度变化|ios特定事件|✔️|-|-|
|cacheloadfinished|缓存完成|ios特定事件|✔️|-|-|
|ratechange|播放速度发生变化||✔️|✔️|✔️|
|startnextloop|开始循环播放|ios特定事件|✔️|-|-|
|enterfullscreen|进入全屏||✔️|✔️|✔️|
|exitfullscreen|退出全屏||✔️|✔️|✔️|
|netchange|网络变化|ios特定事件|✔️|-|-|
|controlhiddenchange|na控件隐藏事件|ios特定事件|✔️|-|-|
|entersuspense|进入悬浮窗||✔️|✔️|-|
|suspenseclick|悬浮窗点击事件，业务方需要在此事件内invoke需要的恢复的落地页||✔️|✔️|-|
|exitsuspense|退出悬浮窗，恢复落地页，恢复的操作需要业务方自行处理||✔️|✔️|-|
|closesuspense|关闭悬浮窗||✔️|✔️|-|
|enterpip|iOS14+支持，进入系统pip小窗||✔️|-|-|
|closepip|iOS14+支持，关闭系统pip小窗||✔️|-|-|
|pipclick|iOS14+支持，点击系统pip小窗恢复落地页||✔️|-|-|
|pipfail|iOS14+支持，开启系统pip小窗失败||✔️|-|-|
|abort|当音频/视频的加载已放弃时||-|✔️|✔️|
|canplaythrough|当浏览器可在不因缓冲而停顿的情况下进行播放时||-|✔️|✔️|
|durationchange|当视频的时长已更改时||-|✔️|✔️|
|emptied|当目前的播放列表为空时||-|✔️|✔️|
|loadeddata|当浏览器已加载视频的当前帧时||-|✔️|✔️|
|loadedmetadata|当浏览器已加载视频的元数据时||-|✔️|✔️|
|loadstart|当浏览器开始查找视频时||-|✔️|✔️|
|playing|当视频在已因缓冲而暂停或停止后已就绪时||✔️|✔️|✔️|
|progress|当浏览器正在下载视频时||-|✔️|✔️|
|seeked|当用户已移动/跳跃到视频中的新位置时||-|✔️|✔️|
|seeking|当用户开始移动/跳跃到视频中的新位置时||-|✔️|✔️|
|stalled|当浏览器尝试获取媒体数据，但数据不可用时||-|✔️|✔️|
|suspend|当浏览器刻意不获取媒体数据时||-|✔️|✔️|
|waiting|当视频由于需要缓冲下一帧而停止||-|✔️|✔️|
|perf|监听此事件（注意只有在autoplay为true时才返回，否则起播速度无意义）,返回jssdk内的耗时数据包括：1.点击到播放耗时clk2play 2.ios查询次数：count 3.ios查询成功耗时querysuc 4.ios查询失败耗时queryfail 5.创建开始到结束耗时create 6.点击到创建开始耗时：clk2create（参考指标） 7.点击到开始查询耗时clk2query:（参考指标）,另外还有一个model参数(12.14支持，之前为null，非必要无需发送)，主要用于ios端同层失败统计的机型信息：{"systemVersion": iphone系统版本号, "deviceInfo": iphone设备信息, "bdVersion": 手百版本号}||✔️|✔️|✔️|

### 监听方式
```js
player.on('事件名', function() {
  // 事件名称可以在上述查询
})
player.once('事件名', function() {
})
player.off('事件名', function() {
})
player.emit('事件名')
```


## plugin
插件对象，构造函数中会传入player实例
分为两类:
- 扩展方法：run方法作为默认的执行函数
- 扩展属性：get和set方法作为取值和赋值时默认执行函数

每个player的功能都是一个plugin

## 生命周期
- `init` player实例化初始化
- `ready` 创建完成
- `reset` 视频信息重置
- `destroy` 实例销毁


## 内部实现
**player播放器核心类**：
- 内置基本属性实现
- 内置基本create，play，pause等方法定义
- 事件监听，生命周期
- 实现plugin机制，播放器功能可按需增强，支持插件对象命令扩展及内部命令覆盖

**内置百度APP端内增强插件**
实现双端同层渲染，端内create、play、pause等播放控制，统一双端播放器

## 同层播放器的几点说明

1. 端内是否支持自动播放？

    支持，同层播放器就是端上的播放器，没有h5不能自动播放的限制，使用方式：`new XPlayer()`时传入autoplay=true，或在player.create()调用之前使用`player.autoplay = true`；播放器创建后设置无效

2. sdk提供的端内播放器有哪些默认功能？

    sdk实际上只提供了**底层播放器创建与销毁，播放器控制等api**，业务方无需考虑端内同层流程，直接使用player.create即可创建出同层的播放器，可以通过sdk的实例获取和更改播放器属性，但是，sdk提供的双端统一播放器**仅为一个播放画面**（也即：没有播放，暂停按钮，没有进度条等等，这类播放控件UI），因此播放器显示的UI完全可用业务方自由定制，实现双端统一

    > ps: 双端提供的同层播放器样式其实并不一致，ios端内同层播放器提供三种类型的播放器（playerControlType来控制：0只有一个播放画面，1仅显示底部进度条，2默认控件层，默认是0），安卓端内同层播放器只提供一个播放画面，控件层需要业务方实现


3. 端内全屏的不同(暂时只推荐使用系统全屏)

    ios端支持两种类型的全屏：h5全屏和window全屏（使用fullScreenType取值来设置，若业务方未设置，则根据playerControlType的取值来控制，当playerControlType为2时，也即端上默认控件，此时全屏api会进入window全屏，playerControlType取0和1时，全屏使用h5的全屏），区别是：widow全屏的控件层不可定制，h5全屏只有一个全屏画面，因此全屏后的控件如"返回按钮"需要业务方实现
    ios端两种类型的全屏可以区分方向：90顺时针、-90逆时针、0竖全屏；使用方式：`player.enterFullscreen(90)`
    android全屏只有系统全屏（控件默认）同时全屏方向根据当前框架的不同而不同，不能指定方向

4. 小窗api的使用流程

    进入小窗可调用`player.enterSuspense()`，成功后会触发`entersuspense`事件这是手百的小窗，双端支持
    在小窗中点击画面，会触发`suspenseclick`事件，在这里可以做自己的业务逻辑
    调用`player.exitSuspense()`方法退出小窗，在同一个页面操作时播放器会恢复到页面原播放器位置，在其他页面操作时会触发`exitsuspense`事件，业务方可根据该事件进行页面的恢复invoke操作，该最后会关闭小窗
    调用`player.closeSuspense()`方法可直接关闭小窗并触发`closesuspense`事件

5. jssdk对端内页面跳转及回退处理

    由于android端同层播放器基于原生video标签扩展实现，因此播放器的标签在页面跳转及跳转返回均与原生标签相同，在此不再赘述
    主要讲一下ios端播放器的处理，分三种场景：
    （1）当前页面reload，页面刷新后，由jssdk创建的播放器标签销毁，端上播放器也跟着销毁
    （2）当前页面通过url方式跳转到另一页面，此时同上页面标签销毁，端上播放器也跟着销毁；通过浏览器后退读取页面缓存时，当player实例存在时，jssdk会根据缓存的数据重新创建播放器在对应的位置上，若页面跳转前是播放状态，恢复时也会恢复播放器状态
    （3）当页面通过schema跳转时，相当于另一个页面盖住当前页面，安卓端内核回默认同步进度，ios端是由jssdk处理，jssdk内会检测页面隐藏事件，将当前正在播放的视频进行暂停，待页面重新露出即可恢复播放，（ios的jssdk内是通过visibilitychange事件实现，如业务方使用其他事件，可在页面重新显示时调用player.reset({src: player.src})，也可选择使用端能力：http://es.baidu-int.com/index#/apidetail/1161 来读取本地进度后设置player.currentTime)
    
    > 搜索页面存在h5跳六合NA无法触发前端事件的情况，具体问题解决见：http://wiki.baidu.com/pages/viewpage.action?pageId=1368294359


6. 日志处理

    目前端内同层播放器的日志依赖于端上的播放器打点，业务方在使用时可以根据ubc规范传入自定义的`from`、`page`、`value`、`ext`，注意`prepareInvokePlayerTime`参数，是在点击创建播放器时的时间戳，主要用于起播的性能统计，在new XPlayer时必传

7. 预取

    sdk提供的单独的prefetch方法，业务方可在合适时机调用（一般是在创建播放器之前），例如：`import {prefetch} from 'xbox-player';` 具体参见api说明

8. 续播功能

    双端的同层播放器续播功能由端上记录，使用时请在初始化时设置`needReadLocalProgress`的值(需要增加pageUrl参数用于同步进度，pageUrl 是指播放视频的网页地址，安卓尤其需要，在ios端也可传递pageUrl，当从 A-B 跳转时，需要保证调起B页面 schema 拼接的 pageUrl 与 A页面传入同层播放器的pageUrl相同)，安卓端同时传入 `needReadLocalProgress` 和 `pageUrl` 即可实现续播；ios 端除需要设置以上两个选项，还需要：1. 在A页面点击跳转时调用 [保存进度端能力](http://es.baidu-int.com/index#/apidetail/1160)存储进度，2. 在B页面返回到A页面时(可监听h5的visibilitychange事件)，在A页面调用 [读取进度](http://es.baidu-int.com/index#/apidetail/1161) 获得当前进度值，并赋值给 `player.currentTime` 以调整播放器进度实现同步。
    同层参数`needReadLocalProgress` 双端12.9支持NA播放器视频的同步，包括同层播放器和短视频，小视频同步存在策略问题，12.10支持。ios 进度保存和读取端能力 11.24 支持。

9. 视频切换

    在JSSDK内切换视频使用reset方法，双端同层播放器在src切换时，播放内核都会销毁重建，但端上的播放器实例在页面内是复用的，因此对起播速度无影响

10. 视频默认等比缩放，需要铺满全屏在new时传入`videoGravity:2`

11. 实现圆角样式

```js

<div class="videowrap">
    <div class="video" id="video1"></div>
</div>

<style>
    .videowrap {
        width: 140px;
        height: 225px;
        position: relative;
    }
    .video {
        width: 100%;
        height: 100%;
        position: absolute;
        top: 0;
        left: 0;
        z-index: 0;
        overflow: hidden;
        border-radius: 10px;
    }
    .video > video {
        border-radius: 10px;
    }
<style>


player = new Player({
    id: 'video1',
    vid: 'vid_6726378263',
    src: 'https://vdse.bdstatic.com//31c84819c9c5607ec0debfe24f6cdc98.mp4',
    videoGravity: 2
});
```

## 版本库地址

http://icode.baidu.com/repos/baidu/hulk/xbox/tree/master


