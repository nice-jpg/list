/**
 * @file Create
 * @author zhangtingting12 <zhangtingting12@baidu.com>
 */
/**
 * ios端内外标签高度
 * @param {number} height 生成ios的特殊dom高度，需要内部高度大于外部，触发overflow:scroll
 */
const genDomHeight = height => ({wrap: height, inner: height + 1});
export default class Create {
    constructor(api, pluginOptions) {
        this.api = api;
        this.pluginOptions = pluginOptions; // 暂时定义为new Player时用户传过来的
        this.perf = {}; // 记录时间点:clk点击, createStart开始创建,queryStart开始查询
        this.perflog = {}; // 记录耗时
        this.isEmitPerf = false; // 控制性能事件发送
        this.api.on('reset', data => this.reset(data));
        this.api.on('destroy', () => this.destroy());
    }
    // 可设置查询次数，使用h5模式 h5Mode=true
    run(iosMaxQueryCnt, h5Mode) {
        if (this.api.getVideoInstance() || !this.api.getRoot()) {
            return;
        }
        const options = this.api.getPlayerOption();
        this.perf.createStart = +new Date;
        this.perf.clk = options.prepareInvokePlayerTime || this.perf.createStart;
        const {isMainBox, version, versionCompare, isIOS, isAndroid} = this.api.getBoxTools();
        this.isIOS = isIOS();
        this.isAndroid = isAndroid();
        const getRandomName = this.api.getBoxTools().getRandomName;
        this.cid = getRandomName('h5-samelayer-cid-') || this.cid;
        this.api.setPlayerOption('containerId', this.cid);
        // 业务方指定了同层失败不使用默认video标签，也即只触发mode=h5，不创建video
        options.customizedVideo && this.api.setPlayerController('slrOnly', true);
        // ios在12.9时功能完全,android在12.10时功能完全
        if (!h5Mode && isMainBox()
            && (this.isIOS && versionCompare(version, '12.9') >= 0
                 || this.isAndroid && versionCompare(version, '12.10') >= 0)
        ) {
            if (this.isIOS) {
                this.iosMaxQueryCnt = iosMaxQueryCnt || 5;
                return this.iosCreateVideo();
            }
            else if (this.isAndroid) {
                return this.androidCreateVideo(options.pageUrl);
            }
        }
        this.h5Run();
    }
    destroy() {
        const invokeP = this.api.getBoxTools().invokeP;
        const video = this.api.getVideoInstance();
        const controller = this.api.getPlayerController();
        if (this.api.getMode() === 'na') {
            // 卸载页面事件
            window.removeEventListener('pagehide', controller.pagehideHandler);
            window.removeEventListener('pageshow', controller.pageshowHandler);
            if (this.isIOS) {
                const eventCallback = controller.eventCallback;
                window[eventCallback] = () => {};
                invokeP('video/slrStopPlayer', {params: {containerId: this.cid}});
                // 卸载页面显隐事件
                document.removeEventListener(controller.visibilityChange, controller.visibilityHandler);
                this.removeDom();
                return;
            }
            else if (this.isAndroid) {
                const jscallback = controller.operationjscallback;
                window[jscallback] = () => {};
                invokeP('v5/datachannel/unregister', {
                    action: 'com.baidu.videoplayer.operationresult',
                    jscallback
                });
            }
        }
        // 卸载video事件
        Object.keys(controller.videoEventHandler).forEach(evtname => (
            video.removeEventListener(evtname, controller.videoEventHandler[evtname])
        ));
        // 卸载全屏事件
        Object.keys(controller.docEventHandler).forEach(evtname => (
            document.removeEventListener(evtname, controller.docEventHandler[evtname])
        ));
        // android的NA播放器依赖此处销毁
        video.src = '';
        this.removeDom();
    }
    removeDom() {
        const dom = this.api.getVideoInstance();
        if (dom) {
            dom.parentNode && dom.parentNode.removeChild(dom);
        }
        this.api.setVideoInstance(null);
    }
    iosCreateVideo() {
        const root = this.api.getRoot();
        const rootPos = this.getContainerBox(root);
        const options = this.api.getPlayerOption();
        // 没有指定宽高则默认使用外层div的宽高
        this.width = options.width || rootPos.width;
        this.height = options.height || rootPos.height;
        const {wrap, inner} = genDomHeight(this.height);
        const video = document.createElement('div');
        video.className = this.cid;
        video.style = 'width:' + this.width + 'px;height:' + wrap + 'px;'
            + 'overflow: scroll; -webkit-overflow-scrolling: touch; background-color: transparent;';
        const videoInner = document.createElement('div');
        videoInner.style = 'width: 100%; height:' + inner + 'px';
        // 预创建
        options.precreate && video.setAttribute('data-precreatevideoinfo', JSON.stringify({
            videoUrl: options.src,
            vid: options.vid,
            playerControlType: options.playerControlType || 0
        }));
        // 预取推荐使用单独的prefetch方法
        // options.prefetchVideoInfo
        //     && video.setAttribute('data-prefetchvideoinfo', JSON.stringify(options.prefetchVideoInfo));
        video.appendChild(videoInner);
        root.appendChild(video);
        this.times = 0;
        this.isScrollViewFound = false;
        this.isRenderComplete = false;
        this.api.setVideoInstance(video);
        // 获取video的真实宽高开始查找
        const position = options.position || this.getContainerBox(video);
        this.api.setPlayerOption('', {
            width: this.width,
            height: this.height,
            position
        });
        this.perf.queryStart = +new Date;
        this.iosQuery(position);
    }
    getContainerBox(e) {
        const bcr = e.getBoundingClientRect();
        return {
            left: bcr.left + window.scrollX,
            top: bcr.top + window.scrollY,
            width: Math.round(bcr.width),
            height: Math.round(bcr.height)
        };
    }
    iosQuery(position) {
        const invokeP = this.api.getBoxTools().invokeP;
        // 超过iosMaxQueryCnt次数且同层渲染失败
        if (++this.times > this.iosMaxQueryCnt && !(this.isScrollViewFound && this.isRenderComplete)) {
            this.perflog.queryfail = +new Date - this.perf.queryStart;
            return this.h5Run();
        }
        const params = {
            containerId: this.cid,
            position: position,
            scrollHeight: genDomHeight(position.height).inner
        };
        // 能力超时和调用失败时，重试并且退化
        invokeP('video/slrIsFoundContainerView', {params})
            .then(data => {
                // ios ab实验开关，默认值为0关闭态，
                if (!data.isSupportSameLR) {
                    return this.h5Run();
                }
                this.perflog.model = data.detailMsg || null;
                if (data.isScrollViewFound) {
                    this.isScrollViewFound = true;
                    if (data.isRenderComplete) {
                        this.isRenderComplete = true;
                        this.perflog.count = this.times;
                        this.perflog.querysuc = +new Date - this.perf.queryStart;
                        this.times = 999;
                        return this.iosInvokePlayer();
                    }
                }
                this.iosQuery(position);
            }).catch(e => {
                this.perflog.queryfail = +new Date - this.perf.queryStart;
                this.h5Run();
            });
    }
    iosInvokePlayer(schema = 'video/slrInvokePlayer') {
        const cid = this.cid;
        const {invokeP, getGlobalFunc} = this.api.getBoxTools();
        // 设置事件回调
        const eventCallback = this.api.getPlayerController('eventCallback')
            || (getGlobalFunc((evtName, evtData) => this.iosPlayerEventDispatch(evtName, evtData)));
        this.api.setPlayerController('eventCallback', eventCallback);
        const options = this.api.getPlayerOption();
        const fullScreenType = options.fullScreenType || 'windowFullScreen';
        // jssdk使用true or false，端上使用1 or 0
        // 默认忽略转屏
        const isIgnoreDeviceOrientation = !options.hasOwnProperty('isIgnoreDeviceOrientation') || !!options.isIgnoreDeviceOrientation;
        const params = {
            containerId: cid,
            eventCallback,
            videoinfo: {
                ...options,
                vid: options.vid,
                videoUrl: options.src,
                posterImage: options.poster,
                // autoPlay: +options.autoplay,
                muted: +options.muted,
                loop: +options.loop,
                syncPlayerPosition: 1,
                fullScreenType,
                isIgnoreDeviceOrientation: +isIgnoreDeviceOrientation,
                // eslint-disable-next-line
                ext_log: {
                    prepareInvokePlayerTime: this.perf.clk,
                    ...(options.ext || {})
                }
            }
        };
        const player = this.api.getPlayerInstance();
        invokeP(schema, {params})
            .then(() => {
                this.api.setMode('na');
                this.perflog.create = +new Date - this.perf.createStart;
                this.api.emit('ready', {mode: 'na', isIOS: this.isIOS, isAndroid: this.isAndroid});
                const {fromCache, hidePlaying} = this.api.getPlayerController();
                if (fromCache && hidePlaying || !fromCache  && options.autoplay) {
                    this.isEmitPerf = true;
                    player.play();
                    this.api.setPlayerController('fromCache', false);
                    this.api.setPlayerController('hidePlaying', false);
                }
            }).catch(e => {
                this.h5Run();
            });
        this.iosUpdatePlayerStatus();
        if (options.hasOwnProperty('volume')) {
            player.volume = options.volume;
        }
        else {
            // 更新系统声音
            invokeP('video/slrGetSystemVolume', {params: {containerId: this.cid}})
                .then(res => this.api.setPlayerOption('volume', res.volume));
        }
        this.api.setPlayerOption('', {
            ended: false,
            paused: false,
            fullscreen: false,
            currentTime: 0,
            duration: 0,
            readyState: 0,
            networkState: 0,
            fullScreenType,
            isIgnoreDeviceOrientation,
            timeInterval: (options.timeInterval || 1), // ios设置播放器进度间隔
            accurate: options.accurate || false // ios跳转精确定位
        });
        // 初始化全屏函数
        const ev1 = this.api.getPlayerController('fullscreenEvt') || (e => {
            e.stopPropagation();
            e.preventDefault();
        });
        this.api.setPlayerController('fullscreenEvt', ev1);
        this.iosVideoVisible();
    }
    iosVideoVisible() {
        if (this.api.getPlayerController('visibilityHandler')) {
            // 避免重复增加
            return;
        }
        let state = '';
        let visibilityChange = '';
        if (typeof document.visibilityState !== 'undefined') {
            state = 'visibilityState';
            visibilityChange = 'visibilitychange';
        }
        else if (typeof document.webkitVisibilityState !== 'undefined') {
            state = 'webkitVisibilityState';
            visibilityChange = 'webkitvisibilitychange';
        }
        if (!visibilityChange) {
            /* eslint-disable no-console */
            console.log('browser donot supports the Page Visibility API.');
            /* eslint-enable no-console */
            return;
        }
        const handler = () => {
            const player = this.api.getPlayerInstance();
            if (!player) {
                return;
            }
            if (document[state] === 'visible') {
                if (this.api.getPlayerController('hideNeedResume')) {
                    player.reset({src: player.src}); // 重置不能同步进度，需要调用端能力同步具体见文档
                    player.play();
                    this.api.setPlayerController('hideNeedResume', false);
                }
            }
            else {
                // 起播成功，且视频不处于暂停态
                if (this.api.getPlayerController('playerKernelInit') && !player.ended && !player.paused) {
                    player.pause();
                    this.api.setPlayerController('hideNeedResume', true);
                }
            }
        };
        this.api.setPlayerController('visibilityChange', visibilityChange);
        this.api.setPlayerController('visibilityHandler', handler);
        // safari 7 和其他现代浏览器生效 android 4.4及以上生效
        document.addEventListener(visibilityChange, handler, false);
        this.naBackRecovery();
    }
    naBackRecovery() {
        if (this.api.getPlayerController('pagehideHandler')) {
            // 避免重复增加
            return;
        }
        const pageshowHandler = e => {
            if (!e.persisted) {
                return;
            }
            // 从缓存中读取
            const player = this.api.getPlayerInstance();
            if (this.isIOS) {
                setTimeout(() => {
                    this.api.setPlayerController('fromCache', true);
                    this.perf.clk = +new Date;
                    this.perf.createStart = this.perf.clk;
                    this.iosCreateVideo();
                }, 10);
            }
            else if (this.api.getPlayerController('hidePlaying')) { // 安卓
                player.play();
                this.api.getPlayerController('hidePlaying', false);
            }
        };
        window.addEventListener('pageshow', pageshowHandler);
        this.api.setPlayerController('pageshowHandler', pageshowHandler);
        const pagehideHandler = () => {
            if (this.isIOS) {
                // 卸载页面移除dom
                this.removeDom();
                this.perf = {};
            }
            const player = this.api.getPlayerInstance();
            // 判断正在播放：起播成功，且视频不处于暂停态
            const playing = this.api.getPlayerController('playerKernelInit') && !player.ended && !player.paused;
            // 正在播放的视频缓存恢复后仍然播放
            this.api.setPlayerController('hidePlaying', playing);
        };
        window.addEventListener('pagehide', pagehideHandler);
        this.api.setPlayerController('pagehideHandler', pagehideHandler);
    }
    iosUpdatePlayerStatus() {
        const invokeP = this.api.getBoxTools().invokeP;
        // 更新播放器状态初始值
        invokeP('video/slrGetPlayerStatus', {
                params: {
                    containerId: this.cid,
                    gather: ['muted', 'duration', 'rate', 'loop']
                }
            })
            .then(res => this.api.setPlayerOption('', {
                muted: !!res.muted,
                duration: res.duration || 0,
                playbackRate: res.rate,
                loop: !!res.loop
            }));
    }
    iosPlayerEventDispatch(evtName, evtData = {}) {
        if (!evtName || evtData.containerId !== this.cid) {
            return;
        }
        delete evtData.containerId;
        switch (evtName) {
            case 'slrPlayerStateChanged':
                this.iosPlayerStatusDispatch(evtData);
                break;
            case 'slrLoadingViewStatusChanged':
                this.api.setPlayerOption('networkState', 2); // loading中说明视频在加载中
                this.api.emit('loadingchange', evtData.loadingShow);
                break;
            case 'slrMuteChanged':
                this.api.setPlayerOption('', {
                    muted: !!evtData.muted,
                    volume: evtData.volume
                });
                this.api.emit('mutedchange', !!evtData.muted);
                break;
            case 'slrSystemVolumeChanged':
                this.api.setPlayerOption('volume', evtData.volume);
                this.api.emit('volumechange', evtData.volume);
                break;
            case 'slrPlayerProgressChanged':
                this.api.setPlayerOption('', {
                    currentTime: evtData.currentTime,
                    duration: evtData.duration
                });
                this.api.emit('timeupdate', evtData.currentTime);
                break;
            case 'slrRateChanged':
                this.api.setPlayerOption('playbackRate', evtData.newRate);
                this.api.emit('ratechange', evtData.newRate);
                break;
        }
    }
    iosPlayerStatusDispatch(evtData) {
        let evtname = '';
        switch (evtData.event) {
            case 'onStartPrepare': // 开始准备播放
                evtname = 'prepare';
                this.api.setPlayerOption('', {
                    ended: false,
                    readyState: 1
                });
                break;
            case 'onPrepared': // 准备播放缓冲成功
                evtname = 'canplay';
                this.api.setPlayerOption('readyState', 4);
                break;
            case 'onPlaySuccess': // 启播成功
                this.api.setPlayerController('playerKernelInit', true);
                this.perflog.clk2play = +new Date - this.perf.clk;
                this.iosUpdatePlayerStatus(); // 启播后更新播放器信息，尤其是duration在启播后才能得到
                this.isEmitPerf && this.emitPerfEvent();
            case 'onReplay': // 重新播放 12.13增加
                this.api.setPlayerOption('ended', false);
            case 'onResumePlay': // 继续播放 12.13增加
                this.api.emit('play');
                this.api.setPlayerOption('paused', false);
                evtname = 'playing';
                break;
            case 'onPaused': // 暂停
                evtname = 'pause';
                this.api.setPlayerOption('paused', true);
                break;
            case 'onFinished': // 播放完成
                evtname = 'ended';
                this.api.setPlayerOption('ended', true);
                break;
            case 'onClosed': // 播放器关闭
                evtname = 'closed';
                break;
            case 'onError': // 播放错误
                evtname = 'error';
                this.api.setPlayerOption('error', evtData);
                break;
        }
        evtname && this.api.emit(evtname);
    }
    androidCreateVideo(pageUrl = '') {
        this.api.setMode('na');
        this.androidNaEvent().then(() => {
            this.createVideoTag({
                't7-video-player-type': 'h5samelayer',
                't7-video-player-ext': pageUrl
            });
            this.androidInitPlayer();
        });
        this.naBackRecovery();
    }
    androidInitPlayer() {
        const video = this.api.getVideoInstance();
        const options = this.api.getPlayerOption();
        // 传递日志
        let log = {};
        ['from', 'page', 'value'].forEach(key => {
            if (options.hasOwnProperty(key)) {
                log[key] = options[key];
            }
        });
        // 12.23新增：passThrough 可配置的videoInfo透传参数key
        const passThrough = ['mpd', 'clarityUrl'].concat(options.passThrough || []);
        // 12.23新增videoInfo: 用于透传端上播放器扩展的能力字段
        // 协议确实是要求videoUrl或clairty必须有一个: http://wiki.baidu.com/pages/viewpage.action?pageId=1522277714
        // 优先级：mpd > clairty > videoUrl > src
        const videoInfo = {videoUrl: options.src};
        passThrough.forEach(key => {
            options[key] && (videoInfo[key] = options[key]);
        });
        // 指令长度有限制，因此mpd和clarityUrl做下互斥处理
        if (videoInfo.mpd && videoInfo.clarityUrl) {
            delete videoInfo.clarityUrl;
        }
        // 12.9新增: ignore4gToast needReadLocalProgress 获取系统音量
        video.zeusVideoExt = JSON.stringify({
            id: this.cid,
            name: 'h5samelayer',
            action: 'init',
            data: {
                vid: options.vid,
                ignore4gToast: +(!!options.ignore4gToast),
                syncProgress: +(!!options.needReadLocalProgress),
                getSysVolume: +(!options.hasOwnProperty('volume') || options.muted),
                videoInfo,
                samelrLog: {
                    ...log,
                    extLog: {
                        prepareInvokePlayerTime: this.perf.clk,
                        ...(options.ext || {})
                    }
                }
            }
        });
        const player = this.api.getPlayerInstance();
        const loadHandler = () => {
            // 播放器默认静音
            this.perflog.create = +new Date - this.perf.createStart;
            if (options.hasOwnProperty('volume')) {
                player.volume = options.volume;
            }
            // 13.2新增：搜索新增由端上控制音量，前端不再维护静音状态
            !options.useAutoVolume && (player.muted = !!options.muted);
            if (options.hasOwnProperty('seekSeconds')) {
                player.currentTime = options.seekSeconds;
            }
            video.removeEventListener('loadedmetadata', loadHandler);
        };
        // 在端上返回onPrepared播放器创建完成事件，内核会调用loadedmetadata事件，在此处理一些音量等事件
        video.addEventListener('loadedmetadata', loadHandler);
        this.api.emit('ready', {mode: 'na', isIOS: this.isIOS, isAndroid: this.isAndroid});
    }
    androidNaEvent() {
        const {invokeP, getGlobalFunc} = this.api.getBoxTools();
        const jscallback = getGlobalFunc((action, data) => {
            if (action !== 'com.baidu.videoplayer.operationresult'
                || !this.api.getVideoInstance()) {
                return;
            }
            try {
                data = JSON.parse(data);
            }
            catch (e) {}
            if (data.status === 0) {
                const id = this.api.getPlayerOption('containerId');
                const video = this.api.getVideoInstance();
                const player = this.api.getPlayerInstance();
                switch (data.action) {
                    case 'init':
                        break;
                    // 端上的操作只有在volume为0时才是静音操作，静音态关联由sdk维护
                    case 'volumeChanged':
                        // volumeChanged存在物理按键触发和video.volume赋值触发
                        if (player.volume === data.data.volume && !this.api.getPlayerOption('useAutoVolume')) {
                            return;
                        }
                        // 根据事件结果来控制option内的volume，video.volume只用来改变音量
                        this.api.setPlayerOption('volume', data.data.volume);
                        if (video.volume !== data.data.volume) {
                            player.volume = data.data.volume;
                        }
                        this.api.emit('volumechange', data.data.volume);
                        // 起播后才可控制静音状态
                        if (!this.api.getPlayerController('playerKernelInit')) {
                            return;
                        }
                        if (data.data.volume === 0 && !player.muted) {
                            // 音量为0 置为静音态
                            player.muted = true;
                        }
                        if (data.data.volume > 0 && player.muted) {
                            // 静音态音量变化 取消静音
                            player.muted = false;
                        }
                        break;
                    case 'setMute':
                        if (player.muted !== !!data.data.muted) { // 静音状态变化
                            this.api.setPlayerOption('muted', !!data.data.muted);
                            this.api.emit('mutedchange', !!data.data.muted);
                        }
                        break;
                    case 'getSysVolume':
                        const newVolume = +data.data.volume === 1 ? +data.data.volume : +data.data.volume.toFixed(3);
                        // 当option内没有配置volume值时，保存默认值，当loadedmetadata触发时统一设置volume
                        this.api.setPlayerOption('volume', newVolume);
                        break;
                }
            }
        });
        this.api.setPlayerController('operationjscallback', jscallback);
        return invokeP('v5/datachannel/register', {
            action: 'com.baidu.videoplayer.operationresult',
            jscallback
        });
    }
    videoEventDispatch() {
        const video = this.api.getVideoInstance();
        const isH5 = this.api.getMode() === 'h5';
        let evtArr = [
            'abort',
            'canplay',
            'canplaythrough',
            'durationchange',
            'emptied',
            'ended',
            'error',
            'loadeddata',
            'loadedmetadata',
            'loadstart',
            'pause',
            'play',
            'playing',
            'progress',
            'ratechange',
            'seeked',
            'seeking',
            'stalled',
            'suspend',
            'timeupdate',
            'waiting',
            'webkitendfullscreen' // iOS下退出全屏触发事件
        ];
        isH5 && evtArr.push('volumechange');
        const evtHandler = {};
        evtArr.forEach(evtname => {
            evtHandler[evtname] = e => {
                const playerKernelInit = this.api.getPlayerController('playerKernelInit');
                if (!isH5 && !playerKernelInit && evtname === 'canplay'
                    && this.api.getPlayerOption('autoplay')) {
                    this.isEmitPerf = true;
                    // na情况下自动播放
                    video.play();
                }
                if (!playerKernelInit && evtname === 'play') {
                    // 首次play触发打点
                    this.api.setPlayerController('playerKernelInit', true);
                    this.perflog.clk2play = +new Date - this.perf.clk;
                    this.isEmitPerf && this.emitPerfEvent();
                }
                this.api.emit(evtname, e);
            };
            video.addEventListener(evtname, evtHandler[evtname]);
        });
        this.api.setPlayerController('videoEventHandler', evtHandler);
        const docEvtHandler = {};
        ['fullscreenchange', 'webkitfullscreenchange', 'mozfullscreenchange', 'MSFullscreenChange'].forEach(item => {
            docEvtHandler[item] = () => {
                let fullscreenEl = document.fullscreenElement || document.webkitFullscreenElement
                    || document.mozFullScreenElement || document.msFullscreenElement;
                if (fullscreenEl && fullscreenEl === video) {
                    this.api.setPlayerOption('fullscreen', true);
                    this.api.emit('enterfullscreen');
                }
                else if (this.api.getPlayerOption('fullscreen')) {
                    this.api.setPlayerOption('fullscreen', false);
                    this.api.emit('exitfullscreen');
                }
            };
            document.addEventListener(item, docEvtHandler[item]);
        });
        this.api.setPlayerController('docEventHandler', docEvtHandler);
    }
    createVideoTag(attr = {}) {
        const root = this.api.getRoot();
        const options = this.api.getPlayerOption();
        const video = document.createElement('video');
        const width = options.width ? options.width + 'px' : '100%';
        const height = options.height ? options.height + 'px' : '100%';
        video.style = 'width:' + width + '; height: ' + height + ';'
            + (options.videoGravity === 2 ? 'object-fit: cover;' : '');
        Object.keys(attr).forEach(name => video.setAttribute(name, attr[name]));
        root.appendChild(video);
        // 修改播放信息
        let propArr = ['controls', 'loop', 'mediaGroup', 'playbackRate',
            'preload', 'src', 'poster', 'volume'];
        // h5video设置muted
        this.api.getMode() === 'h5' && (propArr = propArr.concat(['muted','autoplay']));
        Object.keys(options).filter(ele => propArr.indexOf(ele) > -1).forEach(key => {
            try {
                video[key] = options[key];
            }
            catch (e) {}
        });
        this.api.setPlayerOption('containerId', this.cid);
        this.api.setVideoInstance(video);
        this.videoEventDispatch();
        return video;
    }
    emitPerfEvent() {
        const {clk, queryStart, createStart} = this.perf;
        this.perflog.clk2create = createStart - clk;
        if (queryStart) {
            this.perflog.clk2query = queryStart - clk;
        }
        // 指标包括：
        // 点击到播放耗时clk2play
        // ios查询次数：count
        // ios查询成功耗时querysuc
        // ios查询失败耗时queryfail
        // 创建开始到结束耗时create
        // 点击到创建开始耗时：clk2create（参考指标）
        // 点击到开始查询耗时clk2query:（参考指标）
        this.api.emit('perf', this.perflog);
        this.perflog = {};
        this.isEmitPerf = false;
    }
    /**
    * 重置播放器宽高
    */
    resetRect(width, height) {
        const {isIOS, invokeP} = this.api.getBoxTools();
        const video = this.api.getVideoInstance();
        const {containerId, videoGravity} = this.api.getPlayerOption();
        const isnaIOS = this.api.getMode() === 'na' && isIOS();
        // 调整位置
        if (isnaIOS) {
            const {wrap, inner} = genDomHeight(height);
            const videoInner = video.firstChild;
            video.style.width = width + 'px';
            video.style.height = wrap + 'px';
            videoInner.style.height = inner + 'px';
            invokeP('video/slrUpdatePlayerInfo', {
                params: {
                    containerId,
                    position: {
                        left: 0,
                        top: 0,
                        width,
                        height
                    }
                }
            });
        }
        else {
            const w = width ? width + 'px' : '100%';
            const h = height ? height + 'px' : '100%';
            video.style = 'width:' + w + '; height: ' + h + ';'
                + (videoGravity === 2 ? 'object-fit: cover;' : '');
        }
    }
    /**
    * 重置播放器参数
    */
    reset(config) {
        const video = this.api.getVideoInstance();
        if (!video) {
            return;
        }
        const options = this.api.getPlayerOption();
        const mode = this.api.getMode();
        // 更改宽高
        if (config.width || config.height) {
            // 调整位置
            this.resetRect(options.width, options.height);
            config.width && delete config.width;
            config.height && delete config.height;
        }
        // 只调整大小就结束或当前设置h5由用户自行处理降级方案
        if (Object.keys(config).length === 0
            || mode === 'h5' && this.api.getPlayerController('slrOnly')) {
            return;
        }
        this.perf.createStart = +new Date;
        this.perf.clk = config.prepareInvokePlayerTime || this.perf.createStart;
        // 内核重新初始化
        this.api.setPlayerController('playerKernelInit', false);
        // 更改属性
        if (mode === 'na' && this.isIOS) {
            this.perf.queryStart = this.perf.createStart;
            this.iosInvokePlayer('video/slrSetPlayerInfo');
            return;
        }
        // 修改播放地址
        let propArr = ['controls', 'loop', 'mediaGroup',
            'playbackRate', 'preload', 'src', 'poster', 'volume'];
        // h5video设置muted
        mode === 'h5' && (propArr = propArr.concat(['muted','autoplay']));
        Object.keys(options).filter(ele => propArr.indexOf(ele) > -1).forEach(key => {
            try {
                video[key] = options[key];
            }
            catch (e) {}
        });
        if (mode === 'h5') {
            this.api.emit('ready', {mode: 'h5', isIOS: this.isIOS, isAndroid: this.isAndroid});
            return;
        }
        if (this.isAndroid) {
            video.setAttribute('t7-video-player-ext', options.pageUrl || '')
            this.androidInitPlayer();
        }
    }
    /**
    * 创建h5播放器
    */
    h5Run() {
        this.api.setMode('h5');
        // 清除ios残留dom
        this.removeDom();
        if (this.api.getPlayerController('slrOnly')) { // h5退化方案由业务方处理
            this.api.emit('ready', {mode: 'h5', isIOS: this.isIOS, isAndroid: this.isAndroid});
            this.emitPerfEvent();
            return;
        }
        this.isEmitPerf = !!this.api.getPlayerOption('autoplay');
        this.createVideoTag({
            playsinline: true,
            'webkit-playsinline': true
        });
        this.api.emit('ready', {mode: 'h5', isIOS: this.isIOS, isAndroid: this.isAndroid});
    }
}
