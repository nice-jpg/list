/**
 * @file thunder hn fetch
 * @author okaychen<chenglong13@baidu.com>
 */

import merge from 'lodash.merge';
import {isString, isPlainObject} from './utils'

export default class ThunderHN<T> {
    private HOME = 'https://hpd.baidu.com/v.gif';
    private query: {};
    constructor(props: T, options = { home:'' }) {
        this._validateProps(props);
        this.query = {};
        this.setQueries(props);
        this.HOME = (options.home && isString(options.home)) ? options.home : this.HOME;

        if (this.HOME.charAt(this.HOME.length - 1) !== '?') {
            this.HOME = this.HOME + '?';
        }
    }

    setQueries<U>(props: U): void {
        merge(this.query, props || {});
    }
    
    _validateProps<U>(props: U): void {
        if (null != props && !isPlainObject(props)) {
            throw new Error('Thunder takes a plain object');
        }
    }

    async _fetch<U>(URL: string): Promise<any> {
        let res = await fetch(URL, {
            credentials: 'include',
            mode: 'no-cors'
        });
        const specialLogInfo = {
            ct: 3,
            cst: 9,
            logFrom: 'feed_tab',
            logInfo: 'log_req_fail',
            ssid: 0,
            logExtra: {
                type: res.status
            }
        };
        if (res.status !== 200 && Math.floor(Math.random() * 100) === 50) {
            // 414：日志请求被拦截，随机监控打点
            /* istanbul ignore next */
            await fetch(this.getFetchUrl(specialLogInfo), {
                credentials: 'include',
                mode: 'no-cors'
            });
        }
        return res;
    }

    getFetchUrl = (props: any): string => {
        this._validateProps(props);
        let query = merge({}, this.query, props);
        if (query && query.logExtra) {
            if (isPlainObject(query.logExtra)) {
                query.logExtra.page = 'undefined' === typeof query.logExtra.page
                ? query.tabId : query.logExtra.page;
                query.logExtra.value = 'undefined' === typeof query.logExtra.value
                ? query.tabId : query.logExtra.value;
            } else if (Array.isArray(query.logExtra)) {
                query.logExtra.map((item: any) => {
                    if (!item) {
                        return {
                            page: query.tabId
                        };
                    }
                    item.page = 'undefined' === typeof item.page ? query.tabId : item.page;
                    item.value = 'undefined' === typeof item.value ? query.tabId : item.value;
                    return item;
                });
            }
        }

        const searches = [];

        for (let key in query) {
            let val = query[key];
            let stringified;

            switch (true) {
                case ('number' === typeof val && !isNaN(val)):
                case ('boolean' === typeof val):
                    searches.push(`${key}=${val}`);
                    break;
                case ('' === val || (val && (val.constructor === String))):
                    searches.push(`${key}=${encodeURIComponent(val)}`);
                    break;
                case isPlainObject(val) || Array.isArray(val):
                    stringified = JSON.stringify(val);
                    searches.push(`${key}=${encodeURIComponent(stringified)}`);
                    break;
            }
        }
        return this.HOME + searches.join('&');
    }

    send = async <U>(props: U): Promise<string> => {
        const response = await this._fetch(this.getFetchUrl(props));
        return await response.text();
    }
};