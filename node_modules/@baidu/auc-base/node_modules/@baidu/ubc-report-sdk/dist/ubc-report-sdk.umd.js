(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
  typeof define === 'function' && define.amd ? define(['exports'], factory) :
  (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global["ubc-web-sdk"] = {}));
})(this, (function (exports) { 'use strict';

  function ownKeys(object, enumerableOnly) {
    var keys = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      enumerableOnly && (symbols = symbols.filter(function (sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      })), keys.push.apply(keys, symbols);
    }
    return keys;
  }
  function _objectSpread2(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = null != arguments[i] ? arguments[i] : {};
      i % 2 ? ownKeys(Object(source), !0).forEach(function (key) {
        _defineProperty(target, key, source[key]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
    return target;
  }
  function _typeof(obj) {
    "@babel/helpers - typeof";

    return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) {
      return typeof obj;
    } : function (obj) {
      return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    }, _typeof(obj);
  }
  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }
  function _defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);
    }
  }
  function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    Object.defineProperty(Constructor, "prototype", {
      writable: false
    });
    return Constructor;
  }
  function _defineProperty(obj, key, value) {
    key = _toPropertyKey(key);
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }
    return obj;
  }
  function _toPrimitive(input, hint) {
    if (typeof input !== "object" || input === null) return input;
    var prim = input[Symbol.toPrimitive];
    if (prim !== undefined) {
      var res = prim.call(input, hint || "default");
      if (typeof res !== "object") return res;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (hint === "string" ? String : Number)(input);
  }
  function _toPropertyKey(arg) {
    var key = _toPrimitive(arg, "string");
    return typeof key === "symbol" ? key : String(key);
  }

  /**
   * @file 工具方法
   * @author wangbing11(wangbing11@baidu.com)
   */

  var getUa = function getUa() {
    try {
      return window.navigator.userAgent;
    } catch (e) {
      return '';
    }
  };
  var isBox = function isBox() {
    var ua = getUa();
    var IS_LITE_BOX = / (lite|info) baiduboxapp\//i.test(ua);
    var IS_KANDUODUO_BOX = / mission baiduboxapp\//i.test(ua);
    // IS_BOX 标识是否手百基础版内，不能是Lite、不是看多多
    return / baiduboxapp\//i.test(ua) && !IS_LITE_BOX && !IS_KANDUODUO_BOX;
  };
  var isSwan = function isSwan() {
    var ua = getUa();
    return /swan/i.test(ua);
  };
  var getLocation = function getLocation() {
    try {
      return document.location;
    } catch (e) {
      return {
        href: '',
        protocol: 'https:',
        origin: '',
        pathname: ''
      };
    }
  };

  /**
   * 字符串化query
   *
   * [注]：
   * 默认：如果`value`是数组，其`toString`会自动转为逗号分隔的字符串
   * 这里：如果 是 Array 和 Object 参数 都进行 JSON.stringify + encodeURIComponent 了
   *
   * @param {Object} query 查询条件
   * @return {string}
   */
  function stringify() {
    var query = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    if (!query) {
      return '';
    }
    var search = '';
    for (var key in query) {
      if (query.hasOwnProperty(key)) {
        var value = query[key];
        if (value == null) {
          value = '';
        } else if (_typeof(value) === 'object') {
          value = JSON.stringify(value);
        }
        search += '&' + encodeURIComponent(key) + '=' + encodeURIComponent(value);
      }
    }
    return search.slice(1);
  }

  /**
   * 在url上加指定参数
   *
   * @param  {string} url  url
   * @param {Object} query 参数对象
   * @example
   * {
   *    a: 1
   * }
   * @return {string}    添加参数后的url
   */
  function renderUrl() {
    var url = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
    var query = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    return url + (~url.indexOf('?') ? '&' : '?') + stringify(query);
  }

  /**
   * isObject
   *
   * @param {*} value value
   * @return {boolean} 如果是对象则返回 true, 否则 false
   */
  function isObject(value) {
    // Avoid a V8 JIT bug in Chrome 19-20.
    // See https://code.google.com/p/v8/issues/detail?id=2291 for more details.
    var type = _typeof(value);
    return type === 'function' || !!value && type === 'object';
  }

  /**
   * getUrlQuery  从url中获取query对象
   *
   * @param   {Object} key urlQuery中获得key对应的参数，如果不传则返回整个query对象
   * @return  {string | Object} queryStr 或 整个query对象
   */
  var getUrlQuery = function getUrlQuery(key) {
    var url = getLocation().href;
    var reg = new RegExp('[\\?&]([^\\?&\\=\\/]+)=([^\\?\\&\\=\\/]*)', 'g');
    var query = {};
    var regResult;
    while ((regResult = reg.exec(url)) !== null) {
      query[regResult[1]] = regResult[2];
    }
    if (key) {
      return query[key];
    } else {
      return query;
    }
  };

  /**
   * getUrl
   *
   * @param   {string}  url       请求url
   * @param   {Object}  params    参数
   * @return  {string}  更新url(过滤为空的参数)
   */
  var getUrl = function getUrl(url, params) {
    var realParams = {};
    Object.keys(params).forEach(function (item) {
      // TODO params[item]是不是有可能为0
      params[item] && (realParams[item] = params[item]);
    });
    if (Object.keys(realParams).length === 0) {
      return url;
    }
    return renderUrl(url, realParams);
  };

  /**
   * 获得key对应的cookie值
   * @param {string} sKey cookie的key
   * @return {string} cookie的value
   */
  var getCookieByName = function getCookieByName(sKey) {
    var cookie = document.cookie || '';
    return decodeURIComponent(cookie.replace(new RegExp('(?:(?:^|.*;)\\s*' + encodeURIComponent(sKey).replace(/[-.+*]/g, '\\$&') + '\\s*\\=\\s*([^;]*).*$)|^.*$'), '$1')) || '';
  };

  /**
   * 获得key对应的cookie值
   * @param {any} source merge的第一个对象
   * @param {any} other merge的第二个对象
   * @return {any} merge后的对象
   */
  var merge = function merge(source, other) {
    if (!isObject(source) || !isObject(other)) {
      return other === undefined ? source : other;
    }
    // 合并两个对象的 key，另外要区分数组的初始值为 []
    return Object.keys(_objectSpread2(_objectSpread2({}, source), other)).reduce(function (acc, key) {
      // 递归合并 value
      acc[key] = merge(source[key], other[key]);
      return acc;
    }, Array.isArray(source) ? [] : {});
  };

  /**
   * @file ubcLog的conf配置
   * @author songzimei<songzimei@baidu.com>
   */

  var getProtocol = function getProtocol() {
    if (['http:', 'https:'].includes(getLocation().protocol)) {
      return getLocation().protocol;
    }
    return 'https:';
  };
  var CONFIG = {
    UBC_URL: getProtocol() + '//h2tcbox.baidu.com/ztbox',
    TEST_UBC_URL: 'http://bjyz-mco-searchbox201609-m12xi3-044.bjyz.baidu.com:8080/ztbox',
    DEFAULT_LOG_DATA: {
      cateid: '99',
      actiondata: {
        // 外部填写（ubcID）
        id: '0',
        // 日志类型：0—事件类（web类）1—流类型（客户端)
        type: '0',
        timestamp: 0,
        content: {
          // 页面名称
          page: '-',
          // 区块位置
          type: '-',
          // 页面来源
          value: '-',
          // 资源来源
          source: 'default',
          // 日志类型
          from: 'act',
          // 扩展字段
          ext: {
            apptype: '-'
          }
        }
      }
    },
    DEFAULT_QUERY: {
      action: 'zpblog',
      v: '2.0',
      appname: 'baiduboxapp',
      from: '',
      cfrom: '',
      smfw: ''
    }
  };
  var CONFIG_MERGE = {
    UBC_URL: getLocation().protocol + '//h2tcbox.baidu.com/ztbox',
    TEST_UBC_URL: 'http://bjyz-mco-searchbox201609-m12xi3-044.bjyz.baidu.com:8080/ztbox',
    DEFAULT_LOG_DATA: {
      cateid: '101',
      data: []
    },
    DEFAULT_QUERY: {
      action: 'mpblog',
      v: '2.0',
      appname: 'baiduboxapp',
      from: '',
      cfrom: '',
      smfw: '',
      sid: '',
      sn: ''
    }
  };

  /**
   * @file send 方法
   * @author wangbing11(wangbing11@baidu.com)
   */
  var createImg = function createImg(src) {
    var img = document.createElement('img');
    img.width = 1;
    img.height = 1;
    img.src = src;
    return img;
  };

  // 回调函数等待时间
  var callbackWaitingTime = 100;

  /**
   * 使用图片来发请求
   *
   * @param {string} url 上报服务地址
   * @param {Object} param 上报的数据
   * @return {Promise} 结束回调
   */
  function imgPing(url, param) {
    return new Promise(function (resolve, reject) {
      // 生成URL
      url = renderUrl(url, {
        data: param
      });
      var img = createImg(url);
      var isCallbacked = false;

      // 等待 100 ms， 100ms后如果回调函数还没有执行，就立即执行回调
      setTimeout(function () {
        if (!isCallbacked) {
          resolve();
          isCallbacked = true;
        }
      }, callbackWaitingTime);
      img.onload = img.onerror = function () {
        img = null;
        // 上报成功后，如果回调函数还没有执行，就执行回调函数
        if (!isCallbacked) {
          resolve();
          isCallbacked = true;
        }
      };
    });
  }

  /**
   * 使用Navigator.sendBeacon来发请求
   *
   * @param {string} url 上报服务地址
   * @param {Object} param 上报的数据
   * @param {Object} options 上报格式
   * @return {Promise} 结束回调
   */
  function beaconSend(url, param, options) {
    return new Promise(function (resolve, reject) {
      var isDataInBody = options.sendMethod === 'post';
      var isSendSuccess;
      if (isDataInBody) {
        isSendSuccess = window.navigator.sendBeacon(renderUrl(url, {
          data: param
        }));
      } else {
        isSendSuccess = window.navigator.sendBeacon(url, 'data=' + encodeURIComponent(JSON.stringify(param)));
      }

      // 生成URL
      if (isSendSuccess) {
        resolve();
      } else {
        reject();
      }
    });
  }
  function xhrSend(url, param) {
    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    var method = options.sendMethod === 'post' ? 'POST' : 'GET';
    url = method === 'POST' ? url : renderUrl(url, {
      data: param
    });
    return new Promise(function (resolve, reject) {
      var oReq = new XMLHttpRequest();
      oReq.addEventListener('loadend', function () {
        if (oReq.status === 200) {
          resolve();
        } else {
          reject();
        }
      });
      oReq.open(method, url);
      oReq.withCredentials = true;
      if (method === 'POST') {
        oReq.setRequestHeader("Content-type", "application/x-www-form-urlencoded");
        oReq.send('data=' + encodeURIComponent(JSON.stringify(param)));
      } else {
        oReq.send();
      }
    });
  }

  /**
   * 使用图片来发请求
   *
   * @param {string} url 上报服务地址
   * @param {Object} param 上报的数据
   * @param {Object} [options] 额外参数
   * @param {Object} [options.useSendBeacon] 是否使用sendBeancon
   * @param {boolean} [options.useXhr] 是否使用useXhr
   * @param {string} [options.sendMethod] post/get
   * @return {Promise} 结束回调
   */
  function smartSend(url, param) {
    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    if (options.useXhr) {
      return xhrSend(url, param, options);
    }
    // 与数据RD沟通，待数据组升级后可启用-在好看和全民端sendBeacon无效
    if (typeof window.navigator.sendBeacon === 'function' && options.useSendBeacon) {
      return beaconSend(url, param, options);
    }
    return imgPing(url, param);
  }

  /**
   * @file send 方法
   * @author wangbing11(wangbing11@baidu.com)
   */

  // Set the name of the hidden property and the change event for visibility

  function regestPageVisibilityEvent(handler) {
    try {
      var hidden;
      var visibilityChange;
      if (typeof document.hidden !== 'undefined') {
        // Opera 12.10 and Firefox 18 and later support
        hidden = 'hidden';
        visibilityChange = 'visibilitychange';
      } else if (typeof document.msHidden !== 'undefined') {
        hidden = 'msHidden';
        visibilityChange = 'msvisibilitychange';
      } else if (typeof document.webkitHidden !== 'undefined') {
        hidden = 'webkitHidden';
        visibilityChange = 'webkitvisibilitychange';
      } else if (typeof document.baiduboxappvisibilitychange !== 'undefined') {
        hidden = 'webkitHidden';
        visibilityChange = 'webkitvisibilitychange';
      }
      var handleVisibilityChange = function handleVisibilityChange() {
        handler(!!document[hidden]);
      };
      if (typeof document.addEventListener === 'undefined' || hidden === undefined) {
        return;
      }
      // Handle page visibility change
      document.addEventListener(visibilityChange, handleVisibilityChange, false);
    } catch (e) {}
  }

  var version = "3.3.3";

  /**
   * @file 通过UA获得当前宿主信息
   * @author changyuqing
   */
  var uaRegMap = [{
    // name: '看多多',
    appname: 'baiduboxmission',
    reg: /\bmission\sbaiduboxapp\b/i,
    appid: "10006"
  }, {
    // name: '百度APP极速版',
    appname: 'baiduboxlite',
    reg: /\b(?:lite|info) baiduboxapp\b/i,
    appid: "10001"
  }, {
    // name: '百度APP',
    appname: 'baiduboxapp',
    reg: /\bbaiduboxapp\b/i,
    appid: "1"
  }, {
    // name: '百度贴吧',
    appname: 'tieba',
    reg: /\btieba\b/i,
    appid: "11001"
  }, {
    // name: '好看视频',
    appname: 'haokan',
    reg: /\bhaokan\b/i,
    appid: "11000"
  }, {
    // name: '全民小视频',
    appname: 'quanmin',
    reg: /\bbdminivideo\b/i,
    appid: "12022"
  }, {
    // name: '百度地图',
    appname: 'bdmap',
    reg: /\bbaidumap_/i,
    appid: "11006"
  }, {
    // name: '百度网盘',
    appname: 'wangpan',
    reg: /\bnetdisk;/i,
    appid: "12018"
  }, {
    // name: '宝宝知道',
    appname: 'askmybaby',
    reg: /\bmybaby\//i,
    appid: "12019"
  }, {
    // name: '西番',
    appname: 'xifan',
    reg: /\bbdxifan\//i,
    appid: "12006"
  }, {
    appid: "12031",
    // name: '百度手机助手',
    appname: 'sowhat'
  }, {
    appid: "12010",
    // name: '柠檬爱美',
    appname: 'lemon',
    reg: /lemonapp/i
  }, {
    appid: "12015",
    // name: '百家号APP',
    appname: 'baijiahao'
  }, {
    appid: "12012",
    // name: '番乐',
    appname: 'fanle'
  }, {
    appid: "12013",
    // name: '古物潮玩',
    appname: 'zhaocaimao'
  }, {
    appid: "12014",
    // name: '分玩',
    appname: 'gamenow'
  }, {
    appid: "12016",
    // name: '爱奇艺',
    appname: 'iqiyi'
  }, {
    appid: "12017",
    // name: '百度百科',
    appname: 'baike'
  }, {
    appid: "12023",
    // name: '新流',
    appname: 'flow'
  }, {
    appid: "12026",
    // name: 'Robotaxi约车',
    appname: 'dutaxi'
  }, {
    appid: "12011",
    // name: '有驾APP',
    appname: 'youjia'
  }, {
    appid: "12020",
    // name: '内容联盟',
    appname: 'feedsunion'
  }, {
    appid: "12021",
    // name: '一刻相册',
    appname: 'album'
  }, {
    appid: "12024",
    // name: '页游平台',
    appname: 'webgame'
  }, {
    appid: "12027",
    // name: 'HMI乘客端',
    appname: 'hmi_passenger'
  }, {
    appid: "12028",
    // name: '百度文库',
    appname: 'bdwenku'
  }, {
    appid: "12029",
    // name: '百度翻译',
    appname: 'fanyi'
  }, {
    appid: "12030",
    // name: '百度知道',
    appname: 'iknow'
  }, {
    appid: "12025",
    // name: '度晓晓',
    appname: 'duxiaoxiao'
  }, {
    appid: "12032",
    // name: '百度汉语',
    appname: 'baiduhanyu'
  }, {
    appid: "12034",
    // name: '百度经验',
    appname: 'exp'
  }, {
    appid: "12036",
    // name: 'APP DEMO',
    appname: 'demo'
  }, {
    appid: "12037",
    // name: '百度阅读',
    appname: 'baiduyuedu'
  }, {
    appid: "12038",
    // name: '健康管理',
    appname: 'cdm'
  }, {
    appid: "12040",
    // name: '微叭伴聊',
    appname: 'weiba'
  }, {
    appid: "12041",
    // name: '百度视频版',
    appname: 'baiduboxvision'
  }, {
    appid: "12042",
    // name: '嘻哈',
    appname: 'hiphop'
  }, {
    appid: "12043",
    // name: 'robobus控制终端',
    appname: 'robobus-panel'
  }, {
    appid: "12044",
    // name: '文库大学生版',
    appname: 'wenkustudent'
  }, {
    appid: "12045",
    // name: '百度PC直播',
    appname: 'pc_live'
  }, {
    appid: "12049",
    // name: '云上百度',
    appname: 'yunshangbaidu'
  }, {
    appid: "12050",
    // name: '百度文库PC客户端',
    appname: 'baiduwenku_pc'
  }, {
    appid: "12051",
    // name: '音磁',
    appname: 'yinci'
  }, {
    appid: "12052",
    // name: '小说书城',
    appname: 'novel'
  }, {
    appid: "12054",
    // name: '有噗',
    appname: 'yoopu'
  }, {
    appid: "12057",
    // name: '音啵',
    appname: 'yinbo'
  }, {
    appid: "12062",
    // name: '爱企查',
    appname: 'aiqicha'
  }, {
    appid: "12066",
    // name: '轻竹健康',
    appname: 'Bamboo_Health'
  }, {
    appid: "12067",
    // name: '轻竹健康医生版',
    appname: 'Bamboo_Health_Dr'
  }, {
    appid: "12073",
    // name: '小度',
    appname: 'superduer'
  }, {
    appid: "12074",
    // name: '百度健康',
    appname: 'baidujiankangapp'
  }, {
    appid: "12075",
    // name: '百度爱番番',
    appname: 'bdcrm_aifanfan'
  }, {
    appid: "12077",
    // name: '拇指医生(医生版)',
    appname: 'muzhidoctor'
  }, {
    appid: "12079",
    // name: 'Apollo GO',
    appname: 'apollogo'
  }, {
    appid: "12080",
    // name: '律临',
    appname: 'lvlin'
  }, {
    appid: "12083",
    // name: '爱采购卖家版',
    appname: 'aipurchase'
  }, {
    appid: "12088",
    // name: '百度CarLife',
    appname: 'BaiDuCarLife'
  }, {
    appid: "12090",
    // name: '百度健康tt',
    appname: 'baidujiankangtt'
  }, {
    appid: "12092",
    // name: '如流',
    appname: 'infoflow',
    reg: /\bbaiduhi/i
  }, {
    appid: "12094",
    // name: 'hmi driver',
    appname: 'hmi_driver'
  }, {
    appid: "12095",
    // name: '百度VR智慧云展',
    appname: 'vr_expo'
  }, {
    appid: "12096",
    // name: '内容电商小程序',
    appname: 'content_ecommerce'
  }, {
    appid: "12097",
    // name: '百度VR播控服务',
    appname: 'play_control'
  }, {
    appid: "12098",
    // name: '爱采购买家版',
    appname: 'aipurchaser'
  }, {
    appid: "12101",
    // name: '地图淘金',
    appname: 'ditutaojin'
  }, {
    appid: "12102",
    // name: '高精定位SDK',
    appname: 'hp_location'
  }, {
    appid: "12106",
    // name: '一起吧',
    appname: 'chatroom'
  }, {
    appid: "12107",
    // name: 'Gaia数据App',
    appname: 'gaia'
  }, {
    appid: "12108",
    // name: 'UBI商业数据App',
    appname: 'ubi'
  }, {
    appid: "12109",
    // name: '一局',
    appname: 'yiju'
  }, {
    appid: "12111",
    // name: '全功能AI开发平台',
    appname: 'bml'
  }, {
    appid: "12112",
    // name: '智慧家庭助手',
    appname: 'aihome'
  }, {
    appid: "12113",
    // name: '智慧家庭助手-孩子端',
    appname: 'aihome_children'
  }, {
    appid: "12114",
    // name: '百度手机卫士',
    appname: 'mobsecurity'
  }, {
    appid: "12117",
    // name: '百度APP大字版',
    appname: 'tomas'
  }, {
    appid: "12118",
    // name: 'flutter中台',
    appname: 'baidu_flutter'
  }, {
    appid: "12120",
    // name: '播客',
    appname: 'wepod'
  }, {
    appid: "12121",
    // name: 'YY直播_非百度',
    appname: 'yy'
  }, {
    appid: "12122",
    // name: '萌懂教育',
    appname: 'kidedu'
  }, {
    appid: "12123",
    // name: '网盘极速版',
    appname: 'wangpan_faster'
  }, {
    appid: "12124",
    // name: '随声',
    appname: 'wepod_mobile'
  }, {
    appid: "12125",
    // name: '百度VR教育桌面应用',
    appname: 'baidu_vr_classroom_launcher'
  }, {
    appid: '12407',
    // 好看急速版
    appname: 'bdhkvideo'
  }];
  /**
   * 通过appname或者ua获得对应的appid
   * @param {string} [appname] 传入的appname
   * @link http://app.baidu-int.com/console/application/clientlist
   */
  var getAppByName = function getAppByName() {
    var appname = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
    var defaultApp = {
      appname: 'other',
      appid: "12133"
    };
    if (appname) {
      var item = uaRegMap.find(function (item) {
        return appname === item.appname;
      });
      return item ? item : defaultApp;
    } else {
      var ua = getUa();
      var _item = uaRegMap.find(function (item) {
        if (item.reg) {
          return item.reg.test(ua);
        } else {
          return ua.search(item.appname) !== -1;
        }
      });
      return _item ? _item : defaultApp;
    }
  };

  /**
   * @file MergeLogger
   *
   * @author changyuqing@baidu.com
   */

  var MergeLogger = /*#__PURE__*/function () {
    function MergeLogger(_ref) {
      var _ref$logFn = _ref.logFn,
        logFn = _ref$logFn === void 0 ? function () {} : _ref$logFn;
      _classCallCheck(this, MergeLogger);
      this.logFn = logFn;
      this.logArray = [];
      this.mergeNumMax = 5;
      this.mergeInterval = 5;
      this.timeId = null;
    }
    _createClass(MergeLogger, [{
      key: "set",
      value: function set(_ref2) {
        var mergeNumMax = _ref2.mergeNumMax,
          mergeInterval = _ref2.mergeInterval;
        if (mergeNumMax) {
          this.mergeNumMax = mergeNumMax;
        }
        if (mergeInterval) {
          this.mergeInterval = mergeInterval;
        }
      }
    }, {
      key: "add",
      value: function add(logData) {
        var _this = this;
        this.logArray.push(logData);
        if (this.logArray.length === 1) {
          // 如果是进入队列的第一个日志，此时开启一个定时器
          this.timeId = setTimeout(function () {
            _this.clearAll();
          }, this.mergeInterval * 1000);
        } else if (this.logArray.length >= this.mergeNumMax) {
          // 如果进入队列的日志个数达到上限，就直接发送
          this.clearAll();
        }
      }
    }, {
      key: "clearAll",
      value: function clearAll() {
        if (this.logArray.length > 0) {
          // 如果队列里面存在待发送的日志，调用发送函数进行发送
          this.logFn(this.logArray);
          // 清空日志队列
          this.logArray = [];
        }
        if (this.timeId) {
          clearTimeout(this.timeId);
          this.timeId = null;
        }
      }
    }]);
    return MergeLogger;
  }();

  /**
   * @file TimeLogger
   *
   * @author changyuqing@baidu.com
   */

  var TimeLogger = /*#__PURE__*/function () {
    /**
     * @constructor TimeLogger
     * @param  {Object} [options]  打点设置，覆盖全局设置
     * @param  {boolean} [options.ifHeartbeatTime]  是否通过心跳打点
     * @param  {number} [options.duration]  心跳打点的间隔，单位s
     * @param  {Function} [options.logFn]  向外抛事件的函数
     */
    function TimeLogger(_ref) {
      var _ref$ifHeartbeatTime = _ref.ifHeartbeatTime,
        ifHeartbeatTime = _ref$ifHeartbeatTime === void 0 ? true : _ref$ifHeartbeatTime,
        _ref$duration = _ref.duration,
        duration = _ref$duration === void 0 ? 3 : _ref$duration,
        _ref$logFn = _ref.logFn,
        logFn = _ref$logFn === void 0 ? function () {} : _ref$logFn;
      _classCallCheck(this, TimeLogger);
      this.starttime = Date.now(); // 开始时间
      this.ifHeartbeatTime = ifHeartbeatTime; // 是否心跳打点
      this.logFn = logFn; // 打点方法
      this.intervalId = null;
      this.duration = duration;
      this.flag = 'STOP'; // 状态有 RUNNING STOP AUTO_STOP
    }
    _createClass(TimeLogger, [{
      key: "sendLog",
      value: function sendLog() {
        if (this.ifHeartbeatTime) {
          this.logFn({
            starttime: this.starttime,
            duration: this.duration
          });
        } else {
          var endtime = Date.now();
          this.logFn({
            starttime: this.starttime,
            duration: (endtime - this.starttime) / 1000,
            endtime: endtime
          });
        }
      }
    }, {
      key: "start",
      value: function start() {
        var _this = this;
        if (this.flag !== 'RUNNING') {
          this.flag = 'RUNNING';
          this.starttime = Date.now();
          if (this.ifHeartbeatTime) {
            this.sendLog();
            this.intervalId = setInterval(function () {
              _this.sendLog();
            }, this.duration * 1000);
          }
        }
      }
    }, {
      key: "stop",
      value: function stop() {
        if (this.flag === 'RUNNING') {
          if (this.ifHeartbeatTime) {
            this.sendLog();
            clearInterval(this.intervalId);
            this.intervalId = null;
          } else {
            this.sendLog();
          }
          this.flag = 'STOP';
        }
      }
    }, {
      key: "autoStop",
      value: function autoStop() {
        if (this.flag === 'RUNNING') {
          this.stop();
          this.flag = 'AUTO_STOP';
        }
      }
    }]);
    return TimeLogger;
  }();

  /**
   * @file 打点重试机制
   * @author changyuqing@baidu.com
   *
   */
  var maxStorageLength = 5;
  var isStorageInit = false;
  var origin = '';
  var retryLogLists = null;
  function setStorage(value) {
    if (!isStorageInit) {
      getStorage();
    }
    var now = Date.now();
    if (!retryLogLists[origin]) {
      // retryLogLists 中不存在当前页面对应的列表
      // 如果retryLogLists里面存放过多，则删除最旧的记录
      if (retryLogLists.length >= maxStorageLength) {
        var path = Object.keys(retryLogLists).reduce(function (pre, cur) {
          if (retryLogLists[cur] !== 'length' && retryLogLists[cur].time <= pre.time) {
            return {
              time: retryLogLists[cur].time,
              path: cur
            };
          }
          return pre;
        }, {
          time: now,
          path: ''
        }).path;
        delete retryLogLists[path];
      } else {
        retryLogLists.length++;
      }
    }
    retryLogLists[origin] = {
      list: value,
      time: now
    };
    localStorage.setItem('RETRY_LOG_LIST', JSON.stringify(retryLogLists));
  }
  function clearStorage() {
    if (!isStorageInit) {
      getStorage();
    }
    if (retryLogLists[origin]) {
      delete retryLogLists[origin];
      retryLogLists.length--;
    }
    localStorage.setItem('RETRY_LOG_LIST', JSON.stringify(retryLogLists));
  }
  function getStorage() {
    var _retryLogLists$origin;
    if (!isStorageInit) {
      isStorageInit = true;
      origin = getLocation().origin + getLocation().pathname;
    }
    try {
      retryLogLists = JSON.parse(localStorage.getItem('RETRY_LOG_LIST')) || {
        length: 0
      };
    } catch (e) {
      retryLogLists = {
        length: 0
      };
    }
    return ((_retryLogLists$origin = retryLogLists[origin]) === null || _retryLogLists$origin === void 0 ? void 0 : _retryLogLists$origin.list) || [];
  }
  var RetryLogger = /*#__PURE__*/function () {
    function RetryLogger(_ref) {
      var _ref$logFn = _ref.logFn,
        logFn = _ref$logFn === void 0 ? function () {} : _ref$logFn;
      _classCallCheck(this, RetryLogger);
      this.logFn = logFn;
      this.retryLogList = this._getInitErrLogs();
      this.retryTimesMax = 3; // 最大重发次数
      this.retryLogListMax = 5; // 重试队列最大长度
      this._retryIntervalTimer = null;
    }

    // 从storage中读取遗留的日志
    _createClass(RetryLogger, [{
      key: "_getInitErrLogs",
      value: function _getInitErrLogs() {
        var _this = this;
        var logs = getStorage();
        return new Map(logs.map(function (item) {
          return [item[0], _objectSpread2(_objectSpread2({}, item[1]), {}, {
            failTimes: 1,
            sendCountDown: _this._getDelayTime(item.failTimes)
          })];
        }));
      }
    }, {
      key: "_getDelayTime",
      value: function _getDelayTime(failTimes) {
        // 延迟重发时间的配置。连续失败次数越多，发送延迟越久
        var timeMap = {
          0: 1,
          // s
          1: 1,
          2: 5
        };
        return timeMap[failTimes] || 10 + Math.floor(Math.random() * 5 + 1);
      }
    }, {
      key: "active",
      value: function active() {
        var _this2 = this;
        if (!this._retryIntervalTimer && this.retryLogList.size > 0) {
          this._retryIntervalTimer = setInterval(function () {
            _this2._retryIntervalTimerHandler();
          }, 1000);
        }
      }
    }, {
      key: "addLog",
      value: function addLog(_ref2) {
        var url = _ref2.url,
          loggerData = _ref2.loggerData,
          loggerId = _ref2.loggerId;
        this.retryLogList.set(loggerId, {
          url: url,
          loggerData: loggerData,
          loggerId: loggerId,
          failTimes: 1,
          sendCountDown: this._getDelayTime(1)
        });
        // 超出最大长度时 取出队列中最久的一条
        if (this.retryLogList.size > this.retryLogListMax) {
          var key = this.retryLogList.keys().next().value;
          this.retryLogList["delete"](key);
        }
        this.active();
        // 把更新的数据更新到本地存储
        setStorage(Array.from(this.retryLogList));
      }
    }, {
      key: "removeLog",
      value: function removeLog(loggerId) {
        if (!loggerId) {
          return;
        }
        if (this.retryLogList["delete"](loggerId)) {
          if (this.retryLogList.size === 0) {
            clearStorage();
          } else {
            // 更新本地缓存
            setStorage(this.retryLogList);
          }
        }
      }
    }, {
      key: "updateLog",
      value: function updateLog(loggerId) {
        if (!loggerId) {
          return;
        }
        var item = this.retryLogList.get(loggerId);
        if (item) {
          var curFailTimes = item.failTimes;
          // 如果超过最大重试次数 则不再重发 从队列中删除
          if (curFailTimes + 1 > this.retryTimesMax) {
            this.removeLog(loggerId);
          } else {
            item.failTimes = curFailTimes + 1;
            item.sendCountDown = this._getDelayTime(item.failTimes);
          }
        }
      }
    }, {
      key: "_retryIntervalTimerHandler",
      value: function _retryIntervalTimerHandler() {
        var _this3 = this;
        this.retryLogList.forEach(function (logItem) {
          // 倒计时为-1时 表示该条日志正在被重新发送
          if (logItem.sendCountDown < 0) {
            return;
          } else if (+logItem.sendCountDown === 0) {
            // 倒计时已到 执行再次发送
            logItem.sendCountDown = -1; // 设置其正在方法
            _this3._sendLog(logItem);
          } else {
            // 倒计时计时 -1
            logItem.sendCountDown = logItem.sendCountDown - 1;
          }
        });
        if (this.retryLogList.size === 0) {
          clearInterval(this._retryIntervalTimer);
          this._retryIntervalTimer = null;
        }
      }
    }, {
      key: "_sendLog",
      value: function _sendLog(logItem) {
        var _this4 = this;
        this.logFn(logItem.url, logItem.loggerData).then(function () {
          _this4.removeLog(logItem.loggerId);
        })["catch"](function () {
          _this4.updateLog(logItem.loggerId);
        });
      }
    }]);
    return RetryLogger;
  }();

  /**
   * @file sha256 简化的sha256算法
   * @author geraintluff
   * @link https://github.com/geraintluff/sha256
   */

  var sha256 = function sha256(ascii) {
    function rightRotate(value, amount) {
      return value >>> amount | value << 32 - amount;
    }
    var maxWord = Math.pow(2, 32);
    var lengthProperty = 'length';
    var i, j; // Used as a counter across the whole file
    var result = '';
    var words = [];
    var asciiBitLength = ascii[lengthProperty] * 8;

    //* caching results is optional - remove/add slash from front of this line to toggle
    // Initial hash value: first 32 bits of the fractional parts of the square roots of the first 8 primes
    // (we actually calculate the first 64, but extra values are just ignored)
    var hash = sha256.h = sha256.h || [];
    // Round constants: first 32 bits of the fractional parts of the cube roots of the first 64 primes
    var k = sha256.k = sha256.k || [];
    var primeCounter = k[lengthProperty];
    /*/
     var hash = [], k = [];
     var primeCounter = 0;
     //*/

    var isComposite = {};
    for (var candidate = 2; primeCounter < 64; candidate++) {
      if (!isComposite[candidate]) {
        for (i = 0; i < 313; i += candidate) {
          isComposite[i] = candidate;
        }
        hash[primeCounter] = Math.pow(candidate, .5) * maxWord | 0;
        k[primeCounter++] = Math.pow(candidate, 1 / 3) * maxWord | 0;
      }
    }
    ascii += '\x80'; // Append Ƈ' bit (plus zero padding)
    while (ascii[lengthProperty] % 64 - 56) ascii += '\x00'; // More zero padding
    for (i = 0; i < ascii[lengthProperty]; i++) {
      j = ascii.charCodeAt(i);
      if (j >> 8) return; // ASCII check: only accept characters in range 0-255
      words[i >> 2] |= j << (3 - i) % 4 * 8;
    }
    words[words[lengthProperty]] = asciiBitLength / maxWord | 0;
    words[words[lengthProperty]] = asciiBitLength;

    // process each chunk
    for (j = 0; j < words[lengthProperty];) {
      var w = words.slice(j, j += 16); // The message is expanded into 64 words as part of the iteration
      var oldHash = hash;
      // This is now the undefined working hash", often labelled as variables a...g
      // (we have to truncate as well, otherwise extra entries at the end accumulate
      hash = hash.slice(0, 8);
      for (i = 0; i < 64; i++) {
        // let i2 = i + j;
        // Expand the message into 64 words
        // Used below if
        var w15 = w[i - 15],
          w2 = w[i - 2];

        // Iterate
        var a = hash[0],
          e = hash[4];
        var temp1 = hash[7] + (rightRotate(e, 6) ^ rightRotate(e, 11) ^ rightRotate(e, 25)) // S1
        + (e & hash[5] ^ ~e & hash[6]) // ch
        + k[i]
        // Expand the message schedule if needed
        + (w[i] = i < 16 ? w[i] : w[i - 16] + (rightRotate(w15, 7) ^ rightRotate(w15, 18) ^ w15 >>> 3) // s0
        + w[i - 7] + (rightRotate(w2, 17) ^ rightRotate(w2, 19) ^ w2 >>> 10) // s1
        | 0);
        // This is only used once, so *could* be moved below, but it only saves 4 bytes and makes things unreadble
        var temp2 = (rightRotate(a, 2) ^ rightRotate(a, 13) ^ rightRotate(a, 22) // S0
        ) + (a & hash[1] ^ a & hash[2] ^ hash[1] & hash[2]); // maj

        hash = [temp1 + temp2 | 0].concat(hash); // We don't bother trimming off the extra ones, they're harmless as long as we're truncating when we do the slice()
        hash[4] = hash[4] + temp1 | 0;
      }
      for (i = 0; i < 8; i++) {
        hash[i] = hash[i] + oldHash[i] | 0;
      }
    }
    for (i = 0; i < 8; i++) {
      for (j = 3; j + 1; j--) {
        var b = hash[i] >> j * 8 & 255;
        result += (b < 16 ? 0 : '') + b.toString(16);
      }
    }
    return result;
  };

  function invokeByIframe(schema) {
    var node = document.createElement('iframe'); // tslint:disable-line
    node.style.display = 'none';
    node.src = schema;
    var body = document.body;
    body.appendChild(node);
    // 销毁 iframe
    setTimeout(function () {
      body.removeChild(node);
      node = null;
    }, 0);
  }

  /**
   * @file 生成唯一id
   * @see https://github.com/baidu/san/blob/master/src/util/guid.js
   * @author weijiaxun <weijiaxun@baidu.com>
   */
  /**
   * 唯一id的起始值
   *
   * @inner
   * @type {number}
   */
  var guidIndex = 1;
  /**
   * 唯一id的前缀
   *
   * @inner
   * @type {string}
   */
  var guidPrefix = (new Date().getTime() + Math.floor(Math.random() * 100000000 + 1)).toString(16).slice(8);
  /**
   * 获取唯一id
   *
   * @inner
   * @return {string} 唯一id
   */
  function getId() {
    return '_' + guidPrefix + guidIndex++;
  }

  /**
   * @file 创建全局函数
   * @author weijiaxun <weijiaxun@baidu.com>
   */
  /**
   * 将传入函数转换成全局函数，返回其全局名称字符串
   *
   * @param {Function} func query 对象
   * @return {string} 将 function 字符串化后的 query 对象
   */
  function toGlobalFunc(func) {
    var funcName = getId();
    window[funcName] = function () {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      return func.apply(window, [].slice.call(args, 0));
    };
    return funcName;
  }

  /**
   * @file 版本比较
   * @author weijiaxun <weijiaxun@baidu.com>
   */
  /**
   * 版本比较；
   * @memberOf Bdbox.utils
   * @name version_compare
   * @param  {string} version1 第一个版本号
   * @param  {string} version2 第二个版本号
   * @return {nubmer} num version1 == version2返回0；version1 > version2返回1；小于返回-1
   */
  function versionCompare(version1, version2) {
    var a = version1.toString().split('.');
    var b = version2.toString().split('.');
    var len = Math.max(a.length, b.length);
    for (var i = 0; i < len; i++) {
      if (a[i] && !b[i] && parseInt(a[i], 10) > 0 || parseInt(a[i], 10) > parseInt(b[i], 10)) {
        return 1 /* bigger */;
      } else if (b[i] && !a[i] && parseInt(b[i], 10) > 0 || parseInt(a[i], 10) < parseInt(b[i], 10)) {
        return -1 /* smaller */;
      }
    }

    return 0 /* equl */;
  }

  /**
   * @file App灰度包判断 （限手百）
   * @author liuyaqian02 <liuyaqian02@baidu.com>
   */
  var LOW_EXIST = {
    status: 101,
    message: '该版本不支持此端能力'
  };
  /**
   * @see http://es.baidu-int.com/#/apidetail/1809
   * @resolve {Object} data 端返回的data参数
   * @resolve {String} data.isBata 是否为灰度包 true|false
   *
   * @reject {Object} rejectData 端返回的失败回调信息
   * @reject {String} rejectData.status 失败状态码
   * @reject {String} rejectData.message 失败说明
   */
  function isBeta() {
    return new Promise(function (resolve, reject) {
      var ua = getUa();
      var match = /baiduboxapp\/([\d+.]+)/.exec(ua);
      var BOX_VERSION = match && match[1] || '0';
      // 版本小于12.20.0.0，提示101 该版本不支持此端能力
      if (versionCompare(BOX_VERSION, '12.20.0.0') < 0) {
        reject(LOW_EXIST);
        return;
      }
      var scheme = "baiduboxapp://app/isBeta?callback=".concat(toGlobalFunc(callback));
      invokeByIframe(scheme);
      function callback(res) {
        res = JSON.parse(res);
        // 请求成功回调值
        if (+res.status === 0) {
          resolve(res.data);
        }
        // 请求失败
        else {
          var rejectData = {
            status: res.status,
            message: res.message
          };
          reject(rejectData);
        }
      }
    });
  }

  /**
   *
   * @constructor ubc业务日志类
   * @description ubc业务日志类
   *
   * @example
   * new Ubclogger({
   *     serverId:123,
   *     idfrom:'res_fuli',
   *     page:'index'
   * })
   */
  var UbcLogger$1 = /*#__PURE__*/function () {
    /**
     * Create a UbcLogger
     *
     * @class UbcLogger
     * @param {Object} [options]                        初始化入参
     * @param {number} [options.serverId]               活动serverId
     * @param {string} [options.page]                   页面page名称
     * @param {string} [options.type]                   打点type
     * @param {string} [options.from]                   日志类型
     * @param {Object} [options.queryParams]            ubcUrl上的query(appname,from,cfrom,smfw)
     * @param {boolean} [options.testMode=false]        true走线下地址; false或者为空走线上ubc地址，目前日志平台采用新校验方式，不需要走线下地址
     * @param {string} [options.testUrl]                打点数据上传地址;传入后，打点数据将发送至该地址
     * @param {string} [options.source]                 资源位source
     * @param {string} [options.idfrom]                 资源位idfrom(等价于资源位source，优先级更高)
     * @param {boolean} [options.ifHeartbeatTime=true]  时长打点是否为心跳点，默认为true
     * @param {boolean} [options.useSendBeacon=false]   使用SendBeacon API进行打点
     * @param {Object} [options.logMergeOpt]            日志合并参数配置
     * @param {Object} [options.logMergeOpt.ifAutoMerge] 是否开启自动合并，默认不开启
     * @param {Object} [options.logMergeOpt.mergeNumMax] 最大日志合并数量
     * @param {Object} [options.logMergeOpt.mergeInterval] 合并时间间隔
     * @param {boolean} [options.logErrRetry]            是否开启日志重试
     * @param {Object} [options.ext]               公共的ext参数，会被send的传参覆盖
     *
     *
     */
    function UbcLogger() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      _classCallCheck(this, UbcLogger);
      // ubcLog
      this.ubcParams = {};
      // 是否初始化
      this.logInited = false;
      // set后的options
      this.options = {};

      // 时长打点
      this.timerMap = new Map();
      // 合并打点
      this.mergeLogger = null;
      // 打点重试机制
      this.retryLogger = null;

      // 当前宿主端是否是beta包
      this.isBeta = false;
      this._initUbcParams();
      // 初始化设置参数
      this.set(Object.assign({
        duration: 3,
        ifHeartbeatTime: true,
        testMode: false,
        useSendBeacon: false,
        useXhr: false,
        sendMethod: 'get',
        apptype: getAppByName().appid
      }, options));

      // 注册页面可见性
      this._registerPageVisibility();
      this._registerBeta();
    }

    /**
     * _initUbcParams
     *
     * @private
     */
    _createClass(UbcLogger, [{
      key: "_initUbcParams",
      value: function _initUbcParams() {
        this.ubcParams = {};
        this.ubcDefaultLogData = CONFIG.DEFAULT_LOG_DATA;
        // merge默认数据
        this.ubcParams = merge(this.ubcParams, this.ubcDefaultLogData);
      }
    }, {
      key: "_initCookie",
      value: function _initCookie() {
        var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        // 设置cookie
        if (options.testMode) {
          document.cookie = 'bd_logap_verify=1;domain=.baidu.com;path=/';
        }
      }

      /**
       * _initUbcUrl
       *
       * @private
       * @param {Object} options  options入参
       */
    }, {
      key: "_initUbcUrl",
      value: function _initUbcUrl() {
        var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        // 获取ubcUrl
        var query = options.queryParams || {};
        if (this.isBeta) {
          query = _objectSpread2({
            beta: 1
          }, query);
        }

        // 线下环境带上debug标示
        if (options.testMode) {
          query = _objectSpread2({
            debug: 1
          }, query);
        }

        // beta=1
        this.ubcUrl = getUrl(options.testMode ? options.testUrl ? options.testUrl : CONFIG.UBC_URL : CONFIG.UBC_URL, merge(CONFIG.DEFAULT_QUERY, query));
        this.ubcMergeUrl = getUrl(options.testMode ? options.testUrl ? options.testUrl : CONFIG_MERGE.UBC_URL : CONFIG_MERGE.UBC_URL, merge(CONFIG_MERGE.DEFAULT_QUERY, query));
      }

      /**
       * set
       * options可不填，缺省字段会以上次设置的为准
       * @example
       * ubclogger.set({
       *     serverId:123,
       *     idfrom:'res_fuli',
       *     page:'index'
       * })
       * @param {Object} [options]                  初始化入参
       * @param {number} [options.serverId]               活动serverId
       * @param {string} [options.page]                   页面page名称
       * @param {string} [options.from]                   日志类型
       * @param {Object} [options.queryParams]            ubcUrl上的query(appname,from,cfrom,smfw)
       * @param {string} [options.testMode]         true走校验模式; false或者为空走线上ubc地址
       * @param {string} [options.testUrl]                打点数据上传地址;传入后，打点数据将发送至该地址（需要testMode=true）
       * @param {string} [options.source]                 资源位source
       * @param {string} [options.idfrom]                 资源位idfrom(等价于资源位source，优先级更高)
       * @param {boolean} [options.ifHeartbeatTime]  时长打点是否为心跳点
       * @param {boolean} [options.useSendBeacon]   使用SendBeacon API进行打点，默认false
       * @param {boolean} [options.useXhr]   使用xhr进行打点,默认false
       * @param {string} [options.sendMethod]   单条请求发送方式 get/post，默认get，配合useXhr使用
       * @param {Object} [options.logMergeOpt]            日志合并参数配置
       * @param {boolean} [options.logMergeOpt.ifAutoMerge] 是否开启自动合并，默认不开启
       * @param {number} [options.logMergeOpt.mergeNumMax] 最大日志合并数量。默认5条
       * @param {number} [options.logMergeOpt.mergeInterval] 合并时间间隔，默认5s,单位s
       * @param {boolean} [options.logErrRetry]            是否开启日志重试
       * @param {Object} [options.ext]               公共的ext参数，会被send的传参覆盖
       *
       */
    }, {
      key: "set",
      value: function set() {
        var _this = this;
        var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        this.options = _objectSpread2(_objectSpread2({}, this.options), options);
        this._initCookie(this.options);
        this._initUbcUrl(this.options);

        // 配置serverId,source(idfrom),page
        this.ubcParams = merge(this.ubcParams, {
          actiondata: {
            id: this.options.serverId,
            content: {
              source: this.options.source || this.options.idfrom || getUrlQuery('source') || getUrlQuery('idfrom'),
              page: this.options.page,
              from: this.options.from,
              type: this.options.type,
              ext: _objectSpread2({
                apptype: this.options.apptype
              }, this.options.ext)
            }
          }
        });
        if (+this.options.serverId) {
          this.logInited = true;
        }
        // 初始化mergeLogger
        if (!this.mergeLogger) {
          this.mergeLogger = new MergeLogger({
            logFn: function logFn(paramsList) {
              return _this._sendMerge(paramsList, {
                useXhr: true,
                sendMethod: 'post'
              });
            }
          });
        }
        if (this.options.logMergeOpt) {
          // 修改mergeLogger选项
          this.mergeLogger.set(this.options.logMergeOpt);
        }

        // 初始化retryLogger
        if (this.options.logErrRetry && !this.retryLogger) {
          this.retryLogger = new RetryLogger({
            logFn: function logFn(url, logData) {
              logData.actiondata.metadata.uploadTimeStamp = Date.now();
              return smartSend(url, logData, {
                useXhr: true
              });
            }
          });
        }
      }

      /**
       * 发送普通点
       * @private
       * @param  {Object} params  打点自定义参数
       * @param  {Object} options 额外参数
       * @param  {boolean} options.useSendBeacon 是否使用SendBeacon API发送请求
       * @param  {boolean} [options.useXhr] 是否使用Xhr发送请求
       * @param  {string} [options.sendMethod] 单条请求发送方式 get/post，默认get，配合useXhr使用
       * @return {Promise} promise 打点成功发送返回then
       */
    }, {
      key: "_send",
      value: function _send() {
        var _this2 = this;
        var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
        var logData = {};
        var now = Date.now();
        // 事件打点正常处理
        var baiduId = getCookieByName('BAIDUID');
        if (baiduId && this.options.logErrRetry) {
          // 获得没有加metadata的logData
          logData = merge(this.ubcParams, {
            actiondata: {
              timestamp: now,
              content: params
            }
          });
          // 通过baiduId和logData计算摘要值（logData里面已经包含了当前时间戳）
          var loggerId = sha256(baiduId + JSON.stringify(logData));
          logData.actiondata.metadata = {
            md5: loggerId,
            uploadTimeStamp: now
          };
          return smartSend(this.ubcUrl, logData, _objectSpread2(_objectSpread2({}, options), {}, {
            useXhr: true
          })).then(function (data) {
            // 打点成功后通知retryLogger
            _this2.retryLogger.active();
            return data;
          })["catch"](function (err) {
            //向队列中加一条日志
            _this2.retryLogger.addLog({
              url: _this2.ubcUrl,
              loggerData: logData,
              loggerId: loggerId
            });
            return Promise.reject(err);
          });
        } else {
          logData = merge(this.ubcParams, {
            actiondata: {
              timestamp: now,
              content: params
            }
          });
          return smartSend(this.ubcUrl, logData, options);
        }
      }

      /**
       * 发送合并点
       * @private
       * @param  {Array} paramsList  打点自定义参数
       * @param  {Object} options 额外参数
       * @param  {boolean} [options.useSendBeacon] 是否使用SendBeacon API发送请求
       * @param  {boolean} [options.useXhr] 是否使用Xhr发送请求
       * @param  {string} [options.sendMethod] 单条请求发送方式 get/post，默认get，配合useXhr使用
       * @return {Promise} promise 打点成功发送返回then
       */
    }, {
      key: "_sendMerge",
      value: function _sendMerge() {
        var paramsList = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
        var logData = {};
        var now = Date.now();
        // 事件打点正常处理
        var actiondata = this.ubcParams.actiondata;
        var data = paramsList.map(function (params) {
          var tempLogData = merge(actiondata, {
            timestamp: now,
            content: params
          });
          return tempLogData;
        });
        logData = _objectSpread2(_objectSpread2({}, CONFIG_MERGE.DEFAULT_LOG_DATA), {}, {
          data: data
        });
        return smartSend(this.ubcMergeUrl, logData, options);
      }

      /**
       * 发送流式点
       * @private
       * @param  {Object} params  打点自定义参数
       * @param  {Object} timing  时长相关参数
       * @param  {Object} options 额外参数
       * @param  {boolean} options.useSendBeacon 是否使用SendBeacon API发送请求
       * @return {Promise} promise 打点成功发送返回then
       */
    }, {
      key: "_sendFlow",
      value: function _sendFlow() {
        var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        var timing = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
        var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
        // 流式打点参数处理
        var logData = this._getFlowData(params, timing);
        return smartSend(this.ubcUrl, logData, options);
      }

      /**
       * send
       * @example
       * ubclogger.send({
       *     page: 'y_ent_login',
       *     type: 'login_clk',
       *     value: 'login',
       *     ext: {
       *         p1: 'login'
       *     }
       * })
       * @param  {Object} params  打点自定义参数
       * @param  {Object} [options] 额外选项
       * @param  {boolean} [options.useSendBeacon] 是否使用SendBeacon API发送请求
       * @param  {boolean} [options.useXhr] 是否使用Xhr发送请求
       * @param  {string} [options.sendMethod] 单条请求发送方式 get/post，默认get，配合useXhr使用
       * @return {Promise} promise 打点成功发送返回then
       */
    }, {
      key: "send",
      value: function send() {
        var _this$options, _this$options$logMerg;
        var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        var options = arguments.length > 1 ? arguments[1] : undefined;
        if (!this.logInited) {
          throw 'UBC SDK serverId can not be empty!';
        }
        options = _objectSpread2({
          useSendBeacon: this.options.useSendBeacon,
          useXhr: this.options.useXhr,
          options: this.options.sendMethod
        }, options);
        if ((_this$options = this.options) !== null && _this$options !== void 0 && (_this$options$logMerg = _this$options.logMergeOpt) !== null && _this$options$logMerg !== void 0 && _this$options$logMerg.ifAutoMerge) {
          this.mergeLogger.add(params);
          return Promise.resolve();
        } else {
          return this._send(params, options);
        }
      }

      /**
       * sendMergeLog
       * @example
       * ubclogger.sendMergeLog({
       *     page: 'y_ent_login',
       *     type: 'login_clk',
       *     value: 'login',
       *     ext: {
       *         p1: 'login'
       *     }
       * })
       * @param  {Object} params  打点自定义参数
       * @return {Promise} promise 打点成功发送返回then
       */
    }, {
      key: "sendMergeLog",
      value: function sendMergeLog() {
        var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        if (!this.logInited) {
          throw 'UBC SDK serverId can not be empty!';
        }
        this.mergeLogger.add(params);
        return Promise.resolve();
      }

      /**
       * _getFlowData
       *
       * @private
       * @see 流式打点字段格式：http://wiki.baidu.com/pages/viewpage.action?pageId=337347739#id-%E6%97%A5%E5%BF%97%E8%A7%84%E8%8C%83-2.3.3%E6%B5%81%E7%B1%BB%E5%9E%8B%E6%97%A5%E5%BF%97%E5%AD%97%E6%AE%B5%E8%A7%84%E8%8C%83%E2%80%94%E6%97%B6%E9%95%BF
       * @param {Object} content 打点自定义参数
       * @param {Object} timing 时长相关参数
       * @return {Object} logData 打点数据
       */
    }, {
      key: "_getFlowData",
      value: function _getFlowData(content, timing) {
        var _this$ubcParams, _this$ubcParams$actio;
        var resultLogData = {};
        var starttime = timing.starttime,
          duration = timing.duration,
          endtime = timing.endtime;
        var now = Date.now();

        // 将this.ubcParams?.actiondata?.content 里面 向下移动到 resultLogData.actiondata?.content.option
        resultLogData = merge(this.ubcParams, {
          actiondata: {
            content: '-'
          }
        });
        resultLogData = merge(resultLogData, {
          actiondata: {
            timestamp: now,
            starttime: starttime,
            endtime: endtime,
            type: 1,
            content: {
              duration: duration,
              option: merge((_this$ubcParams = this.ubcParams) === null || _this$ubcParams === void 0 ? void 0 : (_this$ubcParams$actio = _this$ubcParams.actiondata) === null || _this$ubcParams$actio === void 0 ? void 0 : _this$ubcParams$actio.content, content)
            }
          }
        });
        return resultLogData;
      }

      /**
       * startTimingLog 开始
       * @example
       * ubclogger.startTimingLog('timing1',{
       *     page: 'y_ent_login',
       *     type: 'login_clk',
       *     value: 'login',
       *     ext: {
       *         p1: 'login'
       *     }
       * })
       * @example
       * ubclogger.startTimingLog('timing1',{
       *     page: 'y_ent_login',
       * },{
       *     useSendBeacon: true
       * }
       * @param  {*} [label=default]  时长打点必须拥有唯一的名字，默认default
       * @param  {Object} [params]  打点自定义参数
       * @param  {Object} [options]  打点设置，覆盖全局设置
       * @param  {boolean} [options.ifHeartbeatTime]  是否通过心跳打点
       * @param  {boolean} [options.useSendBeacon]  是否使用 SendBeacon API
       * @param  {number} [options.duration]  心跳打点的间隔，单位s
       */
    }, {
      key: "startTimingLog",
      value: function startTimingLog() {
        var _this3 = this;
        var label = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'default';
        var params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
        var options = arguments.length > 2 ? arguments[2] : undefined;
        var timer = this.timerMap.get(label);
        // 如果不存在时长打点，则创建一个打点
        if (!timer) {
          timer = new TimeLogger(_objectSpread2(_objectSpread2({
            ifHeartbeatTime: this.options.ifHeartbeatTime,
            duration: this.options.duration
          }, options), {}, {
            // 根据时长相关参数，发送打点
            logFn: function logFn(timing) {
              _this3._sendFlow(params, timing, _objectSpread2({
                useSendBeacon: _this3.options.useSendBeacon
              }, options));
            }
          }));
          this.timerMap.set(label, timer);
        }
        if (timer.flag === 'RUNNING') {
          console.warn("timeLogger[".concat(label, "] is running"));
          return;
        }
        timer.start();
      }

      /**
       * pauseTimingLog 停止打点,保留该时长点的参数,可被重新启动
       * @example
       * ubclogger.pauseTimingLog('timing1');
       * @param {*} [label=default]  时长打点必须拥有唯一的名字，默认default
       */
    }, {
      key: "pauseTimingLog",
      value: function pauseTimingLog() {
        var label = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'default';
        var timer = this.timerMap.get(label);
        if (timer) {
          timer.stop();
        }
      }

      /**
       * stopTimingLog 停止时长计算
       * @example
       * ubclogger.stopTimingLog('timing1');
       * @param {*} [label=default]  时长打点必须拥有唯一的名字，默认default
       */
    }, {
      key: "stopTimingLog",
      value: function stopTimingLog() {
        var label = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'default';
        var timer = this.timerMap.get(label);
        if (timer) {
          timer.stop();
          this.timerMap["delete"](label);
        }
      }

      /**
       * _registerPageVisibility 在页面切换时暂停时长计算
       * @private
       * @desc 页面展现begin
       * @desc 页面离开/切后台end
       */
    }, {
      key: "_registerPageVisibility",
      value: function _registerPageVisibility() {
        var _this4 = this;
        regestPageVisibilityEvent(function (isHidden) {
          if (isHidden) {
            _this4.timerMap.forEach(function (timer) {
              if (timer && timer.flag === 'RUNNING') {
                timer.autoStop();
              }
            });
            _this4.mergeLogger && _this4.mergeLogger.clearAll();
          } else {
            _this4.timerMap.forEach(function (timer) {
              if (timer && timer.flag === 'AUTO_STOP') {
                timer.start();
              }
            });
          }
        });
      }

      /**
       * getVersion 获得当前sdk版本
       * @return {string} 当前sdk版本
       */
    }, {
      key: "getVersion",
      value: function getVersion() {
        return version;
      }
    }, {
      key: "_registerBeta",
      value: function _registerBeta() {
        var _this5 = this;
        // 只在手百中加入判断灰度包的逻辑
        if (isBox() && !isSwan()) {
          isBeta().then(function (res) {
            if (res !== null && res !== void 0 && res.isBeta) {
              _this5.isBeta = true;
              // 修改ubc url
              _this5.set();
            }
          })["catch"](function () {
            // safe
            // 不支持这个schema，或者非手百，不做任何操作
          });
        }
      }
    }]);
    return UbcLogger;
  }();

  /**
   * @file es 文件入口
   * @author changyuqing@baidu.com
   */
  var UbcLogger = UbcLogger$1;
  var ubcLogger = new UbcLogger$1();

  exports.UbcLogger = UbcLogger;
  exports.ubcLogger = ubcLogger;

  Object.defineProperty(exports, '__esModule', { value: true });

}));
