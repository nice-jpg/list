/**
 * @file 返回拦截
 * @module view
 * @author zhangtingting12 <zhangtingting12@baidu.com>
 *
 * 端能力地址：http://ft.baidu.com/?ticket=ST-383602-2FZmLPASnvzFgPTOdlCt-uuap#/scheme/immersebrowser_backhandler
 * @example
 * ```js
 * // 引用
 * import backHandler, {multipleBackHandler} from '@baidu/xbox-native/view/backHandler';
 *
 * // 定义点击框架返回按钮需要执行的回调函数
 * window.handlerCallBack = () => {
 *     console.log('回调函数体');
 * };
 *
 * // backHandler(此方式指定唯一一个回调函数)
 * backHandler('handlerCallBack');
 * // multipleBackHandler指定多个回调函数，回调函数按调用multipleBackHandler顺序执行，同名函数仅执行一次，且在最后一次调用位置执行
 * multipleBackHandler('handlerCallBack');
 * ```
 */
import {xRegister} from '../invoke';
/**
 * @function backHandler
 * @param {string} backHandlerFuc - 拦截返回时指定的执行js函数名，必须在window下
 */
const backHandler = backHandlerFuc => (
    xRegister(
        {
            lite: {
                v: 23,
                versionRange: '3.9'
            },
            info: {
                v: 23,
                versionRange: '3.9'
            },
            main: {
                v: 23,
                versionRange: '10.5.5'
            }
        },
        'immerseBrowser/backHandler',
        {backHandler: backHandlerFuc}
    )
);

export default cb => backHandler(cb);

const backHandlerQueue = [];
const BACKCB = 'MUL_BACKHANDLER_CALLBACK';

export const multipleBackHandler = backHandlerCb => {
    if (!backHandlerCb) {
        return;
    }

    const i = backHandlerQueue.indexOf(backHandlerCb);
    // 仅执行最后一次调用的相同名称函数
    if (i !== -1) {
        backHandlerQueue.splice(i, 1);
    }
    backHandlerQueue.push(backHandlerCb);

    // 注册backHandler回调函数
    if (!(window[BACKCB] && window[BACKCB] instanceof Function)) {
        window[BACKCB] = () => (
            backHandlerQueue.forEach(fucName => window[fucName] && window[fucName]())
        );
        return backHandler(BACKCB);
    }
};
