/**
 * Copyright (C) 2021 ~ present baidu.com
 */
import { isFunction, isNumber, } from '@baidu/xbox';
import { env } from './env';
/**
 * When page in IOS-IFRAME, scroll and rect have some bugs.
 * So we need add some elements to solve this problem.
 * copy from mip
 */
const patch = () => {
    const element = document.createElement('div');
    element.style.cssText = 'position:absolute;top:0;left:0;width:0;height:0;visibility:hidden;';
    document.body.appendChild(element);
    return element;
};
/**
 * 获取 Body 作为 Viewport 的封装
 *
 * @returns Viewport 结构
 */
const getBody = () => {
    const body = document.body;
    const bodyStyle = body.style;
    document.documentElement.style.overflowY = 'auto';
    document.documentElement.style.height = '100%';
    bodyStyle.position = 'relative';
    bodyStyle.height = '100%';
    bodyStyle.overflowY = 'scroll';
    bodyStyle.webkitOverflowScrolling = 'touch';
    const bodyRect = body.getBoundingClientRect();
    const element = patch();
    return {
        element: body,
        offsetWidth: body.offsetWidth,
        offsetHeight: body.offsetHeight,
        scrollWidth: body.scrollWidth,
        scrollHeight: body.scrollHeight,
        top: bodyRect.top,
        left: bodyRect.left,
        scrollTop(top) {
            if (top && isNumber(top)) {
                body.scrollTop = top;
                return top;
            }
            return Math.round(-element.getBoundingClientRect().top);
        },
    };
};
/**
 * 获取 Window 作为 Viewport 的封装
 *
 * @returns Viewport 结构
 */
const getWindow = () => ({
    element: window,
    offsetWidth: window.innerWidth,
    offsetHeight: window.innerHeight,
    scrollWidth: document.documentElement.scrollWidth,
    scrollHeight: document.documentElement.scrollHeight,
    top: 0,
    left: 0,
    scrollTop(top) {
        if (top && isNumber(top) && isFunction(window.scrollTo)) {
            window.scrollTo(0, top);
            return top;
        }
        return window.scrollY || 0;
    },
});
/**
 * 如果入参是 DOM 元素，将其封装为 viewport 结构
 * 如果是 iOS 环境下 iframe 中，viewport 为 body 的封装，否则是 window 的封装
 *
 * @param container 被封装为 viewport 的容器元素
 * @returns Viewport 结构
 */
export function getViewport(container) {
    if (container && container !== window && container !== document.body) {
        const element = container;
        const containerRect = element.getBoundingClientRect();
        return {
            element,
            offsetWidth: element.offsetWidth,
            offsetHeight: element.offsetHeight,
            scrollWidth: element.scrollWidth,
            scrollHeight: element.scrollHeight,
            top: containerRect.top,
            left: containerRect.left,
            scrollTop(top) {
                if (top && isNumber(top)) {
                    element.scrollTop = top;
                    return top;
                }
                return element.scrollTop;
            },
        };
    }
    else if (container === document.body || (window.self !== window.top && env.isIOS)) {
        return getBody();
    }
    return getWindow();
}
/**
 * 获取容器垂直方向滚动距离
 *
 * @param container 容器元素(可选)
 * @returns 垂直方向滚动距离
 */
export function getScrollTop(container) {
    return +getViewport(container).scrollTop();
}
/**
 * 判断容器是否滚动到底部
 *
 * @param container 容器元素(可选)
 * @returns 判断结果
 */
export function isScrollBottom(container) {
    const viewport = getViewport(container);
    return +viewport.scrollTop() + viewport.offsetHeight >= viewport.scrollHeight;
}
/**
 * 判断元素在指定容器内是否可见（露出1px）
 *
 * @param element DOM元素
 * @param container 目标元素
 * @param offsetX X轴偏移量
 * @param offsetY Y轴偏移量
 * @returns 元素是否可见
 */
export function isVisible(element, container = getViewport().element, offsetX = 1, offsetY = 1) {
    if (!element || !container) {
        return false;
    }
    const visible = (document && document.visibilityState) !== 'hidden';
    const elementRect = element.getBoundingClientRect();
    const viewport = getViewport(container);
    return (visible
        && elementRect.top < viewport.offsetHeight - offsetY
        && elementRect.bottom > viewport.top
        && elementRect.left < viewport.offsetWidth - offsetX
        && elementRect.right > viewport.left);
}
