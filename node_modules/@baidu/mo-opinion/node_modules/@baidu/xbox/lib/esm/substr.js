/**
 * @file 截取指定长度的字符串，将emoji和自定义的ubb表情识别为1个字符
 * @author jinzhan <jinzhan@baidu.com>
 *
 * 字符串编码相关正则表达式
 * refer: https://github.com/qlover/loadsh/blob/39a75c454047c51c328e608756d535791e6cdd88/loadsh-4.17.5/loadsh-4.17.5.js
 *
 * 课外知识: https://github.com/typescript-eslint/typescript-eslint/blob/v4.31.0/packages/eslint-plugin/docs/rules/prefer-regexp-exec.md
 * 因此我们需要关闭 eslint 规则 @typescript-eslint/prefer-regexp-exec，防止 match 正则被自动 fix 为 exec
 */
const rsAstralRange = '\ud800-\udfff';
const rsZWJ = '\u200d';
const rsVarRange = '\ufe0e\ufe0f';
const rsComboMarksRange = '\u0300-\u036f';
const rsComboHalfMarksRange = '\ufe20-\ufe2f';
const rsComboSymbolsRange = '\u20d0-\u20ff';
const rsFitz = '\ud83c[\udffb-\udfff]';
const rsRegional = '(?:\ud83c[\udde6-\uddff]){2}';
const rsSurrPair = '[\ud800-\udbff][\udc00-\udfff]';
const rsComboRange = rsComboMarksRange + rsComboHalfMarksRange + rsComboSymbolsRange;
const rsOptVar = `[${rsVarRange}]?`;
const rsCombo = `[${rsComboRange}]`;
const rsModifier = `(?:${rsCombo}|${rsFitz})`;
const rsOptMod = `${rsModifier}?`;
const rsAstral = `[${rsAstralRange}]`;
const rsNonAstral = `[^${rsAstralRange}]`;
const rsOptJoin = `(?:${rsZWJ}(?:${rsNonAstral}|${rsRegional}|${rsSurrPair})${rsOptVar}${rsOptMod})*`;
const rsSeq = rsOptVar + rsOptMod + rsOptJoin;
const rsSymbol = `(?:${rsNonAstral}${rsCombo}?|${rsCombo}|${rsRegional}|${rsSurrPair}|${rsAstral})`;
const rsUnicode = `${rsFitz}(?=${rsFitz})|${rsSymbol}${rsSeq}`;
const reHasUnicode = new RegExp(`[${rsZWJ}${rsAstralRange}${rsComboRange}${rsVarRange}]`);
const reUnicode = new RegExp(rsUnicode, 'g');
const hasUnicode = (val) => reHasUnicode.test(val);
const unicodeToArray = (val) => val.match(reUnicode) || [];
const asciiToArray = (val) => val.split('');
/**
 * 将字符转换为数组，方便进行截取
 *
 * emoji表情case示例：
 * ["[滑稽]", "[捂脸]", "[赞同]", "[大笑]", "[左捂脸]", ...]
 *
 * @param val 目标字符串
 * @param option 可选配置项
 * @param option.hasEmoji 是否包含 hasEmoji，默认:false
 * @param option.emojiMaxLen 单个emoji文本的最大长度，默认：8
 * @param option.emojiData emoji的详细信息，如果存在，则忽略 emojiMaxLen
 */
export function str2array(val, { hasEmoji = false, emojiMaxLen = 8, emojiData = [] } = {}) {
    if (!hasEmoji) {
        return hasUnicode(val) ? unicodeToArray(val) : asciiToArray(val);
    }
    const rsEmoji = emojiData.length
        ? emojiData.map(item => item.replace('[', '\\[').replace(']', '\\]')).join('|')
        : `\\[.{1,${emojiMaxLen - 2}}?\\]`;
    const reUbb = new RegExp(`${rsEmoji}|${rsUnicode}`, 'g');
    return val.match(reUbb) || [];
}
/**
 * 字符串裁剪，为了能更方便使用，采用打散运算符
 *
 * @param str 目标字符串
 * @param start 起始位置
 * @param rest 第三个及第四个可选参数\
 * 第三个参数是 number 类型时表示需要截取的字符串长度，例如\
 * `substr('[百度][微笑]family', 1, 1)` // 返回`百`\
 * 否则按照 EmojiOptions 选项配置参数调用 str2array 方法，例如\
 * `substr('[百度][微笑]family', 0, 1, {hasEmoji: true, emojiData: ['[百度]']})` // 返回`[百度]`\
 * 没有 rest 参数时从 start 截取到末尾，例如：
 * `substr('[百度][微笑]family', 4)` // 返回`[微笑]family`
 */
export function substr(str, start, ...rest) {
    const hasLength = typeof rest[0] === 'number';
    const data = hasLength ? str2array(str, rest[1]) : str2array(str, rest[0]);
    const ret = hasLength ? data.splice(start, rest[0]) : data.splice(start);
    return ret.join('');
}
