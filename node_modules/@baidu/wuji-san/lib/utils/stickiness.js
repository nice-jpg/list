"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _raf = require("./raf");

/**
 * @file stickiness
 * @author baozhixin <baozhixin@baidu.com>
 * @see https://medium.com/@elad/css-position-sticky-how-it-really-works-54cd01dc2d46
 * @see https://developers.google.com/web/updates/2017/09/sticky-headers
 */
var eventBinded = false;
var _native = false;
var listDom = [];
var listOpt = [];

if (typeof document !== 'undefined') {
  var i = 0; // 不用加那么多判断了，目前就有 blink 和 -webkit 两种情况

  var prefix = ['', '-webkit-'];
  var len = prefix.length;
  var dummy = document.createElement('div').style;

  while (i < len && !dummy.position) {
    dummy.position = "".concat(prefix[i++], "sticky");
  }

  _native = !!dummy.position;
}

var scrollHandler = function scrollHandler() {
  (0, _raf.raf)(function () {
    listOpt.forEach(function (opt) {
      opt.isSticky = !opt.wasSticky ? opt.top >= opt.el.getBoundingClientRect().top : opt.top >= opt.el.parentElement.getBoundingClientRect().top;

      if (opt.isSticky !== opt.wasSticky) {
        if (!_native) {
          if (opt.isSticky) {
            Object.assign(opt.el.style, {
              position: 'fixed',
              top: "".concat(opt.top, "px"),
              maxWidth: '750px'
            });
          } else {
            opt.el.removeAttribute('style');
          }
        }

        opt.wasSticky = opt.isSticky;
        opt.change(opt.isSticky);
      }
    });
  });
};

var refresh = function refresh() {
  if (listDom.length) {
    if (eventBinded) {
      return;
    }

    window.addEventListener('scroll', scrollHandler, false);
    eventBinded = true;
  } else {
    window.removeEventListener('scroll', scrollHandler);
    eventBinded = false;
  }
};

var _default = {
  "native": _native,
  add: function add(option) {
    if (!option || !option.el) {
      return;
    }

    if (listDom.indexOf(option.el) > -1) {
      return;
    }

    listDom.push(option.el);
    listOpt.push(option);
    refresh();
  },
  remove: function remove(option) {
    if (!option || !option.el) {
      return;
    }

    var index = listDom.indexOf(option.el);

    if (index > -1) {
      listDom.splice(index, 1);
      listOpt.splice(index, 1);
      refresh();
    }
  }
};
exports["default"] = _default;