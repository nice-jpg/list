/**
 * @file stickiness
 * @author baozhixin <baozhixin@baidu.com>
 * @see https://medium.com/@elad/css-position-sticky-how-it-really-works-54cd01dc2d46
 * @see https://developers.google.com/web/updates/2017/09/sticky-headers
 */

import {raf} from './raf';


let eventBinded = false;
let native = false;
const listDom = [];
const listOpt = [];

if (typeof document !== 'undefined') {
    let i = 0;
    // 不用加那么多判断了，目前就有 blink 和 -webkit 两种情况
    const prefix = [
        '',
        '-webkit-',
    ];
    const len = prefix.length;
    const dummy = document.createElement('div').style;

    while (i < len && !dummy.position) {
        dummy.position = `${prefix[i++]}sticky`;
    }
    native = !!dummy.position;
}

const scrollHandler = () => {
    raf(() => {
        listOpt.forEach(opt => {
            opt.isSticky = !opt.wasSticky
                ? opt.top >= opt.el.getBoundingClientRect().top
                : opt.top >= opt.el.parentElement.getBoundingClientRect().top;
            if (opt.isSticky !== opt.wasSticky) {
                if (!native) {
                    if (opt.isSticky) {
                        Object.assign(opt.el.style, {
                            position: 'fixed',
                            top: `${opt.top}px`,
                            maxWidth: '750px',
                        });
                    }
                    else {
                        opt.el.removeAttribute('style');
                    }
                }
                opt.wasSticky = opt.isSticky;
                opt.change(opt.isSticky);
            }
        });
    });
};
const refresh = () => {
    if (listDom.length) {
        if (eventBinded) {
            return;
        }
        window.addEventListener('scroll', scrollHandler, false);
        eventBinded = true;
    }
    else {
        window.removeEventListener('scroll', scrollHandler);
        eventBinded = false;
    }
};

export default {
    native,
    add(option) {
        if (!option || !option.el) {
            return;
        }
        if (listDom.indexOf(option.el) > -1) {
            return;
        }

        listDom.push(option.el);
        listOpt.push(option);
        refresh();
    },
    remove(option) {
        if (!option || !option.el) {
            return;
        }

        const index = listDom.indexOf(option.el);
        if (index > -1) {
            listDom.splice(index, 1);
            listOpt.splice(index, 1);
            refresh();
        }
    },
};
