/**
 * @file 组件 WujiPickerItem 无极-选择器选项
 * @author yangmei03 <yangmei03@baidu.com>
 *
 * TODO: 实现细节有些问题，后续优化
 */
import {Component} from 'san';

const prefixCls = 'w-picker-column';

export default class WujiPickerItem extends Component {
    static template = /* html */ `
        <div class="${prefixCls}"
            on-touchstart="onTouchStart"
            on-touchmove="onTouchMove"
            on-touchend="onTouchEnd"
            on-touchcancel="onTouchEnd"
        >
            <ul class="${prefixCls}-wrap"
                style="{{wrapperStyle}}"
                on-transitionend="onTransitionend"
            >
                <li
                    class="${prefixCls}-item {{currentIndex === index ? '${prefixCls}-selected': '' }}"
                    s-for="item, index in options"
                >{{item}}</li>
            </ul>
        </div>
    `;

    static computed = {
        count() {
            return this.data.get('options').length;
        },
        wrapperStyle() {
            const baseOffset = this.data.get('baseOffset');
            const offset = this.data.get('offset');
            const duration = this.data.get('duration');
            const v1 = `translate3d(0, ${offset + baseOffset}px, 0)`;
            const v2 = `${duration}ms`;
            const v3 = duration ? 'all' : 'none';

            return {
                '-webkit-transform': v1,
                'transform': v1,
                '-webkit-transition-duration': v2,
                'transition-duration': v2,
                '-webkit-transition-property': v3,
                'transition-property': v3,
            };
        },
    };

    initData() {
        return {
            count: 5, // 单列元素长度
            direction: '',
            offset: 0,
            deltaX: 0,
            deltaY: 0,
            offsetX: 0,
            offsetY: 0,
            startX: 0,
            startY: 0,
            duration: 0,
            startOffset: 0,
            currentIndex: 0,
            swipeDuration: 1000,
            moving: false,
            moveStatus: null,
            visibleItemCount: 5,
            MOMENTUM_LIMIT_TIME: 300,
            DEFAULT_DURATION: 200,
            MOMENTUM_LIMIT_DISTANCE: 15,
        };
    }

    created() {
        this.dispatch('changeChildren', {child: this, type: 'push'});
    }

    attached() {
        this.watch('itemHeight', value => {
            this.setIndex(this.data.get('currentIndex'));
        });
    }

    destroyed() {
        this.dispatch('changeChildren', {child: this, type: 'splice'});
    }

    onTouchStart(e) {
        this.touchStart(e);
        const {moving, baseOffset, offset} = this.data.get();
        let startOffset = offset;
        if (moving) {
            const cOffset = this.getOffset();
            startOffset = Math.min(0, cOffset - baseOffset);
        }
        this.data.set('duration', 0);
        this.data.set('transitionEndTrigger', null);
        this.data.set('touchStartTime', Date.now());
        this.data.set('startOffset', startOffset);
        this.data.set('momentumOffset', startOffset);
    }

    onTouchMove(e) {
        e.preventDefault();
        e.stopPropagation();
        this.touchMove(e);
        const {MOMENTUM_LIMIT_TIME, direction, startOffset /* , moving */} = this.data.get();
        if ('vertical' === direction) {
            this.data.set('moving', true);
        }
        const {deltaY, count, itemHeight, touchStartTime} = this.data.get();
        const offset = this.range(startOffset + deltaY, -(count * itemHeight), itemHeight);
        this.data.set('offset', offset);

        const time = Date.now();
        if (time - touchStartTime > MOMENTUM_LIMIT_TIME) {
            this.data.set('touchStartTime', time);
            this.data.set('momentumOffset', offset);
        }
    }

    onTouchEnd() {
        let that = this;
        const {DEFAULT_DURATION, MOMENTUM_LIMIT_DISTANCE, MOMENTUM_LIMIT_TIME} = this.data.get();
        const {offset, momentumOffset, touchStartTime} = this.data.get();

        let distance = offset - momentumOffset;
        let duration = Date.now() - touchStartTime;
        let allowMomentum = duration < MOMENTUM_LIMIT_TIME && Math.abs(distance) > MOMENTUM_LIMIT_DISTANCE;

        if (allowMomentum) {
            this.momentum(distance, duration);
            return;
        }

        let index = this.getIndexByOffset(offset);
        this.data.set('duration', DEFAULT_DURATION);
        this.setIndex(index, true); // compatible with desktop scenario
        setTimeout(function () {
            that.data.set('touchStartTime', null);
            that.data.set('moving', false);
        }, 0);
    }

    touchStart({touches}) {
        this.resetTouchStatus();
        this.data.set('startX', touches[0].clientX);
        this.data.set('startY', touches[0].clientY);
    }

    touchMove({touches}) {
        const {startX, startY} = this.data.get();
        const deltaX = touches[0].clientX - startX;
        const deltaY = touches[0].clientY - startY;
        const offsetX = Math.abs(deltaX);
        const offsetY = Math.abs(deltaY);

        const dc
            = offsetX > offsetY && offsetX > 10 ? 'horizontal' : offsetY > offsetX && offsetY > 10 ? 'vertical' : '';
        this.data.set('direction', this.data.get('direction') || dc);
        this.data.set('deltaX', deltaX);
        this.data.set('deltaY', deltaY);
        this.data.set('offsetX', offsetX);
        this.data.set('offsetY', offsetY);
    }

    resetTouchStatus() {
        this.data.set('direction', '');
        this.data.set('deltaX', 0);
        this.data.set('deltaY', 0);
        this.data.set('offsetX', 0);
        this.data.set('offsetY', 0);
    }

    getOffset() {
        // const e = this.ref('wrapper');
        const t = window.getComputedStyle(this.ref('wrapper'));
        const transform = t.transform || t.webkitTransform;
        return Number(transform.slice(7, transform.length - 1).split(', ')[5]);
    }

    range(num, min, max) {
        return Math.min(Math.max(num, min), max);
    }

    momentum(distance, duration) {
        const {offset, swipeDuration} = this.data.get();
        let speed = Math.abs(distance / duration);
        distance = offset + (speed / 0.002) * (distance < 0 ? -1 : 1);
        let index = this.getIndexByOffset(distance);
        this.data.set('duration', +swipeDuration);
        this.setIndex(index, true);
    }

    getIndexByOffset(offset) {
        const {itemHeight, count} = this.data.get();
        return this.range(Math.round(-offset / itemHeight), 0, count - 1);
    }

    setIndex(index, emitChange) {
        const that = this;
        const {itemHeight, currentIndex, moving, offset /* , options */} = this.data.get();
        index = this.adjustIndex(index) || 0;
        let coffset = -index * itemHeight;

        let trigger = function trigger() {
            if (index !== currentIndex) {
                that.data.set('currentIndex', index);

                if (emitChange) {
                    that.fire('change', index);
                }
            }
        }; // trigger the change event after transitionend when moving
        if (moving && coffset !== offset) {
            this.data.set('transitionEndTrigger', trigger);
        }
        else {
            trigger();
        }
        this.data.set('offset', coffset);
    }

    adjustIndex(index) {
        const {count, options} = this.data.get();
        index = this.range(index, 0, count);
        for (let i = index; i < count; i++) {
            if (!this.isOptionDisabled(options[i])) {
                return i;
            }
        }
        for (let j = index - 1; j >= 0; j--) {
            if (!this.isOptionDisabled(options[j])) {
                return j;
            }
        }
    }

    isOptionDisabled(option) {
        return typeof option === 'object' && option.disabled;
    }

    onTransitionend() {
        this.data.set('moving', false);
        this.data.set('duration', 0);
        const transitionEndTrigger = this.data.get('transitionEndTrigger');
        if (transitionEndTrigger) {
            transitionEndTrigger();
            this.data.set('transitionEndTrigger', null);
        }
    }

    setOptions(newOptions) {
        const {options, defaultIndex} = this.data.get();
        if (JSON.stringify(newOptions) !== JSON.stringify(options)) {
            this.data.set('options', newOptions);
            this.setIndex(defaultIndex);
        }
    }

    // 获取当前选中项的文本
    getValue() {
        const {options, currentIndex} = this.data.get();
        return options[currentIndex];
    }
}
