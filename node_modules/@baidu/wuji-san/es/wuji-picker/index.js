/**
 * @file 组件 WujiPicker 无极-选择器
 * @author yangmei03 <yangmei03@baidu.com>
 *
 * TODO: 实现细节有些问题，后续优化
 */

import './style/index.less';
import {Component} from 'san';
import PickerItem from './pickerItem';
const prefixCls = 'w-picker';

export default class WujiPicker extends Component {
    static template = /* html */ `
        <div
            class="${prefixCls}-wrap"
            style="height: {{itemHeight * visibleItemCount}}px"
        >
            <wuji-picker-item
                s-ref="pickerItem"
                s-for="column, index in rColumns"
                options="{{column.values}}"
                current-index="{{column.defaultIndex}}"
                base-offset="{{baseOffset}}"
                item-height="{{itemHeight}}"
                on-change="change(index, childIndex)"
            />
            <div
                class="${prefixCls}-column-mask"
                style="background-size: 100% {{baseOffset}}px"
            />
            <div
                class="${prefixCls}-column-picker"
                style="height: {{itemHeight}}px"
            />
        </div>
    `;

    static components = {
        'wuji-picker-item': PickerItem,
    };

    static dataTypes = {};

    static messages = {
        changeChildren({value}) {
            const children = this.data.get('children');
            switch (value.type) {
                case 'push':
                    children.push(value.child);
                    break;
                case 'splice':
                    children.splice(children.indexOf(value.child), 1);
                    break;
            }
            this.data.set('children', children);
        },
    };

    static computed = {
        baseOffset() {
            const visibleItemCount = this.data.get('visibleItemCount');
            const itemHeight = this.data.get('itemHeight');
            return itemHeight * ((visibleItemCount - 1) / 2);
        },
        dataType: function dataType() {
            let columns = this.data.get('columns');
            let firstColumn = columns[0] || {};

            if (firstColumn.children) {
                return 'cascade';
            }

            if (firstColumn.values) {
                return 'object';
            }

            return 'text';
        },
    };

    initData() {
        return {
            children: [],
            rColumns: [],
            itemHeight: 57,
            baseOffset: 0,
            currentIndex: 0,
            visibleItemCount: 5,
        };
    }

    attached() {
        this.formatColumn();
        this.nextTick(() => {
            const item = this.el.querySelector(`.${prefixCls}-column-item`);
            if (item) {
                this.data.set('itemHeight', item.clientHeight);
            }
        });
    }

    formatColumn() {
        const {columns, dataType, defaultIndex} = this.data.get();
        let rColumns = [];
        if (dataType === 'text') {
            rColumns = [
                {
                    values: columns,
                    defaultIndex: defaultIndex,
                },
            ];
        }
        else if (dataType === 'cascade') {
            rColumns = this.formatCascade();
        }
        else {
            rColumns = columns;
        }

        this.data.set('rColumns', rColumns);
    }

    formatCascade() {
        const {columns, defaultIndex, valueKey} = this.data.get();
        let formatted = [];
        let cursor = {
            children: columns,
        };

        while (cursor && cursor.children) {
            let dIndex = cursor.defaultIndex || +defaultIndex;
            formatted.push({
                values: cursor.children.map(function (item) {
                    return item[valueKey];
                }),
                className: cursor.className,
                defaultIndex: dIndex,
            });
            cursor = cursor.children[dIndex];
        }

        return formatted;
    }

    onCascadeChange(columnIndex) {
        const {columns, valueKey} = this.data.get();

        let cursor = {
            children: columns,
        };
        const indexes = this.getIndexes();
        // 获取当前选中列是否还有children
        for (let i = 0; i <= columnIndex; i++) {
            cursor = cursor.children[indexes[i]];
        }

        while (cursor.children) {
            columnIndex++;
            this.setColumnValues(
                columnIndex,
                cursor.children.map(function (item) {
                    return item[valueKey];
                })
            );
            cursor = cursor.children[cursor.defaultIndex || 0];
        }
    }

    // 每列目前选中的index
    getIndexes() {
        const children = this.data.get('children');
        return children.map(function (child) {
            return child.data.get('currentIndex');
        });
    }

    setColumnValues(index, options) {
        const children = this.data.get('children');
        let column = children[index];
        if (column) {
            column.setOptions(options);
        }
    }

    change(columnIndex) {
        const {dataType} = this.data.get();
        if (dataType === 'cascade') {
            this.onCascadeChange(columnIndex);
        }

        if (dataType === 'text') {
            this.fire('change', {
                picker: this,
                value: this.getColumnValue(0),
                columnIndex: this.getColumnIndex(0),
            });
        }
        else {
            this.fire('change', {
                picker: this,
                value: this.getValues(),
                columnIndex,
            });
        }
    }

    getColumnValue(index) {
        const children = this.data.get('children');
        let column = children[index];
        return column && column.getValue();
    }

    getColumnIndex(columnIndex) {
        const children = this.data.get('children');
        const column = children[columnIndex] || {};
        return column.data.get('currentIndex');
    }

    getValues() {
        const children = this.data.get('children');
        return children.map(function (child) {
            return child.getValue();
        });
    }
}
