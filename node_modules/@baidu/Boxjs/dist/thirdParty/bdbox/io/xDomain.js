
var $ = require('@baidu/Boxjs/dist/utils/_bdboxWrapper')
var xMessage = require('../event/xMessage');
var queryToJson = require('../utils/queryToJson');
var prefix = '_xd_';
var ready = require('../utils/ready');

/**
 * XDomain构造器
 * 请使用`Bdbox.io.xDomain`
 * @constructor XDomain
 * @inner
 * @param {string} url 父窗口使用需要传入代理页面url，子窗口不传入
 * @author wangyongqing01
 * @version $Id: xDomain.js 291630 2016-04-21 03:21:09Z wangyongqing01 $
 */
var XDomain = function(url) {
    var iframe = this.iframe = null;
    var WIN;
    var self = this;
    this.status = 'pending';
    this._callbacks = {};
    this._sendReadyData = [];
    this._handlers = {};
    if (url) {
        this.isIframe = false;
        //说明是父窗口，需要监听子窗口消息
        var id = this.id = $.getId();
        var tid = '_xid=' + id;
        url += (!~url.indexOf('#') ? '#' : '&') + tid;
        iframe = document.createElement('iframe');
        iframe.id = '_xd' + this.id;
        iframe.style.display = 'none';
        iframe.src = url;
        ready(function() {
            document.body.appendChild(iframe);
            self.iframe = iframe;
        });
        //添加监听
        xMessage.on(prefix + 'ready' + this.id, function() {
            self.fireReady.call(self);
        });
        WIN = iframe;
    } else {
        this.isIframe = true;
        //这是子窗口，需要push到父窗口
        var query = queryToJson(location.hash.slice(1));
        if (query._xid) {
            this.id = query._xid;
        } else {
            throw Error('XDomain id!');
        }

        WIN = parent;

        this.fireReady();
    }

    //添加监听
    xMessage.on(prefix + 'msg' + this.id, function(data) {
        self._msg(data);
    }).on(prefix + 'back' + this.id, function(data) {
        self._callback(data);
    }).on(prefix + 'clearcb' + this.id, function(data) {
        self._clearcb(data);
    });

    var self = this;
    /**
     * 发送消息
     * @function send
     * @memberOf XDomain
     *
     * @param  {string} action 事件类型，执行的命令
     * @param  {mixed} type 各种参数，可以连续传入
     * @param {funcation} callback 回调函数，**此回调是异步的！**
     * @return {XDomain}
     * @example
     * //父窗口使用需要传入代理页面url，子窗口不传入
     * var xDomain = new XDomain();
     * xDomain.send('msg', val, function(r){
     *      console.log(r);
     *      Bdbox.byId('msg').innerHTML += '<li>收到send回调消息：'+r+'</li>';
     *  });
     */
    this.send = function(w, id) {
        return function(action) {
            if (self.isReady()) {
                var args = $.toArray(arguments).slice(1);
                var fn = args.slice(-1)[0];
                var data = {
                    action: action
                };
                if ($.isFunction(fn)) {
                    //有回调函数，需要双方通信
                    var cbid = data.cbid = $.getId();
                    this._callbacks[cbid] = fn;
                    args.pop();
                }
                data.args = args;
                xMessage.fire(w, prefix + 'msg' + id, data);
            } else {
                this._sendReadyData.push($.toArray(arguments));
            }

            return self;
        };
    }(WIN, this.id);
    this._send = function(w, id) {
        return function(name, data) {
            xMessage.fire(w, prefix + name + id, data);
        };
    }(WIN, this.id);

    if (this.isIframe) {
        ready(function() {
            //通知父窗口，已经ready
            self._send('ready');
        });
    }

};
XDomain.prototype = {
    constructor: XDomain,
    _clearcb: function(data) {
        delete this._callbacks[data.cbid];
        return this;
    },
    _callback: function(data) {
        var cbid = data.cbid;
        var result = data.result;
        var cb = this._callbacks[cbid];
        // console.log(cbid, data, this._callbacks);
        if (cb) {
            cb(result, data);
        }
        return this;
    },
    _msg: function(data) {
        var action = data.action;
        var args = data.args;
        var handlers = this._handlers[action];

        if (handlers && handlers.length) {
            for (var i = 0, len = handlers.length; i < len; i++) {
                var handler = handlers[i];
                var fn = handler.fn;
                var once = handler.once;
                var result = fn.apply(null, args);
                if (data.cbid) {
                    //表示有回调，而且是【父→子】通信
                    this._send('back', {
                        cbid: data.cbid,
                        result: result
                    });
                }
                if (once) {
                    handlers.splice(i--, 1);
                    len--;
                }
            }
        }
        if (data.cbid) {
            //表示有回调，而且是【父→子】通信
            this._send('clearcb', {
                cbid: data.cbid
            });
        }
        return this;
    },
    /**
     * 绑定跨域事件
     * @param  {String}   type     类型
     * @param  {Function} callback 回调
     * @param  {Boolean}   [once=false]     是否只执行一次
     * @return {XDomain}
     * @example
     * //最后参数是true，相当于`.once`写法
     * xDomain.on('abc', function(a,b,c){
     *      Bdbox.byId('msg').innerHTML += '<li>收到abc事件：'+[a,b,c].join(',')+'</li>';
     *  }, true);
     *  //持续事件
     *  xDomain.on('abc', function(a,b,c){
     *      Bdbox.byId('msg').innerHTML += '<li>收到abc事件：'+[a,b,c].join(',')+'</li>';
     *  });
     */
    on: function(type, callback, once) {
        if ($.isFunction(callback)) {
            this._handlers[type] = this._handlers[type] || [];
            this._handlers[type].push({
                fn: callback,
                once: !! once
            });
        }
        return this;
    },
    /**
     * 绑定一次
     * @param  {String}   type     类型
     * @param  {Function} callback 回调函数
     * @return {XDomain}
     * @example
     * xDomain.once('abc', function(a,b,c){
     *      Bdbox.byId('msg').innerHTML += '<li>收到abc事件：'+[a,b,c].join(',')+'</li>';
     *  });
     */
    once: function(type, callback) {
        return this.on(type, callback, true);
    },
    /**
     * 解绑事件
     * @param  {String}   type     事件类型
     * @param  {Function} callback 被解绑的函数，不传则解绑所有type
     * @return {XDomain}
     * @example
     * xDomain.off('abc', function(a,b,c){
     *      Bdbox.byId('msg').innerHTML += '<li>收到abc事件：'+[a,b,c].join(',')+'</li>';
     *  });
     *  //解绑所有abc事件
     * xDomain.off('abc');
     *
     */
    off: function(type, callback) {
        var handlers = this._handlers[type];
        if (!handlers || !handlers.length) {
            return this;
        }
        if (!callback) {
            this._handlers[type].length = 0;
        }
        for (var i = 0, len = handlers.length; i < len; i++) {
            if (handlers[i].fn === handler) {
                handlers.splice(i, 1);
                return this;
            }
        }
        return this;
    },
    fireReady: function() {
        var self = this;
        this.status = 'ready';
        this._sendReadyData.forEach(function(args) {
            self.send.apply(self, args);
        });
        this._sendReadyData.length = 0;
        return this;
    },
    isReady: function() {
        return this.status === 'ready';
    },
    destroy:function(){
        if(this.iframe){
            document.body.removeChild(this.iframe);
        }
    }

};

/**
 * 基于xMessage包装的跨域通信组件
 * 产生一个隐藏iframe，私下通信，支持回调和callback
 * 详细使用请看demo/bdbox/xdomain.html
 *
 * @memberOf Bdbox.io
 * @function
 *
 * @param {string} url 父窗口需要传入通信代理页面url，子窗口不需要传入
 * @return {XDomain}
 */
var xDomain = function(url) {
    return new XDomain(url);
};
xDomain.XDomain = XDomain;
return xDomain;
