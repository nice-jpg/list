/**
 * boxx.js 
 * v3.0.69
 */

(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
    typeof define === 'function' && define.amd ? define(factory) :
    (global = global || self, global.boxx = factory());
}(this, (function () { 'use strict';

    var ADAPTVERSION = {
    	lite: {
    		"5.24.0.0": {
    			android: "13.2.0.0",
    			ios: "13.2.1.0"
    		},
    		"5.21.0.0": {
    			android: "12.28.0.0",
    			ios: "12.28.2.0"
    		},
    		"5.15.0.0": {
    			android: "12.21.0.0",
    			ios: "12.21.0.0"
    		},
    		"5.6.0.0": {
    			android: "12.13.0.0",
    			ios: "12.13.0.0"
    		},
    		"5.0.0.0": {
    			android: "12.1.0.0",
    			ios: "12.1.0.0"
    		},
    		"4.21.0.0": {
    			android: "11.24.0.0",
    			ios: "11.24.0.0"
    		},
    		"4.17.0.0": {
    			android: "11.22.0.0",
    			ios: "11.22.0.0"
    		}
    	},
    	tomas: {
    		"1.13.0.0": {
    			android: "12.19.0.0",
    			ios: "12.19.0.0"
    		},
    		"1.0.0.0": {
    			android: "12.1.0.0",
    			ios: "12.1.0.0"
    		}
    	},
    	baiduboxvision: {
    		"2.0.0.0": {
    			android: "12.15.0.0",
    			ios: "12.15.0.0"
    		},
    		"1.0.0.0": {
    			android: "11.25.9.10",
    			ios: "11.25.5.15"
    		}
    	},
    	baiduboxsenior: {
    		"1.0.0.0": {
    			android: "12.1.0.0",
    			ios: "12.1.0.0"
    		}
    	},
    	knews: {
    		"2.0.0.0": {
    			android: "12.13.0.0",
    			ios: "12.13.0.0"
    		}
    	}
    };

    /**
     * @file  获取全局对象
     * @author zhoudan03
     * @date 2019/8/6
     * @description 获取当前环境的全局对象, @todo 有必要这么判断么？
     */
    /* global globalThis */

    var global$1 =
        /* eslint-disable no-negated-condition */
        typeof globalThis !== 'undefined'
            ? globalThis
            : typeof window !== 'undefined'
                ? window
                // eslint-disable-next-line no-use-before-define
                : typeof global$1 !== 'undefined'
                    // eslint-disable-next-line no-use-before-define
                    ? global$1
                    : typeof self !== 'undefined' ? self : {};
        /* eslint-enable no-negated-condition */

    /**
     * @file: debug.js
     * @description 开发环境输出日志信息，便于调试
     */
    var debugInstance = null;

    var messageList = [];

    function setDebug(debug) {
        debugInstance = debug;
        messageList.forEach(function (item) {
            debugInstance.apply(void 0, item);
        });
        messageList = [];
    }

    function debug() {
        var args = [], len = arguments.length;
        while ( len-- ) args[ len ] = arguments[ len ];

        if (!debugInstance) {
            messageList.push(args);
            return;
        }
        debugInstance.apply(void 0, args);
    }

    /**
     * @file  环境判断的变量及函数
     * @author zhoudan03
     * @date 2019/8/15
     */
    // 矩阵产品的端能力适配，端发版对齐新的主线版本时，这里需要新增
    // 矩阵映射表：http://wiki.baidu.com/pages/viewpage.action?pageId=1649977238
    // ADAPTVERSION 数据如需要更新，执行npm run updateAdapteInfo
    // 表示无穷大的版本
    var INFINITYVERSION = '99999';
    /**
     * 比较两个参数版本大小
     *
     * @param {string} version1 v1
     * @param {string} version2 v2
     * @return {number} 1 v1 > v2 ; -1 v1 < v2 ; 0 v1 = v2
     */
    function versionCompare(version1, version2) {
        if (version1 === version2) {
            return 0;
        }

        function toNumber(item) {
            if (!(+item >= 0)) {
                throw new Error('传递了非法版本号:: ' + item);
            }
            return +item;
        }

        var versionArray1 = ('' + version1).split('.').map(toNumber);
        var versionArray2 = ('' + version2).split('.').map(toNumber);

        var i = 0;
        var len = Math.max(versionArray1.length, versionArray2.length);

        for (; i < len; i++) {
            if ((versionArray1[i] > versionArray2[i]) ||
                versionArray1[i] && !versionArray2[i] && versionArray1[i] > 0) {
                return 1;
            }
            else if ((versionArray1[i] < versionArray2[i]) ||
                (versionArray2[i] && !versionArray1[i] && versionArray2[i] > 0)) {
                return -1;
            }
        }
        return 0;
    }

    var inBrowser = typeof window !== 'undefined';
    var UA = inBrowser && window.navigator.userAgent.toLowerCase();

    /**
     * 获取iOS/Android操作系统版本号
     *
     * @return {number}
     */
    function getOSVersion(options) {
        var UA = options.UA;
        var isIOS = options.isIOS;
        var isAndroid = options.isAndroid;
        var result = 0;
        if (isAndroid) {
            var androidMatch = UA.match(/(android);?\s+([\d.]+)?/);
            // 优先判断android并且提前 return，避免 android 的仿 IOS 系统，例如'android 1.1 xxxIOS 1.0'情况被识别为 ios 系统并返回错误版本
            return androidMatch && androidMatch[2];
        }
        if (isIOS) {
            var iosMatch = UA.match(/(ipad|iphone|ipod).*os\s([\d_]+)/);
            return iosMatch && iosMatch[2].replace(/_/g, '.');
        }
        return result;
    }


    /**
     * 获取当前 UA 适配的版本信息，该方法依赖适配信息ADAPTVERSION，即时外部调用也可以保证在ADAPTVERSION的适配范围内
     * @param {string} bdversion 当前 UA 的真实版本
     * @param {string} uaType 当前 UA 的真实类型: 'main'、'mission'、'lite'、'tomas'、'baiduboxvision'、'unknown'，伴随矩阵产品的增加会越来越多
     * @return {string}
     */
    function getAdaptVersion(options) {
        var boxType = options.boxType;
        var realBoxVersion = options.realBoxVersion;
        var isIOS = options.isIOS;
        // 获取适配信息中的版本list
        var versionList = ADAPTVERSION[boxType] || {};
        var adaptVersionKeys = Object.keys(versionList);
        var len = adaptVersionKeys.length;
        // ADAPTVERSION中没有适配信息的 UA，返回'', 表示不支持端能力，若需要支持boxxx，需要在ADAPTVERSION中增加配置
        if (len === 0) {
            return '';
        }
        // 获取适配前的版本list，并且从高到底排序
        adaptVersionKeys.sort(versionCompare).reverse();
        for (var i = 0; i < adaptVersionKeys.length; i++) {
            var adaptVersionKey = adaptVersionKeys[i];
            if (versionCompare(realBoxVersion, adaptVersionKey) >= 0) {
                if (typeof versionList[adaptVersionKey] !== 'string') {
                    return isIOS ? versionList[adaptVersionKey].ios : versionList[adaptVersionKey].android;
                }
                return versionList[adaptVersionKey];
            }
        }
        // 低于ADAPTVERSION中的最低版本的app，表示没有对齐主线，返回''
        return '';
    }

    /**
     * 获取当前环境真实版本号，后续打点中需要使用
     * @returns {string}
     */
    function getRealBoxVersion(options) {
        var isBdApp = options.isBdApp;
        var UA = options.UA;
        var appProtoName = options.appProtoName;
        if (isBdApp) {
            var bdappMatch = (new RegExp(appProtoName + '/([\\d+.]+)')).exec(UA);
            if (bdappMatch && bdappMatch[1]) {
                return bdappMatch[1];
            }
        }
        // 现代手百，包含main和lite
        var match = /baiduboxapp\/([\d+.]+)/.exec(UA);
        if (match && match[1]) {
            return match[1];
        }

        // 某个历史版本手百
        if (global$1.baiduboxapp_version) {
            return global$1.baiduboxapp_version;
        }

        // 某个历史版本手百
        var oldMatch = /([\d+.]+)_(?:diordna|enohpi)_/.exec(UA);
        return oldMatch && oldMatch[1] && oldMatch[1].split('.').reverse()
            .join('.') || 0;
    }

    /**
     * 获取适配主线的版本号，大字版、青春版、关怀版、lite返回适配后的主线版本，主线其真实版本
     * @return {string}
     */
    function getMainBoxVersion(options) {
        var isBdApp = options.isBdApp;
        var isLiteBox = options.isLiteBox;
        var realBoxVersion = options.realBoxVersion;
        // bdapp 和 lite 矩阵产品使用对齐主线的版本
        if (isBdApp || isLiteBox) {
            return getAdaptVersion(options);
        }
        return realBoxVersion;
    }


    /**
     * 获取 UA 相关的信息
     * @param {string} UA
     * @returns {string}
     */
    function getUAInfo(UA) {
        var isIOS = UA && /iphone|ipad|ipod|ios/.test(UA);
        var isAndroid = UA && UA.indexOf('android') > 0;
        // 系统优先判断 android, 避免 android 的仿 IOS 系统，例如'android 1.1 xxxIOS 1.0'情况被识别为 ios 系统
        var OS = isAndroid ? 'android' : (isIOS ? 'ios' : 'unknown');
        var options = {
            UA: UA,
            isIOS: isIOS,
            isAndroid: isAndroid
        };
        // 操作系统版本
        var OSVersion = getOSVersion(options);
        // 手百系列产品
        var isBoxSeries = / baiduboxapp\//i.test(UA) || / bdapp\//i.test(UA);
        // bdapp协议的手百矩阵产品
        var isBdApp = / bdapp\//i.test(UA);
        // 获取bdapp协议头
        var schemaHeadReg = / bdapp\/\d+[.\d+]*\s\((\w+)[;]?\s?(\w+)?\)/g;
        var appSchemaHead = schemaHeadReg.exec(UA);
        // 浏览器是否支持小程序
        var isSupportSwanInBrowser = inBrowser && window && window._na
            && window._na.isSupportSwan && window._na.getSchemeHeader && window._na.isSupportSwan();
        // 若浏览器支持小程序，获取对应的端能力协议头
        var appProtoName = isSupportSwanInBrowser
            ? window._na.getSchemeHeader()
            : (appSchemaHead ? (appSchemaHead[2] || appSchemaHead[1]) : 'baiduboxapp');
        // 手百主版本
        var isMainBox = / baiduboxapp\//i.test(UA) && !/ (lite|info|pro|mission) baiduboxapp/.test(UA) && !isBdApp;
        // 手百极速版（在 iOS，极速版的关键词是 info; 在 Android，极速版的 UA 关键字是 lite。其他也为 info 的产品为 lite 的前身，可以忽略）
        // wiki:  http://wiki.baidu.com/pages/viewpage.action?pageId=418333914
        var isLiteBox = (isIOS && / info baiduboxapp\//i.test(UA)) || (isAndroid && / lite baiduboxapp\//i.test(UA));
        // 手百看多多
        var isMissionBox = / mission baiduboxapp\//i.test(UA);
        // 手百类型    'main'主版  'mission'看多多  'lite'极速版
        var boxType = isMainBox
            ? 'main'
            : (isMissionBox ? 'mission' : (isLiteBox ? 'lite' : (appProtoName || 'unknown')));
        // 适配后的手百类型
        var adaptBoxType = 'main';
        // 浏览器框架  light：轻浏览器框架；search：主（搜索）浏览器框架; imagesearch mian: 多模半屏webview
        var boxBrowserType = /imagesearch[\s\S]+main/i.test(UA)
            ? 'imageseach'
            : /light/i.test(UA) ? 'light' : 'search';
        Object.assign(options, {
            isBdApp: isBdApp,
            boxType: boxType,
            appProtoName: appProtoName
        });
        // 获取当前 UA 对应的真实版本号，后续打点中需要使用
        var realBoxVersion = getRealBoxVersion(options);
        Object.assign(options, {
            realBoxVersion: realBoxVersion,
            isLiteBox: isLiteBox
        });
        // 获取当前 UA 适配主线的版本号，大字版、青春版、关怀版返回适配后的主线版本，主线和lite返回其真实版本
        var boxVersion = getMainBoxVersion(options);
        return {
            isIOS: isIOS,
            isAndroid: isAndroid,
            OS: OS,
            OSVersion: OSVersion,
            isBoxSeries: isBoxSeries,
            isBdApp: isBdApp,
            isSupportSwanInBrowser: isSupportSwanInBrowser,
            appProtoName: appProtoName,
            isMainBox: isMainBox,
            isLiteBox: isLiteBox,
            isMissionBox: isMissionBox,
            boxType: boxType,
            adaptBoxType: adaptBoxType,
            boxBrowserType: boxBrowserType,
            realBoxVersion: realBoxVersion,
            boxVersion: boxVersion
        };
    }

    var ref = getUAInfo(UA);
    var isIOS = ref.isIOS;
    var isAndroid = ref.isAndroid;
    var OS = ref.OS;
    var OSVersion = ref.OSVersion;
    var isBoxSeries = ref.isBoxSeries;
    var isBdApp = ref.isBdApp;
    var isSupportSwanInBrowser = ref.isSupportSwanInBrowser;
    var appProtoName = ref.appProtoName;
    var isMainBox = ref.isMainBox;
    var isLiteBox = ref.isLiteBox;
    var isMissionBox = ref.isMissionBox;
    var boxType = ref.boxType;
    var adaptBoxType = ref.adaptBoxType;
    var boxBrowserType = ref.boxBrowserType;
    var realBoxVersion = ref.realBoxVersion;
    var boxVersion = ref.boxVersion;

    /**
     * 为某一对象数据上添加环境信息： app 类型， app 版本
     *     一般用来做统计， 比如在错误事件数据上添加
     *
     * @param {Object} data 原数据
     */
    function addEnvInfo(data) {
        try {
            data.boxType = boxType;
            data.boxVersion = realBoxVersion;
        }
        catch (ex) {
            // nothind
        }

        return data;
    }

    /**
     * 主线 12.16 以下以及其它矩阵产品均使用兜底描述表
     * 矩阵产品开启端描述表下发以后，这个需要同步变更
     * @param {*} isLocalDesc 是否命中兜底描述表
     * @param {*} options UA 相关参数，options由于编译问题不能与全局变量同名
     */
    function isHitLocDesc(isLocalDesc, options) {
        if ( options === void 0 ) options = {
        isApp: isMainBox,
        isBdBox: isBdApp,
        isLiteApp: isLiteBox,
        appType: boxType,
        realAppVersion: realBoxVersion
    };

        var isApp = options.isApp;
        var isBdBox = options.isBdBox;
        var isLiteApp = options.isLiteApp;
        var appType = options.appType;
        var realAppVersion = options.realAppVersion;
        if (isLocalDesc) {
            if (isApp && versionCompare(realAppVersion, '12.16') < 0
            || isBdBox || isLiteApp) {
                debug(appType + realAppVersion + '使用兜底描述表，符合预期');
            }
            else {
                debug(appType + realAppVersion + '使用兜底描述表，！！！不符合预期，请加抽样验证效果！！！');
            }
        }
        else if (isApp) {
            if (versionCompare(realAppVersion, '12.16') > 0) {
                debug(appType + realAppVersion + '使用端描述表，符合预期');
            }
            else {
                debug(appType + realAppVersion + '使用端描述表，！！！不符合预期，请去掉抽样使用兜底描述表验证效果！！！');
            }
        }
        else {
            // 线上矩阵产品不会命中抽样，一直使用兜底描述表
            debug('矩阵产品' + appType + realAppVersion + '线上无法命中联动实验，不会使用端描述表，！！！不需要加抽样验证，请去掉抽样使用兜底描述表验证效果！！！');
        }
    }

    var env = /*#__PURE__*/Object.freeze({
        __proto__: null,
        INFINITYVERSION: INFINITYVERSION,
        versionCompare: versionCompare,
        inBrowser: inBrowser,
        UA: UA,
        getUAInfo: getUAInfo,
        isIOS: isIOS,
        isAndroid: isAndroid,
        OS: OS,
        OSVersion: OSVersion,
        isBoxSeries: isBoxSeries,
        isBdApp: isBdApp,
        isSupportSwanInBrowser: isSupportSwanInBrowser,
        appProtoName: appProtoName,
        isMainBox: isMainBox,
        isLiteBox: isLiteBox,
        isMissionBox: isMissionBox,
        boxType: boxType,
        adaptBoxType: adaptBoxType,
        boxBrowserType: boxBrowserType,
        realBoxVersion: realBoxVersion,
        boxVersion: boxVersion,
        addEnvInfo: addEnvInfo,
        isHitLocDesc: isHitLocDesc
    });

    /**
     * 广播事件处理
     * @description 目标: 为了尽可能的减少模块之间业务逻辑的耦合度, 而开发了这个eventbus, 主要用于业务逻辑的事件传递
     * 使用规范: 每个js模块尽可能通过事件去通信, 减少模块之间的直接调用和依赖(耦合)
     *
     * @author chenqi14
     */
    var _cache = {};
    var broadcast = {

        /**
         * 派发
         * @param  {String} type 事件类型
         * @param  {...*} data 回调数据，支持连续传递
         * @return {this}   this   broadcast对象
         * @example
         * Bdbox.event.broadcast.fire('some event', arg1, arg2)
         */
        fire: function fire(type, data) {
            var listeners = _cache[type];
            var len = 0;
            if (listeners) {
                // eslint-disable-next-line prefer-rest-params
                var args = [].slice.call(arguments, 0); // 后面补单测时请删除上面的 disable 注释
                args = args.length > 2 ? args.splice(2, args.length - 1) : [];
                args = [type, data].concat(args);

                len = listeners.length;
                for (var i = 0; i < len; i++) {
                    var listener = listeners[i];
                    if (listener && listener.callback) {
                        args = args.concat(listener.args);
                        listener.callback.apply(listener.scope, args);
                    }
                }
            }
            return this;
        },

        /**
         * 订阅广播事件
         * @param  {String}   types     事件类型，支持`,`分隔符
         * @param  {Function} callback 回调函数
         * @param  {Object}   [scope=undefined]    回调函数上下文
         * @return {this}    this broadcast
         * @example
         * Bdbox.event.broadcast.on('some event,someevent2', function(arg1, arg2){
         *     console.log(arg1, arg2);
         * });
         */
        on: function on(types, callback, scope) {
            types = types || [];
            // eslint-disable-next-line prefer-rest-params
            var args = [].slice.call(arguments); // 后面补单测时请删除上面的 disable 注释


            if (typeof types === 'string') {
                types = types.split(',');
            }
            var len = types.length;
            if (len === 0) {
                return this;
            }
            args = args.length > 3 ? args.splice(3, args.length - 1) : [];
            for (var i = 0; i < len; i++) {
                var type = types[i];
                _cache[type] = _cache[type] || [];
                _cache[type].push({
                    callback: callback,
                    scope: scope,
                    args: args
                });
            }
            return this;
        },

        /**
         * 退订
         * @param  {String}   type     退订服务的类型
         * @param  {Function} callback 假如传入则移出传入的监控事件，否则移出全部
         * @return {this} this broadcast
         * @example
         * Bdbox.event.broadcast.off('some event', callback);
         */
        off: function off(type, callback, scope) {
            var listeners = _cache[type];
            if (!listeners) {
                return this;
            }
            if (callback) {
                var len = listeners.length;
                var tmp = [];

                for (var i = 0; i < len; i++) {
                    var listener = listeners[i];
                    if (listener.callback !== callback || listener.scope !== scope) {
                        tmp.push(listener);
                    }
                }
                _cache[type] = tmp;
            }
            else {
                listeners.length = 0;
            }
            return this;
        },

        /**
         * 移出所有事件
         * @return {this} this broadcast对象
         */
        removeAll: function removeAll() {
            _cache = {};
            return this;
        }
    };

    function EventEmitter() {
        var handlers = {};
        return {
            on: function on(eventName, fn) {
                if (handlers.hasOwnProperty(eventName)) {
                    handlers[eventName].indexOf(fn) === -1
                    && handlers[eventName].push(fn);
                }
                else {
                    handlers[eventName] = [fn];
                }
            },

            off: function off(eventName, fn) {
                var handlerList = handlers[eventName] || [];
                var index = handlerList.indexOf(fn);
                if (index > -1) {
                    handlers[eventName].splice(index, 1);
                }
            },

            once: function once(eventName, fn) {
                var this$1 = this;

                var only = function () {
                    var args = [], len = arguments.length;
                    while ( len-- ) args[ len ] = arguments[ len ];

                    this$1.off(eventName, only);
                    fn.apply.apply(fn, [ this$1 ].concat( args ));
                };
                this.on(eventName, only);
            },

            emit: function emit(eventName) {
                var args = [], len$1 = arguments.length - 1;
                while ( len$1-- > 0 ) args[ len$1 ] = arguments[ len$1 + 1 ];

                var arr = eventName.split(':');
                var len = arr.length;

                // 不允许直接 emit('xxx:*')
                if (len === 2 && arr[1] === '*') {
                    return;
                }

                // emit ('xxx:*')事件
                if (len > 1) {
                    var key = arr[0] + ':*';
                    handleEmitEvent.apply(void 0, [ handlers, key, eventName ].concat( args ));
                }

                // 执行eventName事件
                handleEmitEvent.apply(void 0, [ handlers, eventName ].concat( args ));
            }
        };

    }

    function handleEmitEvent(handlers, key) {
        var args = [], len = arguments.length - 2;
        while ( len-- > 0 ) args[ len ] = arguments[ len + 2 ];

        if (handlers.hasOwnProperty(key)) {
            handlers[key].forEach(function (fn) {
                fn.apply(void 0, args);
            });
        }
    }

    /**
     * 暴露给外部事件
     */
    var event = new EventEmitter();

    /**
     * 暴露给内部事件
     */
    var innerEvent = new EventEmitter();

    /**
     * @file 厂商浏览器端能力描述表list
     * @author lihuanyu01
     * @data 2021/10/08
     * @wiki 厂商浏览器需要按照此规范接入：http://wiki.baidu.com/pages/viewpage.action?pageId=1685360555
     * @desc 搜索可以维护10个以内的描述表，当描述表较多时，必须推动厂商自行下发描述表
     */
    var browserDescriptionList = [{
        name: 'swan.open',
        invoke: 'iframe.openSwan',
        args: [{
            name: 'appKey',
            value: 'string'
        }, {
            name: 'path',
            value: 'string='
        }, {
            name: 'query',
            value: 'Object='
        }, {
            name: '_baiduboxapp',
            value: {
                type: {
                    from: 'string=',
                    notinhis: 'string=',
                    srcAppId: 'string=',
                    extraData: 'Object=',
                    ext: 'Object=',
                    srcAppPage: 'string=',
                    ubc: 'Object=',
                    navi: 'string=',
                    backwardURL: 'string='
                }
            }
        }, {
            name: 'third_ext',
            value: 'string='
        }, {
            name: 'abtest',
            value: 'string='
        }, {
            name: 'oauthType',
            value: 'string='
        }, {
            name: '_swaninfo',
            value: 'string='
        }, {
            name: 'downloadUrl',
            value: 'string='
        }, {
            name: 'udid',
            value: 'string='
        }, {
            name: 'host',
            value: 'string='
        }, {
            name: 'cb',
            value: 'string='
        }, {
            name: 'port',
            value: 'string='
        }],
        authority: 'swan',
        scheme: window && window._na && window._na.getSchemeHeader && window._na.getSchemeHeader()
    }];

    var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

    function createCommonjsModule(fn, module) {
    	return module = { exports: {} }, fn(module, module.exports), module.exports;
    }

    var jsNative = createCommonjsModule(function (module, exports) {
    /**
     * @file js-native 通信管理
     * @author errorrik(errorrik@gmail.com)
     * @author houyu(785798835@qq.com)
     */

    (function (root) {

        /**
         * 对数组进行遍历
         *
         * @inner
         * @param {Array} array 要遍历的数组
         * @param {Function} fn 遍历函数
         */
        function each(array, fn) {
            var len = array && array.length || 0;

            for (var i = 0, l = len; i < l; i++) {
                if (fn(array[i], i) === false) {
                    break;
                }
            }
        }

        /**
         * 返回原值的方法，调用过程的兜底处理函数
         *
         * @inner
         * @param {*} source 原值
         * @return {*}
         */
        function returnRaw(source) {
            return source;
        }

        /**
         * 对返回值进行 JSON 解码（反序列化）处理的函数
         *
         * @inner
         * @param {*} source 原值
         * @return {*}
         */
        function returnJSONDecode(source) {
            return typeof source === 'string' ? JSON.parse(source) : source;
        }


        /**
         * 参数检查，错误直接抛出异常
         *
         * @inner
         * @param {Array} args 调用参数
         * @param {Array} declarations 参数声明列表
         */
        function checkArgs(args, declarations, apiContainer) {
            each(declarations, function (declaration, i) {
                var errorMsg;
                var value = normalizeValueDeclaration(declaration.value);

                switch (checkValue(args[i], value)) {
                    case 1:
                        errorMsg = ' is required.';
                        break;

                    case 2:
                        errorMsg = ' type error. must be ' + JSON.stringify(value.type || 'Array');
                        break;

                    case 3:
                        errorMsg = ' type error, must be oneOf ' + JSON.stringify(value.oneOf);
                        break;

                    case 4:
                        errorMsg = ' type error, must be oneOfType ' + JSON.stringify(value.oneOfType);
                        break;

                    case 5:
                        errorMsg = ' type error, must be arrayOf ' + JSON.stringify(value.arrayOf);
                        break;
                }

                if (errorMsg) {
                    var title = apiContainer && apiContainer.options.errorTitle || 'jsNative';
                    throw new Error('[' + title + ' Argument Error]' + declaration.name + errorMsg);
                }
            });
        }

        /**
         * 对值声明进行标准化处理
         *
         * @inner
         * @param {Object|string} declaration 值声明
         * @return {Object}
         */
        function normalizeValueDeclaration(declaration) {
            if (typeof declaration === 'string') {
                var realDeclaration = {isRequired: true};


                if (/=$/.test(declaration)) {
                    realDeclaration.isRequired = false;
                    declaration = declaration.slice(0, declaration.length - 1);
                }

                if (/\[\]$/.test(declaration)) {
                    realDeclaration.arrayOf = declaration.slice(0, declaration.length - 2);
                }
                else if (declaration.indexOf('|') > 0) {
                    realDeclaration.oneOfType = declaration.split('|');
                }
                else {
                    realDeclaration.type = declaration;
                }

                return realDeclaration;
            }

            return declaration;
        }


        /**
         * 对参数值进行检查
         *
         * @inner
         * @param {*} value 值
         * @param {Object} declaration 值声明
         * @return {number}
         */
        function checkValue(value, declaration) {
            declaration = normalizeValueDeclaration(declaration);
            if (value == null) {
                return declaration.isRequired && declaration.type !== '*' ? 1 : 0;
            }


            var valid = false;
            switch (typeof declaration.type) {
                case 'string':
                    switch (declaration.type) {
                        case 'string':
                        case 'boolean':
                        case 'number':
                        case 'function':
                        case 'object':
                            valid = typeof value === declaration.type;
                            break;

                        case 'Object':
                            valid = typeof value === 'object';
                            break;

                        case 'Array':
                            valid = value instanceof Array;
                            break;

                        case '*':
                            valid = true;
                            break;
                    }

                    if (!valid) {
                        return 2;
                    }
                    break;

                case 'object':
                    if (value && typeof value === 'object') {
                        valid = true;
                        for (var key in declaration.type) {
                            valid = !checkValue(value[key], declaration.type[key]);

                            if (!valid) {
                                break;
                            }
                        }
                    }

                    if (!valid) {
                        return 2;
                    }
                    break;

                default:

                    if (declaration.oneOf) {

                        each(declaration.oneOf, function (expectValue) {
                            valid = expectValue === value;
                            return !valid;
                        });

                        if (!valid) {
                            return 3;
                        }

                    }
                    else if (declaration.oneOfType) {

                        each(declaration.oneOfType, function (expectType) {
                            valid = !checkValue(value, expectType);
                            return !valid;
                        });

                        if (!valid) {
                            return 4;
                        }

                    }
                    else if (declaration.arrayOf) {

                        if (value instanceof Array) {
                            valid = true;
                            each(value, function (item) {
                                return (valid = !checkValue(item, declaration.arrayOf));
                            });

                            if (!valid) {
                                return 5;
                            }
                        }
                        else {
                            return 2;
                        }

                    }
            }

            return 0;
        }

        /**
         * 对调用参数中的所有回调函数，进行参数解码（反序列化）包装
         *
         * @inner
         * @param {Array} args 调用参数
         * @return {Array}
         */
        function wrapDecodeFuncArgs(args) {
            each(args, function (arg, i) {
                if (typeof arg === 'function') {
                    args[i] = wrapDecodeFuncArg(arg);
                }
            });

            return args;
        }

        /**
         * 对回调函数的参数进行解码（反序列化）包装
         *
         * @inner
         * @param {Function} fn 回调函数
         * @return {Function}
         */
        function wrapDecodeFuncArg(fn) {
            return function (arg) {
                fn(typeof arg === 'string' ? JSON.parse(arg) : arg);
            };
        }

        /**
         * 对调用参数中的所有回调函数，进行序列化包装
         *
         * @inner
         * @param {Array} args 调用参数
         * @return {Array}
         */
        function wrapArgFunc(args) {
            each(args, function (arg, i) {
                if (typeof arg === 'function') {
                    args[i] = wrapFunc(arg);
                }
            });

            return args;
        }

        /**
         * 用于回调函数包装命名的自增id
         *
         * @inner
         * @type {number}
         */
        var funcId = 1;

        /**
         * 用于回调函数包装命名的前缀
         *
         * @inner
         * @const
         * @type {string}
         */
        var FUNC_PREFIX = '__jsna_';

        /**
         * 对回调函数，进行序列化包装
         *
         * @inner
         * @param {Function} fn 回调函数
         * @return {string}
         */
        function wrapFunc(fn) {
            var funcName = FUNC_PREFIX + (funcId++);

            root[funcName] = function (arg) {
                delete root[funcName];
                fn(arg);
            };

            return funcName;
        }

        /**
         * 对调用参数中的所有参数进行JSON序列化
         *
         * @inner
         * @param {Array} args 调用参数
         * @return {Array}
         */
        function argJSONEncode(args) {
            each(args, function (arg, i) {
                args[i] = JSON.stringify(arg);
            });

            return args;
        }

        /**
         * 将调用参数合并成对象
         *
         * @inner
         * @param {Array} args 调用参数
         * @param {Array} declarations 参数声明列表
         * @return {Object}
         */
        function argCombine(args, declarations) {
            var result = {};
            each(declarations, function (declaration, i) {
                var arg = args[i];
                if (arg != null) {
                    result[declaration.name] = arg;
                }
            });

            return result;
        }

        /**
         * 通过 prompt 对话框进行 Native 调用
         *
         * @inner
         * @param {string} source 要传递的数据字符串
         * @return {string}
         */
        function callPrompt(source) {
            return root.prompt(source);
        }

        /**
         * 通过 location.href 进行 Native 调用
         *
         * @inner
         * @param {string} url 要传递的url字符串
         */
        function callLocation(url) {
            root.location.href = url;
        }

        /**
         * 通过 iframe 进行 Native 调用
         *
         * @inner
         * @param {string} url 要传递的url字符串
         */
        function callIframe(url) {
            var iframe = document.createElement('iframe');
            iframe.src = url;
            document.body.appendChild(iframe);
            document.body.removeChild(iframe);
        }

        /**
         * 映射调用对象描述中的名称
         *
         * @inner
         * @param {Object|Function} mapAPI 调用描述对象名称的映射表或映射函数
         * @param {string} name 调用描述对象中的名称
         * @return {string}
         */
        function mapAPIName(mapAPI, name) {
            if (typeof mapAPI === 'function') {
                return mapAPI(name);
            }

            return mapAPI[name];
        }

        /**
         * 调用描述对象的 invoke 属性为字符串时的快捷映射表
         *
         * @inner
         * @const
         * @type {Object}
         */
        var INVOKE_SHORTCUT = {
            'method': [
                'ArgCheck',
                'CallMethod'
            ],

            'method.json': [
                'ArgCheck',
                'ArgFuncArgDecode:JSON',
                'ArgFuncEncode',
                'ArgEncode:JSON',
                'CallMethod',
                'ReturnDecode:JSON'
            ],

            'prompt.json': [
                'ArgCheck',
                'ArgFuncArgDecode:JSON',
                'ArgFuncEncode',
                'ArgAdd:name',
                'ArgCombine:JSONString',
                'CallPrompt',
                'ReturnDecode:JSON'
            ],


            'prompt.url': [
                'ArgCheck',
                'ArgFuncArgDecode:JSON',
                'ArgFuncEncode',
                'ArgEncode:JSON',
                'ArgCombine:URL',
                'CallPrompt',
                'ReturnDecode:JSON'
            ],


            'location': [
                'ArgCheck',
                'ArgFuncArgDecode:JSON',
                'ArgFuncEncode',
                'ArgEncode:JSON',
                'ArgCombine:URL',
                'CallLocation'
            ],

            'iframe': [
                'ArgCheck',
                'ArgFuncArgDecode:JSON',
                'ArgFuncEncode',
                'ArgEncode:JSON',
                'ArgCombine:URL',
                'CallIframe'
            ],

            'message': [
                'ArgCheck',
                'ArgFuncArgDecode:JSON',
                'ArgFuncEncode',
                'ArgAdd:name',
                'ArgCombine:Object',
                'CallMessage'
            ]
        };

        /**
         * 调用描述对象的 invoke 属性为 Object时，call 字段对应的映射表
         *
         * @inner
         * @const
         * @type {Object}
         */
        var INVOKE_CALL_MAP = {
            method: 'CallMethod',
            prompt: 'CallPrompt',
            location: 'CallLocation',
            iframe: 'CallIframe',
            message: 'CallMessage'
        };

        /**
         * 调用描述对象的 invoke 属性为 Object时，before 字段对应的映射表
         *
         * @inner
         * @const
         * @type {Object}
         */
        var INVOKE_BEFORE_MAP = {
            JSONStringInTurn: [
                'ArgFuncArgDecode:JSON',
                'ArgFuncEncode',
                'ArgEncode:JSON'
            ],

            JSONString: [
                'ArgFuncArgDecode:JSON',
                'ArgFuncEncode',
                'ArgAdd:name',
                'ArgCombine:JSONString'
            ],

            JSONObject: [
                'ArgFuncArgDecode:JSON',
                'ArgFuncEncode',
                'ArgAdd:name',
                'ArgCombine:Object'
            ],

            URL: [
                'ArgFuncArgDecode:JSON',
                'ArgFuncEncode',
                'ArgEncode:JSON',
                'ArgCombine:URL'
            ]
        };

        var BUILTIN_DESCRIPTION_PROPS = {
            name: 1,
            args: 1,
            invoke: 1,
            method: 1,
            scheme: 1,
            authority: 1,
            path: 1,
            handler: 1
        };

        function descriptionPropMerger(target, source) {
            for (var key in source) {
                if (source.hasOwnProperty(key) && !BUILTIN_DESCRIPTION_PROPS[key]) {
                    target[key] = source[key];
                }
            }

            return target;
        }

        /**
         * 对调用描述对象进行标准化处理
         *
         * @inner
         * @param {Object} description 调用描述对象
         * @param {Function?} propMerger 属性合并方法，默认实现为for...in，APIContainer可用于提升性能
         * @return {Object}
         */
        function normalizeDescription(description, propMerger) {
            var args = [];
            if (description.args instanceof Array) {
                for (var i = 0; i < description.args.length; i++) {
                    var arg = description.args[i];

                    args.push({
                        name: arg.name || arg.n,
                        value: arg.value || arg.v
                    });
                }
            }

            propMerger = propMerger || descriptionPropMerger;
            return propMerger(
                {
                    name: description.name,
                    args: args,
                    invoke: normalizeInvoke(description.invoke),
                    method: description.method,
                    scheme: description.scheme || description.schema,
                    authority: description.authority,
                    path: description.path,
                    handler: description.handler
                }, 
                description
            );
        }

        /**
         * 对 description 中的 invoke 属性进行标准化处理
         *
         * @inner
         * @param {Array|Object|string} invoke description的invoke属性
         * @return {Array?}
         */
        function normalizeInvoke(invoke) {
            if (invoke instanceof Array) {
                return invoke;
            }

            switch (typeof invoke) {
                case 'string':
                    return INVOKE_SHORTCUT[invoke];

                case 'object':
                    var result = [];

                    if (invoke.check) {
                        result.push('ArgCheck');
                    }

                    if (invoke.before) {
                        result = result.concat(INVOKE_BEFORE_MAP[invoke.before]);
                    }

                    result.push(INVOKE_CALL_MAP[invoke.call]);

                    if (invoke.after === 'JSON') {
                        result.push('ReturnDecode:JSON');
                    }

                    return result;

            }
        }

        function APIContainer(options) {
            /**
             * processor 创建方法集合
             *
             * @inner
             * @type {Object}
             */
            var processorCreators = {

                /**
                 * 创建参数检查处理函数
                 *
                 * @param {Object} description 调用描述对象
                 * @return {Function}
                 */
                ArgCheck: function (description, option, apiContainer) {
                    return function (args) {
                        checkArgs(args, description.args, apiContainer);
                        return args;
                    };
                },

                /**
                 * 创建解码回调函数参数包装的处理函数
                 *
                 * @param {Object} description 调用描述对象
                 * @param {string} option 处理参数
                 * @return {Function}
                 */
                ArgFuncArgDecode: function (description, option) {
                    return option === 'JSON'
                        ? wrapDecodeFuncArgs
                        : returnRaw;
                },

                /**
                 * 创建回调函数序列化的处理函数
                 *
                 * @return {Function}
                 */
                ArgFuncEncode: function () {
                    return wrapArgFunc;
                },

                /**
                 * 创建参数序列化的处理函数
                 *
                 * @param {Object} description 调用描述对象
                 * @param {string} option 处理参数
                 * @return {Function}
                 */
                ArgEncode: function (description, option) {
                    return option === 'JSON'
                        ? argJSONEncode
                        : returnRaw;
                },

                /**
                 * 创建从调用描述对象中添加额外参数的处理函数
                 *
                 * @param {Object} description 调用描述对象
                 * @param {string} option 处理参数
                 * @return {Function}
                 */
                ArgAdd: function (description, option) {
                    var argLen = description.args.length;

                    description.args.push({
                        name: '_' + option,
                        value: '*'
                    });

                    var value = description[option];
                    return function (args) {
                        args[argLen] = value;
                        return args;
                    };
                },

                /**
                 * 创建参数合并的处理函数
                 *
                 * @param {Object} description 调用描述对象
                 * @param {string} option 处理参数
                 * @return {Function}
                 */
                ArgCombine: function (description, option) {
                    switch (option) {
                        case 'URL':
                            var prefix = description.scheme + '://' + description.authority + description.path;
                            return function (args) {
                                var result = [];

                                each(description.args, function (declaration, i) {
                                    var arg = args[i];
                                    if (arg != null) {
                                        result.push(declaration.name + '=' + encodeURIComponent(arg));
                                    }
                                });

                                var queryStr = result.join('&');

                                return queryStr ? prefix + '?' + queryStr : prefix;
                            };

                        case 'Object':
                            return function (args) {
                                return argCombine(args, description.args);
                            };

                        case 'JSONString':
                            return function (args) {
                                return JSON.stringify(argCombine(args, description.args));
                            };
                    }

                    return returnRaw;
                },

                /**
                 * 创建方法调用的处理函数
                 *
                 * @param {Object} description 调用描述对象
                 * @param {string} option 处理参数
                 * @return {Function}
                 */
                CallMethod: function (description, option) {
                    var methodOwner;
                    var methodName;

                    function findMethod() {
                        if (!methodOwner) {
                            var segs = description.method.split('.');
                            var lastIndex = segs.length - 1;

                            methodName = segs[lastIndex];
                            methodOwner = root;
                            for (var i = 0; i < lastIndex; i++) {
                                methodOwner = methodOwner[segs[i]];
                            }
                        }
                    }

                    return function (args) {
                        findMethod();

                        switch (description.args.length) {
                            case 0:
                                return methodOwner[methodName]();
                            case 1:
                                return methodOwner[methodName](args[0]);
                            case 2:
                                return methodOwner[methodName](args[0], args[1]);
                            case 3:
                                return methodOwner[methodName](args[0], args[1], args[2]);
                        }

                        return methodOwner[methodName].apply(methodOwner, args);
                    };
                },

                /**
                 * 创建 prompt 调用的处理函数
                 *
                 * @return {Function}
                 */
                CallPrompt: function () {
                    return callPrompt;
                },

                /**
                 * 创建 iframe 调用的处理函数
                 *
                 * @return {Function}
                 */
                CallIframe: function () {
                    return callIframe;
                },

                /**
                 * 创建 location 调用的处理函数
                 *
                 * @return {Function}
                 */
                CallLocation: function () {
                    return callLocation;
                },

                /**
                 * 创建 postMessage 调用的处理函数
                 *
                 * @param {Object} description 调用描述对象
                 * @return {Function}
                 */
                CallMessage: function (description) {
                    return function (args) {
                        root.webkit.messageHandlers[description.handler].postMessage(args);
                    };
                },

                /**
                 * 创建对返回值进行解码的处理函数
                 *
                 * @param {Object} description 调用描述对象
                 * @param {string} option 处理参数
                 * @return {Function}
                 */
                ReturnDecode: function (description, option) {
                    return option === 'JSON'
                        ? returnJSONDecode
                        : returnRaw;
                }
            };

            var apiContainer = {
                options: {
                    errorTitle: 'jsNative',
                    namingConflict: 'error'
                },

                apis: [],
                apisLen: 0,
                apiIndex: {},

                /**
                 * 配置参数，设置的参数将被合并到现有参数中
                 *
                 * @param {Object} options 参数对象
                 * @param {string=} options.errorTitle 显示报错信息的标题
                 * @param {string=} options.namingConflict 名字冲突时的处理策略
                 * @return {APIContainer}
                 */
                config: function (options) {
                    options = options || {};
                    // 再多就不能这么干了
                    this.options.errorTitle = options.errorTitle || this.options.errorTitle;
                    this.options.namingConflict = options.namingConflict || this.options.namingConflict;

                    return this;
                },

                /**
                 * 添加调用API
                 *
                 * @param {Object|Array} description 调用描述对象
                 * @return {APIContainer}
                 */
                add: function (description) {
                    if (description instanceof Array) {
                        for (var i = 0; i < description.length; i++) {
                            this.add(description[i]);
                        }
                    }
                    else if (typeof description === 'object') {
                        var name = description.name;

                        if (this.apiIndex[name] != null) {
                            switch (this.options.namingConflict) {
                                /* jshint ignore:start */
                                case 'override':
                                    this.apis[this.apiIndex[name]] = normalizeDescription(
                                        description, 
                                        this.descriptionPropMerger
                                    );

                                case 'ignore':
                                    break;
                                /* jshint ignore:end */

                                case 'error':
                                default:
                                    throw new Error('[' + this.options.errorTitle + '] API exists: ' + name);
                            }
                        }
                        else {
                            var realDesc = normalizeDescription(description, this.descriptionPropMerger);

                            this.apiIndex[name] = this.apisLen;
                            this.apis[this.apisLen++] = realDesc;
                        }
                    }

                    return this;
                },

                /**
                 * 从一次 Native 的调用结果中添加调用API
                 *
                 * @param {Object} description 调用描述对象
                 * @return {APIContainer}
                 */
                fromNative: function (description) {
                    return this.add(invokeDescription(normalizeDescription(description, this.descriptionPropMerger)));
                },


                /**
                 * 通过描述对象的 name 属性进行调用
                 *
                 * @param {string} name 调用描述对象名
                 * @param {Array=} args 调用参数
                 * @return {*}
                 */
                invoke: function (name, args) {
                    return invokeDescription(this.apis[this.apiIndex[name]], args);
                },

                /**
                 * 生成一个对象，其上的方法是 API 容器对象中调用描述对象编译成的，可被直接调用的函数
                 *
                 * @param {Object|Function} mapAPI 调用描述对象名称的映射表或映射函数
                 * @return {Object}
                 */
                map: function (mapAPI) {
                    mapAPI = mapAPI || function (name) {
                        return name;
                    };

                    var apiObject = {};


                    for (var i = 0; i < this.apis.length; i++) {
                        var api = this.apis[i];
                        var apiName = mapAPIName(mapAPI, api.name);

                        if (apiName && api.invoke) {
                            if (apiName.indexOf('.') > 0) {
                                var apiNameSegs = apiName.split('.');
                                var j = 0;
                                var ns = apiObject;

                                for (; j < apiNameSegs.length - 1; j++) {
                                    var seg = apiNameSegs[j];
                                    
                                    ns[seg] = ns[seg] || {};
                                    ns = ns[seg];

                                    // 无聊留个精简写法
                                    // ns = ns[apiNameSegs[j]] = ns[apiNameSegs[j]] || {};
                                }

                                ns[apiNameSegs[j]] = buildAPIMethod(api);
                            }
                            else {
                                apiObject[apiName] = buildAPIMethod(api);
                            }
                        }
                    }

                    return apiObject;
                },

                /**
                 * 通过调用描述对象进行调用
                 *
                 * @param {Object} description 调用描述对象
                 * @param {Array} args 调用参数
                 * @return {*}
                 */
                invokeAPI: function (description, args) {
                    return invokeDescription(normalizeDescription(description, this.descriptionPropMerger), args);
                },

                /**
                 * 开发者补充processorsCreators的自定义集(TIPS:不能刷掉内置的processorCreators)
                 *
                 * @param {string} name 注册的processorCreator名称
                 * @param {Function} 需要注册的processorCreator，此函数返回值需要是一个函数
                 * @return {APIContainer}
                 */
                addProcessorCreator: function (name, processorCreator) {
                    if (processorCreators[name]) {
                        throw new Error('[' + this.options.errorTitle + '] processorCreators exists: ' + name);
                    }
                    processorCreators[name] = processorCreator;
                    return this;
                },

                /**
                 * 设置 description 额外的属性列表
                 * 若设置了description 额外的属性列表，不在列表中的属性将被忽略
                 * 该接口应仅用于性能优化，不应改变默认行为
                 *
                 * @param {Array.<string>} props description额外的属性列表
                 */
                setExternalDescriptionProps: function (props) {
                    var code = '';

                    for (var i = 0; i < props.length; i++) {
                        var prop = props[i];
                        code += 'target["' + prop + '"] = source["' + prop + '"];';
                    }

                    this.descriptionPropMerger = new Function('target', 'source', code + 'return target;');
                }
            };

            apiContainer.config(options);
            return apiContainer;

            /**
             * 生成调用过程处理函数的列表
             *
             * @inner
             * @param {Object} description 调用描述对象
             * @return {Function[]}
             */
            function getProcessors(description) {
                var processors = [];

                if (!description.invoke) {
                    throw new Error('[' + apiContainer.options.errorTitle + '] invoke undefined: ' + description.name);
                }

                each(description.invoke, function (processName) {
                    var dotIndex = processName.indexOf(':');
                    var option;

                    if (dotIndex > 0) {
                        option = processName.slice(dotIndex + 1);
                        processName = processName.slice(0, dotIndex);
                    }

                    var processor = processorCreators[processName](description, option, apiContainer);
                    if (typeof processor === 'function') {
                        processors.push(processor);
                    }
                });

                return processors;
            }

            /**
             * 通过调用描述对象进行调用
             *
             * @inner
             * @param {Object} description 调用描述对象
             * @param {Array} args 调用参数
             * @return {*} 处理完成结果
             */
            function invokeDescription(description, args) {
                if (description) {
                    args = args || [];

                    each(getProcessors(description), function (processor) {
                        args = processor(args);
                    });

                    return args;
                }
            }

            /**
             * 把调用描述对象编译成可被直接调用的函数
             *
             * @inner
             * @param {Object} description 调用描述对象
             * @return {Function}
             */
            function buildAPIMethod(description) {
                var processors = getProcessors(description);

                function process(args) {
                    each(processors, function (processor) {
                        args = processor(args);
                    });

                    return args;
                }

                return function () {
                    return process(Array.prototype.slice.call(arguments, 0, description.args.length));
                };
            }
        }

        // export object ===========

        /**
         * 默认的 API Container 实例
         *
         * @type {APIContainer}
         */
        var jsNative = new APIContainer();

        /**
         * 版本号
         *
         * @type {string}
         */
        jsNative.version = '1.2.4';

        /**
         * 创建 API Container
         *
         * @param {Object=} options 创建的参数
         * @return {APIContainer}
         */
        jsNative.createContainer = function (options) {
            return new APIContainer(options);
        };

        // export ==============
        root.jsNative = jsNative;

        // for Commonjs
        {
            exports.jsNative = jsNative;
        }

    })(
        typeof window !== 'undefined'
            ? window
            : typeof commonjsGlobal !== 'undefined'
                ? commonjsGlobal
                : commonjsGlobal
    );
    });
    var jsNative_1 = jsNative.jsNative;

    /**
     * @file 创建 API 容器
     * @author zhoudan03
     * @date 2019/6/2
     */

    var apiContainer = jsNative_1.createContainer().config({
        errorTitle: 'boxx',
        namingConflict: 'override'
    });

    /**
     * @file NA 上获取 description 的接口
     * @author zhoudan03
     * @date 2019/5/27
     */


    /**
     * getAPIs 接口描述
     * @params {number=0} fragmentIndex 索引值
     * @returns {Object} res 返回值
     * @returns {String} res.totalSlices 总片段数
     * @returns {Object} res.currentIndex 当前索引
     * @returns {Object} res.descriptions 描述表数组
     */
    var naGetAPIDesc = {
        invoke: [
            'ArgFuncArgDecode:JSON',
            'ArgFuncEncode',
            'CallMethod',
            'ReturnDecode:JSON'
        ],
        name: 'na.getAPIs',
        method: '_na.getAPIs',
        args: [{name: 'fragmentIndex', value: 'number='}]
    };

    /**
     * @file invoke简称
     * @description 以下每个 invoke 都对应着一个函数处理栈，会依次对用户参数进行处理、然后拼接并用于对客户端的通信。所有的函数的实现逻辑均位于 processor.js 或 js-native 文件中。
     *
     * @author zhoudan03
     * @date 2019/5/28
     */


    /**
     * ArgFuncArgDecode:JSON     对调用参数中的所有回调函数，进行参数解码（反序列化）包装（因为回调是端上触发，传递参数通常是序列化后的 JSON 对象）
     * ArgFuncEncode:  对调用参数中的所有回调函数，进行序列化包装 。决定了是否把 func 拼接进去
     * ArgsEncodeToJSONExceptString  对于每个需要拼接在协议中的参数(除了string以外的类型)，进行JSON序列化
     * ArgCombine:URL  将参数拼接为协议
     * ArgCombine:JSONString 将参数拼接为一个 JSON 对象
     *  eg. [] ====ArgcCombine==> {} ====JSNOString====> "{}"
     *  eg. ['value1', 'value2'] ===> {key1:value1, key2:value2}  ===> "{"key1":"value1","key2":"value2"}"
     *
     */

    // ArgFuncArgDecode wrapDecodeFuncArg  fixme 去掉 jsnative 回调函数的反序列化包装 。因为有二级回调函数，返回值是字符串。不能被 parse

    var INVOKE_SHORTCUT = {
        // bdboxURL 特指参数合并为 JSONString 的。参数可能通过 params 传递，也可能通过 options 传递
        'iframe.bdboxURL': [
            'ArgCheckWithCallback', // 校验API的参数 (包括 success 和 fail)
            'RegisterCallbacks', // 注册一二级回调函数（用于执行 success 和 fail）
            'ArgFuncArgDecode:JSON', // 对API参数中的回调函数的参数值进行 JSON 解码
            'ArgFuncEncode', // 对API参数中的函数进行序列化包装（转为随机字符串并挂在全局）
            'ArgCombineWithCallback:Object', // 将参数数组合并为用于params值的对象。透传一级回调
            'ArgJSONString', // 对 params stringify；透传一级回调
            'ArgCombineWithCallback:bdboxURL', // 拼协议（在协议中，注入一级回调）
            'CheckURL', // 检查 URL 长度及特殊关键字
            'CallIframe' // 使用 iframe 的方式发协议
        ],

        'iframe.url': [
            'ArgCheckWithCallback', // 校验API的参数 (包括 success 和 fail)
            'RegisterCallbacks', // 注册一二级回调函数（用于执行 success 和 fail）
            'ArgFuncArgDecode:JSON', // 对API参数中的回调函数的参数值进行 JSON 解码
            'ArgFuncEncode', // 对API参数中的函数进行序列化包装（转为随机字符串并挂在全局）
            'ArgsEncodeToJSONExceptString', // 对于每个需要拼接在协议中的参数(除了string以外的类型)，进行转码。
            'ArgCombineWithCallback:URL', // 拼协议（在协议中，注入一级回调）
            'CheckURL', // 检查 URL 长度及特殊关键字
            'CallIframe' // 使用 iframe 的方式发协议
        ],

        'method.args-json+callback': [
            'ArgCheckWithCallback', // 校验API的参数 (包括 success 和 fail)
            'RegisterCallbacks', // 注册一二级回调函数
            'ArgCombineWithCallback:JSONString', // 8.2 之前的接口要求，JSON 类型必须通过JSON.stringify 后传入。 返回值是数组
            'CallMethodByUserArgs:callback' // 调用安卓的 JS bridge
        ],

        'method.args-json': [
            'ArgCheckWithCallback', // 校验API的参数 (包括 success 和 fail)
            'RegisterCallbacks', // 没有 callback，但是也把 success 和 fail 包进去 callbacks 方便执行
            'ArgCombineWithCallback:JSONString', // 8.2 之前的接口要求，JSON 类型必须通过JSON.stringify 后传入
            'CallMethodByUserArgs:noCallback' // 调用安卓的 JS bridge. 不接受 callback 作为参数，响应通过函数直接返回。
        ],

        'method.bdboxURL': [
            'ArgCheckWithCallback', // 校验API的参数 (包括 success 和 fail)
            'RegisterCallbacks', // 注册一二级回调函数
            'ArgFuncArgDecode:JSON', // 对API参数中的回调函数的参数值进行 JSON 解码
            'ArgFuncEncode', // 对API参数中的函数进行序列化包装（转为随机字符串并挂在全局）
            'ArgCombineWithCallback:Object', // 将参数数组合并为用于params值的对象。输入数组，输出对象（包括一级回调）
            'ArgJSONString', // 对 params stringify；透传一级回调
            'ArgCombineWithCallback:bdboxURL', // 拼协议（在协议中，注入一级回调）
            'CheckURL', // 检查 URL 长度及特殊关键字
            'CallMethodByUserArgs:callback' // 接受的参数为数组
        ],

        'method.url': [
            'ArgCheckWithCallback', // 校验API的参数 (包括 success 和 fail)
            'RegisterCallbacks', // 注册一二级回调函数（用于执行 success 和 fail）
            'ArgFuncArgDecode:JSON', // 对API参数中的回调函数的参数值进行 JSON 解码
            'ArgFuncEncode', // 对API参数中的函数进行序列化包装（转为随机字符串并挂在全局）
            'ArgsEncodeToJSONExceptString', // 对于每个需要拼接在协议中的参数(除了string以外的类型)，进行转码。
            'ArgCombineWithCallback:URL', // 拼协议（在协议中，注入一级回调）
            'CheckURL', // 检查 URL 长度及特殊关键字
            'CallMethodByUserArgs:callback' // 接受的参数为数组
        ],

        'method.openSwan': [
            'ArgCheckWithCallback', // 校验API的参数 (包括 success 和 fail)
            'RegisterCallbacks', // 注册一二级回调函数（用于执行 success 和 fail）
            'ArgsEncodeToJSONExceptString', // 对于每个需要拼接在协议中的参数(除了string以外的类型)，进行转码。
            'SwanSchemeCombine', // 小程序特有的拼接方式
            'CheckURL', // 检查 URL 长度及特殊关键字
            'CallMethodByUserArgs:callback' // 接受的参数为数组
        ],

        'iframe.openSwan': [
            'ArgCheckWithCallback', // 校验API的参数 (包括 success 和 fail)
            'RegisterCallbacks', // 注册一二级回调函数（用于执行 success 和 fail）
            'ArgsEncodeToJSONExceptString', // 对于每个需要拼接在协议中的参数(除了string以外的类型)，进行转码。
            'SwanSchemeCombine', // 小程序特有的拼接方式
            'CheckURL', // 检查 URL 长度及特殊关键字
            'CallIframe' // 使用 iframe 的方式发协议
        ]
    };

    /**
     * @file 合并生成一份使用的 description 数组
     * @author zhoudan03
     * @date 2019/5/27
     */

    /**
     * 根据公参信息里的 “默认字段” 给每个description 增加默认值
     *
     * @param {Array} nativeDescriptions  na描述表
     * @param {Object} defaultsFields
     * @return {Array} 描述表
     */
    function addDefaultFields(nativeDescriptions, defaultsFields) {

        // fixme 安卓在开关关闭时，仍然返回有一个元素的数组，导致判断失效。临时 hard code，11.3.5 @邵颖慧 修复后就删掉。
        if (nativeDescriptions.length === 1) {
            return [];
        }

        return nativeDescriptions.map(function (desc) {
            for (var key in defaultsFields) {
                if (defaultsFields.hasOwnProperty(key)) {
                    desc[key] = desc[key] || defaultsFields[key];
                }
            }

            return desc;
        });
    }

    /**
     * 删除描述表
     * 只有 name 字段时，认为是无效的描述表，需要删除，ps: 从后往前遍历删除不会影响下标
     * @param {Array} descriptions 描述表
     * @return {void}
     */
    function deleteDescriptions(descriptions) {
        for (var i = descriptions.length - 1; i >= 0; i--) {
            var keys = Object.keys(descriptions[i]);
            if (keys.length === 1 && keys[0] === 'name') {
                descriptions.splice(i, 1);
            }
        }
    }

    /**
     * 从客户端获取 API
     *
     * @param {Object} apiContainer 由jsNative创建的 APIContainer 实例
     * @return {Array} 返回 NA 的描述表数组
     */
    function getNADescriptions(apiContainer) {
        if (typeof _na === 'undefined' || _na === null || !_na.getAPIs) {
            debug('端描述表开关已关闭');
            return [];
        }
        debug('端描述表开关已打开， 端上会注入描述表， 但如果此时同时引入了兜底描述表， 则会被兜底描述表覆盖，目前矩阵（lite、tomas、青春版）产品属于该种情况');
        var nativeDescriptions = [];
        var resultDescriptions = [];
        var amendDescriptions = [];
        var nativeSlices;
        var defaultsFields;
        var i = 0;

        do {
            var ref = apiContainer.invokeAPI(naGetAPIDesc, [i]);
            var totalSlices = ref.totalSlices;
            var descriptions = ref.descriptions;
            var defaults = ref.defaults;
            defaultsFields = defaults;
            nativeSlices = totalSlices;
            i++;
            nativeDescriptions = nativeDescriptions.concat(descriptions);
        } while (i < nativeSlices);

        nativeDescriptions = addDefaultFields(nativeDescriptions, defaultsFields);

        // 获取修复描述表，做merge
        if (_na && _na.getAmendAPIs) {
            var amendDescJsonStrOrArray = _na.getAmendAPIs();
            if (amendDescJsonStrOrArray && typeof amendDescJsonStrOrArray === 'string') {
                try {
                    amendDescriptions = JSON.parse(amendDescJsonStrOrArray);

                    /* istanbul ignore next */
                    if ("production" === 'development' || "production" === 'development-mock') {
                        console.log('----------------修复描述表信息-------------------');
                        console.log('amend descriptions:: ', amendDescriptions);
                        console.log('-----------------------------------');
                    }
                }
                catch (e) {
                    /* istanbul ignore next */
                    console.error(e);
                }
            }
            else if (Array.isArray(amendDescJsonStrOrArray)) {
                amendDescriptions = amendDescJsonStrOrArray;
            }
            if (amendDescriptions && amendDescriptions.length > 0) {
                var amendDesc = {};
                amendDescriptions.forEach(function (item) {
                    amendDesc[item.name] = item;
                });
                // 存在云控的name，需要删除端下发的描述表
                for (var i$1 = nativeDescriptions.length - 1; i$1 >= 0; i$1--) {
                    if (amendDesc[nativeDescriptions[i$1].name]) {
                        nativeDescriptions.splice(i$1, 1);
                    }
                }
            }
        }

        resultDescriptions = nativeDescriptions.concat( amendDescriptions);

        // 只有name字段，删除空的描述表
        deleteDescriptions(resultDescriptions);

        return resultDescriptions;
    }

    /**
     * 获取某个描述表支持的版本号
     * @param {Object} env 环境值
     * @return {string} 版本号
     */
    function getVersionByEnv(env, options) {
        var appType = options.appType;
        var adaptAppType = options.adaptAppType;
        // 根据当前 UA 类型 boxType获取兜底描述表 env 中的配置版本
        var version = getVersionByBoxtypeInEnv(env, appType);
        // 优先使用兜底描述表中配置的信息
        // 1、若配置了支持的版本，例如：'2.0'，优先使用该配置信息
        // 2、若配置了false，表示需要裁剪掉该端能力
        // 3、若没有配置相关信息undefined，则使用适配主线以后的版本
        if (version || version === false) {
            return {
                isAdapted: false,
                startedVersion: version
            };
        }
        // 根据适配后的 UA 类型 adaptBoxType获取兜底描述表 env 中的适配版本
        var adaptVersion = getVersionByBoxtypeInEnv(env, adaptAppType);
        // 其次使用适配主线的版本
        if (adaptVersion) {
            return {
                isAdapted: true,
                startedVersion: adaptVersion
            };
        }
        // 没有对齐主线的矩阵会走到该逻辑
        return {
            isAdapted: false,
            startedVersion: INFINITYVERSION
        };
    }

    /**
     * 保留 没有标注版本号的，以及 标注的起始版本号 小于当前手百版本号的
     * @param {Array} descriptions 描述表
     * @return {Array} 过滤后的描述表
     */
    function filterVersion(descriptions) {
        // 为了避免全局变量被修改，这里对象的属性重命名，与全局变量名不同
        var options = {
            appType: boxType,
            adaptAppType: adaptBoxType,
            realAppVersion: realBoxVersion,
            appVersion: boxVersion
        };
        return descriptions.filter(function (description) {
            return isCapacityExisting(description, options);
        });
    }

    /**
     * 获取前端预置描述表（根据版本、平台等不同，输出的描述表不同）
     *
     * @return {Array} 描述表
     */
    function getDefaultDescription(defaultDecs) {
        var descriptions = isIOS ? defaultDecs.ios : defaultDecs.android;

        return descriptions && descriptions.length > 0 ? filterVersion(descriptions) : [];
    }

    /**
     * 获取前端用于兼容的低版本预置描述表
     *
     * @return {Array} 描述表
     */
    function getCompatibilityDescription(defaultDecs) {
        var descriptions = isIOS ? defaultDecs.iosCompatibility : defaultDecs.androidCompatibility;

        return filterVersion(descriptions || []);
    }
    /**
     * 根据矩阵产品类型获取env中的版本配置
     */
    function getVersionByBoxtypeInEnv(env, boxType) {
        return env && env[boxType] && env[boxType][boxBrowserType];
    }
    /**
     * 该端能力是存在的（根据和当前手百版本号比对而得）
     * @param {Object} description 描述表
     * @return {boolean}  true 存在，false 不存在
     */
    function isCapacityExisting(description, options) {
        if ( options === void 0 ) options = {
        appType: boxType,
        adaptAppType: adaptBoxType,
        realAppVersion: realBoxVersion,
        appVersion: boxVersion
    };

        // 变量命名不要与全局变量同名，否则全局变量会被修改
        var realAppVersion = options.realAppVersion;
        var appVersion = options.appVersion;
        var ref = getVersionByEnv(description.env, options);
        var isAdapted = ref.isAdapted;
        var startedVersion = ref.startedVersion;
        // 若兜底描述表中配置了false，则表示不支持
        if (!startedVersion) {
            return false;
        }
        // 若兜底描述表中存在配置信息，使用真实版本对比，不存在使用适配版本
        var version = isAdapted
            ? appVersion
            : realAppVersion;
        return version
            ? versionCompare(version, startedVersion) >= 0
            : false;
    }


    /**
     * 对描述表的字段标准化处理：invoke 从缩写 => processor 数组
     *
     * @param {Object} description 描述表
     * @return {Object} 标准化处理后的描述表
     */
    function normalizeDescription(description) {
        description.invoke = INVOKE_SHORTCUT[description.invoke] || description.invoke;
        description.path = description.path || '';
        return description;
    }

    function getLocalDescriptions(defaultDecs) {
        var defaultDescriptions = getDefaultDescription(defaultDecs);

        // 兼容性的描述表，仅存在于前端。不参与和 NA 的 merge 策略，merge 完后直接拼接
        var compatibilityDescriptions = getCompatibilityDescription(defaultDecs);

        var mergedDefaultDescriptions = defaultDescriptions.concat(compatibilityDescriptions);

        mergedDefaultDescriptions.forEach(normalizeDescription);

        return mergedDefaultDescriptions;
    }

    /**
     * 获取端下发的描述表
     *
     * @param {Object} apiContainer 由jsNative创建的 APIContainer 实例
     * @return {Array} 最终描述表数组
     */
    function getDescriptions(apiContainer) {
        var nativeDescriptions = getNADescriptions(apiContainer);
        nativeDescriptions.forEach(normalizeDescription);
        return nativeDescriptions;
    }

    /**
     * @file  回调函数处理逻辑
     * @author zhoudan03 tianty05
     * @date 2019/6/12
     */

    /**
     * 安卓没有返回值，调用后直接默认成功。修复这种历史遗留 bug 不会造成兼容性问题，应该修复。todo 推动 客户端 RD 排期修复
     * @return {{status: number, message: string}}
     */
    function returnDefaultSuccess() {
        return {
            status: 0,
            message: 'success: NA 无返回信息，默认成功'
        };
    }

    // 不规则的端能力返回值
    /* istanbul ignore next */
    var irregularResponseHandlers = {
        'feed.updateFavorInfo': returnDefaultSuccess,
        'hybrid.reliabilityLog': returnDefaultSuccess,
        'feed.showDislike': returnDefaultSuccess,
        'easyBrowser.open': returnDefaultSuccess,

        'account.login': function (res) {
            if (res.data) {
                return {
                    status: res.data.status === '1' ? 0 : 1,
                    message: res.data.status === '1' ? 'login success' : 'login fail'
                };
            }

            return res;
        },


        // doc: http://cp01-invoker-3-mgt161657.epc.baidu.com:8007/invokers?id=5476cb1c319bf8d34ce2052b
        'device.getCUID': function (res) {
            // 处理ios手百lite和看多多下的情况
            if (res && res.result === 0) {
                return {
                    status: 0,
                    message: 'success',
                    data: {
                        // eslint-disable-next-line camelcase
                        unique_id: res.unique_id
                    }
                };
            }
            // 处理安卓下低版本返回 {error: 0, result: 'xxxx'}
            if (res && res.error === 0) {
                return {
                    status: 0,
                    message: 'success',
                    data: {
                        // eslint-disable-next-line camelcase
                        unique_id: res.result
                    }
                };
            }

            // 安卓的 getCUID 返回值是字符串。iOS 返回是对象。前端兼容对齐
            if (isAndroid && (versionCompare(boxVersion, '7.4') >= 0 || !isMainBox)) {
                var hasCUID = res && res.length > 0;
                return {
                    status: hasCUID ? 0 : 1,
                    message: hasCUID ? 'success' : 'fail',
                    data: hasCUID
                        ? {
                            // eslint-disable-next-line camelcase
                            unique_id: res
                        }
                        : {}
                };
            }

            // 低版本的逻辑暂无法验证，取自于原 JSSDK，可与业务方确认
            if (
                (isAndroid && versionCompare(boxVersion, '7.4') < 0)
                || (isIOS && versionCompare(boxVersion, '8.4') < 0)
            ) {
                var match = isAndroid
                    ? document.cookie.match(/BAIDUCUID=(.+?);/)
                    : UA.match(/baiduboxapp\/.*\/(\w+)\/\d/);
                var cuid = match ? match[1] : '';
                return {
                    status: cuid ? 0 : 1,
                    message: cuid ? 'success' : 'fail',
                    data: cuid
                        ? {
                            // eslint-disable-next-line camelcase
                            unique_id: cuid
                        }
                        : {}
                };
            }

            return res;
        },

        'device.getDeviceInfo': function (res) {
            // 此端能力的返回值很特殊，客户端难以给出枚举值。而且由于业务方只关注是 wifi 还是非 wifi，所以细节不再深究
            //
            // 安卓的 1_0 和 iOS 的 Wifi 代表 wifi
            // iOS ：不同的单词代表不同的网络。（4g： WWAN）
            // Android：不同的数字前缀代表不同的网络:
            //    （ WIFI 1， 3GNET 21， 3GWAP 22， CMNET 31， UNINET 32， CTNET 33， CMWAP 41， UNIWAP 42， CTWAP 43 ）
            if (res.data && res.data.netInfo && res.data.netInfo.network
                && (res.data.netInfo.network === '1_0' || res.data.netInfo.network === 'Wifi')) {
                res.data.networkType = 'wifi';
            }
            else {
                res.data.networkType = 'unknown';
            }

            return res;
        },

        // 9.2+ 版本参数被多封装了一层（被封装在了res.data.params中），前端在此兼容。
        'feed.getSessionClickID': function (res) {
            return {
                status: +res.status,
                message: res.message || '',
                data: (res.data && res.data.params) || res.params || {}
            };
        },

        // 安卓多了无用的 data 值（status和 message）。前端兼容对齐
        'easyBrowser.performanceFlowLog': function (res) {
            if (isAndroid) {
                return {
                    status: +res.status,
                    message: res.message || ''
                };
            }
            return res;
        },

        // request iOS 做了多余的转码，导致双端返回值不一致，但是涉及到的线上业务方过多，端上无法修复。前端兼容对齐
        'easyBrowser.request': function (res) {
            var data;
            if (res && res.data && res.errno === '1') {
                data = isIOS ? JSON.parse(decodeURIComponent(res.data)) : JSON.parse(res.data);
            }
            else {
                data = res.data;
            }

            return {
                status: res.errno === '1' ? 0 : (res.errno === '0' ? 1 : parseInt(res.errno, 10)),
                message: res.message || (res.errno === '1' ? 'success' : 'fail'),
                data: data || {}
            };
        },
        'easyBrowser.webStorage': function (res) {
            // 解决返回值为空时格式不一致的问题
            if (isIOS && res.result === 0) {
                return {
                    status: 0,
                    message: res.message || res.errmsg,
                    data: res.data
                };
            }
            return res;
        },
        // iOS 的数据多了一层 coords
        'device.getCurrentLocation': function (res) {
            if (isIOS) {
                // todo 原逻辑 401
                return {
                    status: res.result || res.status,
                    message: res.message || (res.result === 0 ? 'success' : 'fail'),
                    data: res.coords || res.data
                };
            }
            else if (isAndroid) {
                var status = res.st;

                // 安卓的 st 字段用来表示状态码，没必要暴露
                var data = res;
                delete data.st;

                return {
                    status: status,
                    message: res.message || (status === 0 ? 'success' : 'fail'),
                    data: data
                };
            }
            return res;
        },
        // result下为最终信息，不能被过滤掉
        'feed.isWebPSupported': function (res) {
            if (isAndroid) {
                res.data = res.result;
            }
            return res;
        }
    };

    /**
     * 存储 res 中除了状态码和状态信息以外的其他属性，用作 data 的默认值。
     * @param res
     */
    function getDefaultData(res) {
        var defaultData = {};

        for (var key in res) {
            if (res.hasOwnProperty(key)
                && key !== 'errno' && key !== 'errmsg'
                && key !== 'status' && key !== 'message'
                && key !== 'result') {
                defaultData[key] = res[key];
            }
        }
        return defaultData;
    }

    /**
     * 格式化处理 response。用于兼容不同时期的协议之间响应信息的格式存在的差异。
     *
     * 返回信息标准
     * status: {number} 数字类型，0代表成功，非0代表失败
     * message: {string} 返回信息，NA 有则透传 NA，否则前端返回 success / fail
     * data: {*} 任意类型
     *
     * @param {*} response 响应信息
     * @param {string} handler 响应信息的处理标识，是 description 中的 resHandler 字段
     * @return {{status: number, message: (string), data: *}}
     * status 为0时，表示成功。其他值为失败
     */
    function normalizeResponse(response, handler) {

        // response 为客户端返回。返回的方式有多种，可能是直接返回相应数据(number / object / array / string)
        // 也有可能是JSON string （任何类型对应的JSON string）
        var res;
        try {
            res = typeof response === 'string' ? JSON.parse(response) : response;
        }
        catch (e) {
            res = response;
        }

        if (Object.keys(irregularResponseHandlers).indexOf(handler) > -1) {
            // 不直接 return 的原因是，有双端对齐的端能力，某端符合以下规则，需要再处理
            res = irregularResponseHandlers[handler](res);
        }

        // eslint-disable-next-line default-case
        switch (typeof res) {
            case 'undefined':
                return {
                    status: 1,
                    message: 'fail: na 返回值为 undefined'
                };
            case 'boolean':
                return {
                    status: res ? 0 : 1,
                    message: res ? 'success' : 'fail'
                };

            case 'number':
                return {
                    status: res,
                    message: +res === 0 ? 'success' : 'fail'
                };

            case 'string':
                return {
                    status: 0,
                    message: 'success',
                    data: res
                };

            case 'object': {
                if (res === null) {
                    return {
                        status: 1,
                        message: 'fail: NA 返回信息为 null'
                    };
                }

                var defaultData = getDefaultData(res);

                // fixme: 提取res.data作为响应数据的 data可能会有风险：老旧端能力无规范，data 只是众多响应值属性中的其中一个属性
                if (res.errno != null) {
                    // errno 为 1 代表成功，为 0 代表失败。如果还有其他值的话，则直接赋给 status。
                    var errno = parseInt(res.errno, 10);
                    var status = errno === 1
                        ? 0
                        : errno === 0 ? 1 : errno;

                    return {
                        status: status,
                        message: res.errmsg || errno === 1 ? 'success' : 'fail',
                        data: res.data || defaultData
                    };
                }
                else if (res.status != null) {
                    return {
                        status: +res.status,
                        message: res.message || (+res.status === 0 ? 'success' : 'fail'),
                        data: res.data || defaultData
                    };
                }
                else if (res.result != null) {
                    return {
                        status: res.result,
                        message: res.result === 0 ? 'success' : 'fail',
                        data: res.data || defaultData
                    };
                }
                // 直接返回的无状态码的数据
                else {
                    return {
                        status: 0,
                        message: 'success',
                        data: res
                    };
                }
            }
        }

        return res;
    }

    /**
     * @file  回调函数处理逻辑
     * @author zhoudan03
     * @date 2019/6/5
     * @description
     一级回调相当于端能力调用是否成功，二级回调相当于异步处理一些事情 然后返回结果。

     对于一个端能力而言，如果只有一级回调，则在一级回调返回后 触发开发者的 success 或者 fail。如果同时有 一级回调 和二级回调，则会在一级回调调用成功后，等待二级回调执行，二级成功再触发 开发者的 success。

     对于有二级回调的情况，一级回调只是告知端能力通信是否成功，对开发者是隐藏的，不用告诉开发者。

     在手百端能力中，一级回调通常叫 callback 或者 func，或者拆分为 successcallback errorcallback  failcallback
     二级回调通常没有规范，由当时的文档或者口头约定。

     【举例】
     二级回调叫 jscallback
     baiduboxapp://v5/datachannel/register?action=com.baidu.channel.tts.statuschange&page=dataChannelDemoWeb&jscallback=__jsna_1&callback=__jsna_2

     二级回调叫 cb
     baiduboxapp://v41/device/startAccelerometer?params={"interval":"0.2","cb":"cb"}&callback=_bdbox_js_cb&upgrade=0

     二级回调叫 event_callback
     baiduboxapp://v4/comment/showbox?params={"type":1,"topic_id":"1072000001838121","placeholder":"placeholder","logid":"feed","source":"feed","page":"feed","event_callback":"cbname"}&callback=_bdbox_js_617

     小程序里二级回调 cb 为对象 的例子：
     baiduboxapp://swanAPI/backgroundAudio/open?params={"src":"http://ws.xxxq.com/M500001VfvsJ21xFqb.mp3?","slaveId":"4","title":"石家庄人民共和国","epname":"此时此刻","singer":"许巍","coverImgUrl":"http://y.xxxphoto_new/T002R300x300M000003rsKF44GyaSk.jpg?max_age=2592000","cb":{"onCanplay":"_bkAudio_onCanplay","onPlay":"_bkAudio_onPlay","onPause":"_bkAudio_onPause","onStop":"_bkAudio_onStop","onEnded":"_bkAudio_onEnded","onTimeUpdate":"_bkAudio_onTimeUpdate","onPrev":"_bkAudio_onPrev","onNext":"_bkAudio_onNext","onError":"_bkAudio_onError","onWaiting":"_bkAudio_onWaiting"}}&callback=_bdbox_js_66&upgrade=0


     目前有三类二级回调
     第一类：普通表示端能力调起成功的异步处理数据。即用即毁。
     第二类：事件监听函数，如 event.on
     事件监听函数需要长期保存。
     对于开发者传递的，分为具名函数和匿名函数。匿名可以用自增函数，具名需要保存开发者的函数名，以便 off 时指定
     第三类：点击事件，如 toast、dialog 等有按钮的，由用户触发

     * 端能力的返回值有多种返回方式：
     * 1. 通过一级回调，触发用户回调
     * 2. 通过二级回调，触发用户回调
     * 3. 通过 jsInterface 函数返回，触发用户回调
     *
     *
     * 对应于上述的多种返回方式，那么触发用户回调的时机应该是：
     * 1. 如果只有一级回调，则在一级回调返回后，触发开发者的 success 或者 fail
     * 2. 如果同时有 一级回调 和二级回调，则会在一级回调调用成功后，等待二级回调执行，二级成功再触发 开发者的 success；如果一级回调调用失败则直接 fail，无需等待二级回调
     * 3. 通过 jsInterface 函数返回后，使用 nextTick 延迟触发用户回调（success/fail）
     */

    /**
     * 用于回调函数包装命名的自增id
     *
     * @inner
     * @type {number}
     */
    var funcId = 1;

    /**
     * 用于回调函数包装命名的前缀
     *
     * @inner
     * @const
     * @type {string}
     */
    var FUNC_PREFIX = '__boxx_';

    /**
     * 全局注册函数
     * @param {string} name 函数名
     * @param {Function} fn 函数
     */
    var registerGlobally = function (name, fn) {
        global$1[name] = fn;
    };

    /**
     * 生成一级回调函数
     *
     * @param {string} descName   API 名称
     * @param {function} success  用户的成功回调
     * @param {function} fail     用户的失败回调
     * @param {boolean} hasNext   是否含有二级回调
     * @return {Function}
     */
    function generateCallback(descName, ref, hasNext) {
        var success = ref.success;
        var fail = ref.fail;


        return function firstCallback(res) {

            res = normalizeResponse(res, descName);

            // 处理返回值（如果没二级回调，则区分成功失败执行用户回调；否则什么也不做，由二级回调来出触发用户回调）
            if (!hasNext) {
                if (+res.status === 0) {
                    success && success(res);
                }
                else {
                    fail && fail(res);
                }
            }
        };
    }

    /**
     * 生成二级回调函数
     *
     * @param {string} descName API 名称
     * @param success  用户的成功回调
     * @param fail     用户的失败回调
     * @return {Function}
     */
    function generateSecondCallback(descName, ref) {
        var success = ref.success;
        var fail = ref.fail;

        return function secondCallback(res) {

            res = normalizeResponse(res, descName);

            // 处理返回值（客户端的返回的状态码都是字符串）
            if (+res.status === 0) {
                success && success(res);
            }
            else {
                fail && fail(res);
            }
        };
    }

    /**
     * 基于自增的值，获取唯一的函数变量名
     * @return {string} 函数名
     */
    function getUniqueName() {
        return FUNC_PREFIX + (funcId++);
    }

    /**
     * @file  在下一个时间周期运行任务（参考 san）
     * @author zhoudan03
     * @date 2019/8/12
     */


    /**
     * 下一个周期要执行的任务列表
     *
     * @inner
     * @type {Array}
     */
    var nextTasks = [];

    /**
     * 执行下一个周期任务的函数
     *
     * @inner
     * @type {Function}
     */
    var nextHandler;

    /**
     * 浏览器是否支持原生Promise
     * 对Promise做判断，是为了禁用一些不严谨的Promise的polyfill
     *
     * @inner
     * @type {boolean}
     */
    var isNativePromise = typeof Promise === 'function' && /native code/.test(Promise);


    /**
     * 在下一个时间周期运行任务
     *
     * @inner
     * @param {Function} fn 要运行的任务函数
     * @param {Object=} thisArg this指向对象
     */
    function nextTick(fn, thisArg) {

        if (thisArg) {
            fn = fn.bind(thisArg);
        }

        nextTasks.push(fn);

        if (nextHandler) {
            return;
        }

        nextHandler = function () {
            var tasks = nextTasks.slice(0);
            nextTasks = [];
            nextHandler = null;

            for (var i = 0, l = tasks.length; i < l; i++) {
                tasks[i]();
            }
        };

        // 非标准方法，但是此方法非常吻合要求。
        if (typeof setImmediate === 'function') {
            setImmediate(nextHandler);
        }
        // 用MessageChannel去做setImmediate的polyfill
        // 原理是将新的message事件加入到原有的dom events之后
        else if (typeof MessageChannel === 'function') {
            var channel = new MessageChannel();
            var port = channel.port2;
            channel.port1.onmessage = nextHandler;
            port.postMessage(1);
        }
        // for native app
        else if (isNativePromise) {
            Promise.resolve().then(nextHandler);
        }
        else {
            setTimeout(nextHandler, 0);
        }
    }

    /**
     * @file 用于注入 jsNative 的自定义 processor
     * @author zhoudan03
     * @date 2019/5/28
     */

    var methodUndefinedCheckerSended = false;

    function isArray(o) {
        return Object.prototype.toString.call(o) === '[object Array]';
    }

    /**
     * 返回原值的方法，调用过程的兜底处理函数
     *
     * @inner
     * @param {*} source 原值
     * @return {*}
     */
    function returnRaw(source) {
        return source;
    }

    /**
     * 对数组进行遍历
     *
     * @inner
     * @param {Array} array 要遍历的数组
     * @param {Function} fn 遍历函数
     */
    function each(array, fn) {
        var len = array && array.length || 0;

        for (var i = 0, l = len; i < l; i++) {
            if (fn(array[i], i) === false) {
                break;
            }
        }
    }

    function getPrefix(scheme, description) {
        return scheme + description.authority + description.path;

    }

    /**
     * 获取用户参数，生成形如 key1=value1&key2=value2 的 string
     *
     * @param {Object} args 用户传参
     * @param {Object} description 调用描述对象
     * @return {string}  参数字符串
     */
    function getArgsString(args, description) {
        var argsString = '';

        if (description.args && description.args.length > 0) {
            var argResult = [];
            each(description.args, function (declaration, i) {
                var arg = args[i];
                if (arg != null) {
                    argResult.push(declaration.name + '=' + encodeURIComponent(arg));
                }
            });
            argsString = argResult.length >= 0 ? argResult.join('&') : '';
        }

        return argsString;
    }

    /**
     * 获取用户参数，生成形如 params=encodeURIComponent({key1:value1,key2:value}) 的 string
     *
     * @param {string} args 用户传参，已经被前一个处理器 stringify 过
     * @param {Object} description 调用描述对象
     * @return {string} 参数字符串
     */
    function getParamsString(args, description) {
        // 移除args中query部分
        if (args && Array.isArray(description.argQueryList)) {
            var rawArgs = JSON.parse(args);
            description.argQueryList.forEach(function (query) {
                if (rawArgs[query]) {
                    delete rawArgs[query];
                }
            });
            args = JSON.stringify(rawArgs);
        }

        var paramsName = description.paramsName || 'params';

        // 描述的 args 有参数，才需要这么做。
        return args ? (paramsName + '=' + encodeURIComponent(args)) : '';
    }

    /**
     * 获取 query 字符串。形如 action=flow 之类的固定值
     *
     * @param {Object} description 调用描述对象
     * @return {string} queryString
     */
    function getQueryString(description) {
        var queryStr = '';
        if (description.query) {
            var queryStrArray = [];
            for (var key in description.query) {
                if (description.query.hasOwnProperty(key)) {
                    queryStrArray.push(key + '=' + description.query[key]);
                }
            }
            queryStr = queryStrArray.join('&');
        }
        return queryStr;
    }

    /**
     * 获取参数中的query字符串
     * @param {string} args 用户传参，已经被前一个处理器 stringify 过
     * @param {Object} description 调用描述对象
     */
    function getArgQueryString(args, description) {
        var queryArray = [];
        if (description.argQueryList) {
            var rawArgs = args ? JSON.parse(args) : [];
            description.argQueryList.forEach(function (key) {
                if (rawArgs[key]) {
                    var queryValue = (typeof rawArgs[key] === 'string') ? rawArgs[key] : JSON.stringify(rawArgs[key]);
                    queryArray.push(key + '=' + encodeURIComponent(queryValue));
                }
            });
        }
        return queryArray.join('&');
    }

    /**
     * 对参数值进行检查
     *
     * @inner
     * @param {*} value 值
     * @param {Object} declaration 值声明
     * @return {number}
     */
    function checkValue(value, declaration) {
        declaration = normalizeValueDeclaration(declaration);
        if (value == null) {
            return declaration.isRequired && declaration.type !== '*' ? 1 : 0;
        }

        var valid = false;
        switch (typeof declaration.type) {
            case 'string':
                switch (declaration.type) {
                    case 'string':
                    case 'boolean':
                    case 'number':
                    case 'function':
                    case 'object':
                        valid = typeof value === declaration.type;
                        break;

                    case 'Object':
                        valid = typeof value === 'object';
                        // console.log('value type:', typeof value, value, valid);
                        break;

                    case 'Array':
                        valid = value instanceof Array;
                        break;

                    case '*':
                        valid = true;
                        break;
                }

                if (!valid) {
                    return 2;
                }
                break;

            case 'object':
                if (value && typeof value === 'object') {
                    valid = true;
                    for (var key in declaration.type) {
                        valid = !checkValue(value[key], declaration.type[key]);

                        if (!valid) {
                            break;
                        }
                    }
                }

                if (!valid) {
                    return 2;
                }
                break;

            default:

                if (declaration.oneOf) {

                    each(declaration.oneOf, function (expectValue) {
                        valid = expectValue === value;
                        return !valid;
                    });

                    if (!valid) {
                        return 3;
                    }

                }
                else if (declaration.oneOfType) {

                    each(declaration.oneOfType, function (expectType) {
                        valid = !checkValue(value, expectType);
                        return !valid;
                    });

                    if (!valid) {
                        return 4;
                    }

                }
                else if (declaration.arrayOf) {

                    if (value instanceof Array) {
                        valid = true;
                        each(value, function (item) {
                            return (valid = !checkValue(item, declaration.arrayOf));
                        });

                        if (!valid) {
                            return 5;
                        }
                    }
                    else {
                        return 2;
                    }

                }
        }

        return 0;
    }

    /**
     * 对值声明进行标准化处理
     *
     * @inner
     * @param {Object|string} declaration 值声明
     * @return {Object}
     */
    function normalizeValueDeclaration(declaration) {
        if (typeof declaration === 'string') {
            var realDeclaration = {isRequired: true};


            if (/=$/.test(declaration)) {
                realDeclaration.isRequired = false;
                declaration = declaration.slice(0, declaration.length - 1);
            }

            if (/\[\]$/.test(declaration)) {
                realDeclaration.arrayOf = declaration.slice(0, declaration.length - 2);
            }
            else if (declaration.indexOf('|') > 0) {
                realDeclaration.oneOfType = declaration.split('|');
            }

            // 事件类的函数
            else if (declaration === 'eventFunction') {
                realDeclaration.type = 'function';
            }

            else {
                realDeclaration.type = declaration;
            }

            return realDeclaration;
        }

        return declaration;
    }

    /**
     * 参数检查，错误直接抛出异常
     *
     * @param {Array} args 调用参数
     * @param {Array} declarations 参数声明列表
     * @param {Object} apiContainer jsNative 容器
     */
    function checkArgs(args, declarations, apiContainer) {

        // fixme 增加了 success 和 fail 的校验       // 在统一的地方传一个修正过的描述表
        declarations = declarations.concat([{
            name: 'success',
            value: 'function='
        }, {
            name: 'fail',
            value: 'function='
        }]);

        each(declarations, function (declaration, i) {
            var errorMsg = '';
            var value = normalizeValueDeclaration(declaration.value);

            switch (checkValue(args[i], value)) {
                case 1:
                    errorMsg = ' is required.';
                    break;

                case 2:
                    // console.log('type error 2', args[i], value, declaration);
                    errorMsg = ' type error. must be ' + JSON.stringify(value.type || 'Array');
                    break;

                case 3:
                    errorMsg = ' type error, must be oneOf ' + JSON.stringify(value.oneOf);
                    break;

                case 4:
                    errorMsg = ' type error, must be oneOfType ' + JSON.stringify(value.oneOfType);
                    break;

                case 5:
                    errorMsg = ' type error, must be arrayOf ' + JSON.stringify(value.arrayOf);
                    break;
            }

            if (errorMsg) {
                var title = apiContainer && apiContainer.options.errorTitle || 'jsNative';
                throw new Error('[' + title + ' Argument Error]' + declaration.name + errorMsg);
            }
        });
    }


    /**
     * 将调用参数合并成对象
     *
     * @inner
     * @param {Array} args 调用参数
     * @param {Array} declarations 参数声明列表
     * @return {Object}
     */
    function argCombine(args, declarations) {
        var result = {};
        each(declarations, function (declaration, i) {
            var arg = args[i];
            if (arg != null) {
                result[declaration.name] = arg;
            }
        });

        return result;
    }

    /**
     * 使用prompt调用
     *
     * @inner
     * @param {Array} description 描述表
     * @param {Array} args 调用参数
     * @return {Object}
     */
    function promptInvoker(description, args) {
        var segments = description.method.split('.');
        var newArgs = args || [];

        // 判断是否为只含有callback的情况
        if (!description.args || (description.args.length === 0)) {
            newArgs = newArgs.slice(1);
        }

        var caller = {
            obj: segments[0],
            func: segments.slice(1).join('.'),
            args: Array.isArray(newArgs) ? newArgs : [newArgs]
        };
        debug('window.prompt BdboxApp:' + JSON.stringify(caller));
        // eslint-disable-next-line no-alert
        return window.prompt('BdboxApp:' + JSON.stringify(caller));
    }


    /**
     * 获取用户参数，生成形如 key1=value1&key2=value2 的 string
     *
     * @param {Object} args 用户传参
     * @param {Object} description 调用描述对象
     * @param {Object} userQuery 用户参数
     * @return {string}  参数字符串
     */
    function getArgsStringWithUserQuery(args, description, userQuery) {

        // 小程序的 query
        var argResult = Object.keys(userQuery)
            .map(function (key) { return (key + "=" + (encodeURIComponent(userQuery[key]))); });

        // 协议的 query
        if (description.args && description.args.length > 0) {
            each(description.args, function (declaration, i) {
                var arg = args[i];
                if (arg != null) {
                    argResult.push(declaration.name + '=' + encodeURIComponent(arg));
                }
            });

        }

        return argResult.length >= 0 ? argResult.join('&') : '';
    }

    // schema 最长长度， 超过会报警， 长度规范参考这里： http://wiki.baidu.com/pages/viewpage.action?pageId=1522468568
    var MAX_URL_LENGTH = 1024 * 15;

    var processors = {

        /**
         * 自定义参数校验的处理器。校验参数的时候不完全依照描述表
         * @param {Object} description 调用描述对象
         * @param {string} option 处理参数
         * @param {Object} apiContainer jsNative容器
         * @return {Function}
         */
        ArgCheckWithCallback: function ArgCheckWithCallback(description, option, apiContainer) {
            return function processorArgCheckWithCallback(args) {
                checkArgs(args, description.args, apiContainer);
                return args;
            };
        },

        /**
         * 创建参数序列化的处理函数，功能和 js-native 中的 ArgEncode 类似，都是对参数进行字符串序列化。
         * 但是，本函数区分 string 和 object，仅对 object 做 stringify，避免字符串前后增加 双引号 "" ，导致客户端无法识别。
         * 因为客户端解析 scheme 协议时，是硬编码匹配 {} 找到JSON 对象，只对其进行 JSON parse 操作。
         * 而普通字符串，则拿来就用，不会 JSON parse，所以如果字符串在前端被 stringify 而带上了多余的双引号了的话，会导致客户端无法正确识别普通字符串。
         *
         * @return {Function}  返回一个函数，该接受上一个处理器的返回值作为参数
         */
        ArgsEncodeToJSONExceptString: function ArgsEncodeToJSONExceptString() {
            return function processorArgsEncodeToJSONExceptString(args) {
                each(args, function (arg, i) {
                    if (typeof arg === 'object') {
                        args[i] = JSON.stringify(arg);
                    }
                });

                return args;
            };
        },

        /**
         * 注册一二级回调  （本质上，这个 processor 并没有对参数进行处理。但是由于需要区分 invoke 决定是否注册回调函数，因此放在 processor 中）
         * 一二级回调的管理方式：使用一个对象，以 description name 为 key 记录一级回调；以一级回调的 name 为 key 记录二级回调。从而在后续端能力返回后，找到并触发对应的回调。
         * fixme args 最后两位本来是 success 和 fail，现在变成一二级回调了，可以吗？而且 pop 是不是有点隐晦
         *
         * @param {Object} description 调用描述对象
         * @return {function(*): *}
         * @constructor
         */
        RegisterCallbacks: function RegisterCallbacks(description) {

            var descName = description.name;

            return function processorRegisterCallbacks(args) {

                var fail = args.pop();
                var success = args.pop();

                // 生成二级回调（在 description 中指定了 nextCallback ，则代表有二级回调）
                if (description.nextCallback) {
                    var nextCallback = generateSecondCallback(descName, {success: success, fail: fail});
                    var nextCallbackFuncName = getUniqueName();
                    registerGlobally(nextCallbackFuncName, nextCallback);
                    args.push(nextCallbackFuncName);
                }

                // 生成一级回调
                var firstCallbackName = getUniqueName();
                var firstCallback = generateCallback(description.name, {success: success, fail: fail}, !!description.nextCallback);

                registerGlobally(firstCallbackName, firstCallback);
                args.push(firstCallbackName);


                return args;
            };
        },

        /**
         * 创建参数合并的处理函数
         *
         * @param {Object} description 调用描述对象
         * @param {string} option 处理参数
         * @return {Function}
         */
        ArgCombineWithCallback: function ArgCombineWithCallback(description, option) {
            var scheme = appProtoName + '://';
            switch (option) {
                case 'bdboxURL':

                    return function processorArgCombineWithCallbackBdboxURL(ref) {
                        var args = ref[0];
                        var callbackFunctionName = ref[1];


                        var prefix = getPrefix(scheme, description);
                        var queryString = getQueryString(description);
                        var argQueryString = getArgQueryString(args, description);
                        var paramsString = getParamsString(args, description);

                        var callbackString = (description.callbackName || description.callback || 'callback') + "=" + callbackFunctionName;

                        var resultStr = [paramsString, queryString, argQueryString, callbackString]
                            .filter(function (item) { return item !== ''; })
                            .join('&');

                        var schemeURL = prefix + '?' + resultStr;

                        console.log('scheme URL::: ', schemeURL);

                        return schemeURL;
                    };
                case 'URL':

                    return function processorArgCombineWithCallbackURL(args) {
                        var prefix = getPrefix(scheme, description);
                        var queryString = getQueryString(description);
                        var argQueryString = getArgQueryString(args, description);

                        // 一级回调字符串
                        var callbackName = description.callbackName || description.callback || 'callback';
                        var callbackString = callbackName + '=' + args.pop();

                        // 二级回调字符串
                        var nextCallbackString = description.nextCallback
                            ? (description.nextCallback + '=' + args.pop())
                            : '';

                        // 参数字符串
                        var paramsString = getArgsString(args, description);

                        var resultStr = [paramsString, nextCallbackString, queryString, argQueryString, callbackString]
                            .filter(function (item) { return item !== ''; })
                            .join('&');

                        var schemeURL = prefix + '?' + resultStr;

                        console.log('scheme URL::: ', schemeURL);

                        return schemeURL;
                    };

                case 'Object':
                    return function processorArgCombineWithCallbackObject(args) {

                        var requireArgs = description.args;
                        var callbackFunctionName = args.pop();

                        if (description.nextCallback) {
                            requireArgs = requireArgs.concat([{
                                name: description.nextCallback,
                                value: 'string'
                            }]);
                        }

                        // 如果API不接受参数（而且也没二级回调），就不传递空对象。
                        // 因为 Android 的 Java 函数传参数量决定了函数的定义(传参和不传参是两个不同的函数)。
                        if (requireArgs.length === 0) {
                            return [undefined, callbackFunctionName];
                        }

                        // 使用数组的方式传递 [params, callback]
                        // 有利于手百 8.2 之前的安卓 Java jsInterface 接受参数的格式 module.action(params, callback)
                        return [argCombine(args, requireArgs), callbackFunctionName];
                    };

                case 'JSONString':
                    return function processorArgCombineWithCallbackJSONString(args) {

                        var callbackFunctionName = args.pop();

                        var requireArgs = description.args;
                        if (description.nextCallback) {
                            requireArgs = requireArgs.concat([{
                                name: description.nextCallback,
                                value: 'string'
                            }]);
                        }

                        // 如果API不接受参数（而且也没二级回调），就不传递空对象。
                        // 因为 Android 的 Java 函数传参数量决定了函数的定义(传参和不传参是两个不同的函数)。
                        if (requireArgs.length === 0) {
                            return [undefined, callbackFunctionName];
                        }

                        // 使用数组的方式传递 [params, callback]
                        // 有利于手百 8.2 之前的安卓 Java jsInterface 接受参数的格式 module.action(params, callback)
                        return [JSON.stringify(argCombine(args, requireArgs)), callbackFunctionName];
                    };
            }

            return returnRaw;
        },


        /**
         *
         * @return {function(*[]): any[]}
         * @constructor
         */
        ArgJSONString: function ArgJSONString() {
            return function processorArgJSONString(ref) {
                var args = ref[0];
                var callbackFunctionName = ref[1];

                return [JSON.stringify(args), callbackFunctionName];
            };
        },

        /**
         * 创建方法调用的处理函数（根据 用户传入的args 决定调用传参，而非描述的 args长度）
         * @param {Object} description 调用描述对象
         * @param {string} option 处理参数
         * @return {Function}
         */
        /* istanbul ignore next */
        CallMethodByUserArgs: function CallMethodByUserArgs(description, option) {
            var methodOwner;
            var methodName;

            function findMethod() {
                if (!methodOwner) {
                    var segments = description.method.split('.');
                    var lastIndex = segments.length - 1;

                    methodName = segments[lastIndex];
                    methodOwner = global$1;
                    for (var i = 0; i < lastIndex; i++) {
                        methodOwner = methodOwner[segments[i]];
                    }
                }
            }

            function methodUndefinedChecker() {
                // 只发送一次
                if (methodUndefinedCheckerSended) {
                    return;
                }
                methodUndefinedCheckerSended = true;

                var methodInfo = [0, 0, 0, 0];
                if (!window.Bdbox_android_common) {
                    methodInfo[0] = 1;
                }
                else if (!window.Bdbox_android_common.setQuery) {
                    methodInfo[0] = 2;
                }
                if (!window.Bdbox_android_jsbridge) {
                    methodInfo[1] = 1;
                }
                else if (!window.Bdbox_android_jsbridge.dispatch) {
                    methodInfo[1] = 2;
                }
                // 存在 method-undefined 报错的 UA 端描述表开关是否打开
                if (!window._na) {
                    methodInfo[2] = 1;
                }
                else if (!window._na.getAPIs) {
                    methodInfo[2] = 2;
                }
                else if (!window._na.getAPIs(0)) {
                    methodInfo[2] = 3;
                }
                // 存在 method-undefined 报错的 UA 是否为 chrome浏览器
                if (window.chrome) {
                    methodInfo[3] = 1;
                }
                var lsStr = '';
                try {
                    lsStr = localStorage.getItem('methodInfo') || '';
                    var lsArr = lsStr ? lsStr.split('|') : [];
                    var methodInfoStr = methodInfo.join(',');
                    if (lsArr.indexOf(methodInfoStr) === -1) {
                        lsArr.push(methodInfoStr);
                        lsStr = lsArr.join('|');
                        localStorage.setItem('methodInfo', lsStr);
                    }
                }
                catch (err) {
                    // safari 隐私模式下 localStorage 会报错
                }
                var error = {
                    name: 'MethodUndefined',
                    message: 'Method undefined',
                    method: description.method,
                    info: methodInfo,
                    ls: lsStr
                };
                innerEvent.emit('error:method-undefined', error);
            }

            function callMethod(args) {
                // 区分是否是数组来决定调起方式
                findMethod();

                var methodDefined = methodOwner && methodOwner[methodName];

                // 这里对低版本的安卓端做特殊处理
                // global.prompt替代method直接调用（因为低版本不支持js interface）
                if (isAndroid && isMainBox && !methodDefined) {
                    return promptInvoker(description, args);
                }

                if (!methodDefined) {
                    methodUndefinedChecker();
                }

                // 不是数组，则直接传递
                if (!isArray(args)) {
                    debug(description.method + '(' + JSON.stringify(args) + ')');
                    return methodOwner[methodName](args);
                }

                // params 为 undefined 证明不需要传，移除此参数。
                // 因为安卓的 jsInterface 为 Java 函数，参数数量不同代表了不同的函数，传递了不该传的参数。会导致安卓报错找不到函数
                if (args[0] === undefined) {
                    args.shift();
                }

                debug(description.method + '(' + JSON.stringify(args) + ')');
                // 性能优化：对于高频的参数为0、1、2、3的情况，直接调用。减少 apply 带来的性能损失
                switch (args.length) {
                    case 0:
                        return methodOwner[methodName]();
                    case 1:
                        return methodOwner[methodName](args[0]);
                    case 2:
                        return methodOwner[methodName](args[0], args[1]);
                    case 3:
                        return methodOwner[methodName](args[0], args[1], args[2]);
                    default:
                        return methodOwner[methodName].apply(methodOwner, args);
                }
            }

            switch (option) {
                case 'callback':
                    return function processorCallMethodByUserArgsWithCallback(args) {
                        return callMethod(args);
                    };
                case 'noCallback':
                    return function processorCallMethodByUserArgsWithoutCallback(args) {
                        var callback = args.pop();
                        var res = callMethod(args);

                        // 对于直接返回值的 jsInterface，需要使用 nextTick 来使得回调能异步执行
                        nextTick(function () {
                            global$1[callback](res);
                        });
                    };
                default:
                    return function processorCallMethodByUserArgsDefault(args) {
                        return callMethod(args);
                    };
            }
        },

        CheckURL: function CheckURL() {
            return function processorCheckURL(url) {
                var args = [], len$1 = arguments.length - 1;
                while ( len$1-- > 0 ) args[ len$1 ] = arguments[ len$1 + 1 ];

                try {
                    debug('schema:', url);
                    var len = url.length;
                    if (len > MAX_URL_LENGTH) {
                        innerEvent.emit('error:url-too-long', {
                            name: 'URLTooLong',
                            message: 'The url is too long',
                            length: len,
                            url: url
                        });
                    }

                    var unexpectedKeywordMatch = /(NaN|null|undefined)/.exec(url);
                    if (unexpectedKeywordMatch) {
                        innerEvent.emit('error:url-include-unexpected-keyword', {
                            name: 'URLError',
                            message: 'The url include an unexpected keyword',
                            keyword: unexpectedKeywordMatch[0],
                            url: url
                        });
                    }
                }
                catch (err) {
                    // empty
                }

                return url;
            };
        },

        /**
         * 创建 openSwan（打开小程序的）的参数合并的处理函数
         *
         * @param {Object} description 调用描述对象
         * @return {Function}
         */
        SwanSchemeCombine: function SwanSchemeCombine(description) {
            var scheme = appProtoName + '://';

            return function processorSwanSchemeCombine(args) {
                var appKey = args[0];
                var appPath = args[1] || '';
                // appPath 开头字符不是/
                if (appPath.indexOf('/') !== 0) {
                    debug('xcx_path: ' + appPath + ' 必须是/开头');
                    var tailStr = appKey.substr(appKey.length - 1, 1);
                    // appKey 结尾不包含/时，appPath 开头需要补充/
                    appPath = tailStr === '/' ? appPath : '/' + appPath;
                }
                var query = args[2] && JSON.parse(args[2]) || {};

                args[0] = undefined;
                args[1] = undefined;
                args[2] = undefined;


                // 一级回调字符串
                var callbackName = description.callbackName || description.callback || 'callback';
                var callbackString = callbackName + '=' + args.pop();

                // 二级回调字符串
                var nextCallbackString = description.nextCallback ? (description.nextCallback + '=' + args.pop()) : '';

                var prefix = scheme + description.authority + '/' + appKey + appPath;
                var queryString = getQueryString(description);
                var paramsString = getArgsStringWithUserQuery(args, description, query);

                var resultStr = [paramsString, nextCallbackString, queryString, callbackString]
                    .filter(function (item) { return item !== ''; })
                    .join('&');

                var schemeURL = prefix + '?' + resultStr;

                console.log('scheme URL::: ', schemeURL);

                return schemeURL;
            };
        }
    };

    /**
     * @file 用于注入 jsNative 的自定义 processor
     * @author zhoudan03
     * @date 2019/5/28
     */

    var initProcessor = function (apiContainer) {
        for (var key in processors) {
            if (processors.hasOwnProperty(key)) {
                try {
                    apiContainer.addProcessorCreator(key, processors[key]);
                }
                catch (e) {
                    // do nothing
                }
            }
        }
    };

    /**
    * @file event.on event.off jscallback 参数重写
    *
    * 由于 event 的回调管理比较特殊，不属于即用即毁的类型，因此在此重写
    *
    * 目前端上事件通信设计的缺陷
    1. webview 刷新后，发送消息，端上仍然调用之前注册的事件，证明端上并没有在 webview 刷新后重置状态。不符合 webview 的生命周期。
    2. 目前事件通过字符串传递，导致前端和客户端需要分别管理事件，前端必须全局挂载事件供端调用，却不知道何时能移除。会导致前端内存泄露。更合理的解决办法应该是使用 jsBinding 的方式进行通信，由客户端统一 GC。
    *
    *
    * TODO 对于 callback 的长期保持需求，除了 event 以外，还有别的端能力。目前的解决方案是重写，待出现4个以上后，再进行总结及封装
    */

    /**
     * 用于回调函数包装命名的自增id
     *
     * @inner
     * @type {number}
     */
    var funcId$1 = 1;

    /**
     * 用于回调函数包装命名的前缀
     *
     * @inner
     * @const
     * @type {string}
     */
    var FUNC_PREFIX$1 = '__boxx_event_';

    function guid() {
        return FUNC_PREFIX$1 + (funcId$1++);
    }

    function wrapFunction(fn) {
        var id = guid();

        global$1[id] = function (action, data) {
             { // eslint-disable-line no-unused-labels
                event.emit('devtools:wrapFunction', {action: action, jscallback: id, data: data, functionName: fn.name});
            }
            fn(action, data);
        };

        return id;
    }

    /**
     * 比较用户传参的注册/反注册的事件  是否和存储的事件有同一个
     * 判断条件区分安卓和 iOS
     *
     * @param info
     * @param options
     * @return {boolean}
     */
    function isSameEvent(info, options) {
        // 安卓 需要看 page 和 action 的组合
        if (isAndroid) {
            if (options.jscallback) {
                return (info.page === options.page
                    && info.action === options.action
                    && info.fn === options.jscallback);
            }
            else {
                return info.page === options.page
                    && info.action === options.action;
            }
        }

        // ios 只看 action
        else if (options.jscallback) {
            return (info.action === options.action
                    && info.fn === options.jscallback);
        }
        else {
            return info.action === options.action;
        }
    }

    var fnContainer = [];


    function hasNoReference(fn) {
        return !fnContainer.some(function (item) {
            return fn === item.fn;
        });
    }

    /**
     * event.on/event.off jscallback 参数处理
     *
     * @param {String} type
     * @param {Object} options
     * @returns {Object}
     */
    // eslint-disable-next-line max-statements
    function eventParamsFilter(type, options) {
        if (type === 'event.on') {
            var fn = options.jscallback;
            if (typeof fn === 'string') {
                return options;
            }
            var fnString;

            var isUniqueEvent = true;
            var isUniqueFunction = true;

            // 允许重复注册。遍历找下有没有一样的。
            var eventItem;
            var len = fnContainer.length;
            while (len--) {
                eventItem = fnContainer[len];

                // 完全相同：重复注册，无需 push。
                if (isSameEvent(eventItem, options)) {
                    fnString = eventItem.fnString;
                    isUniqueFunction = false;
                    isUniqueEvent = false;
                    break;
                }
                // 有同样的函数，则使用同名的
                else if (eventItem.fn === options.jscallback) {
                    fnString = eventItem.fnString;
                    isUniqueFunction = false;
                    isUniqueEvent = true;
                    break;
                }
            }

            if (isUniqueFunction) {
                fnString = wrapFunction(options.jscallback);
            }

            if (isUniqueEvent) {
                fnContainer.push({
                    page: options.page,
                    action: options.action,
                    fn: options.jscallback,
                    fnString: fnString
                });
            }

            var rawArgs = {
                page: options.page,
                action: options.action,
                jscallback: fnString,
                rnmsg: options.rnmsg,
                allowDuplicate: options.allowDuplicate
            };

            options.success && (rawArgs.success = options.success);
            options.fail && (rawArgs.fail = options.fail);

            return rawArgs;
        }
        else if (type === 'event.off') {
            var fn$1 = options.jscallback;

            if (!fn$1 || (typeof fn$1 === 'string')) {
                return options;
            }

            var isExistentEvent = false;
            var len$1 = fnContainer.length;
            while (len$1--) {
                var eventInfo = fnContainer[len$1];

                if (isSameEvent(eventInfo, options)) {
                    fnContainer.splice(len$1, 1);

                    // 判断下整个数组， 如果没有别的函数引用，就从 全局对象 上移除该 function
                    if (hasNoReference(eventInfo.fn)) {
                        delete global$1[eventInfo.fnString];
                    }

                    var rawArgs$1 = {
                        page: options.page,
                        action: options.action,
                        rnmsg: options.rnmsg,
                        jscallback: eventInfo.fnString
                    };

                    options.success && (rawArgs$1.success = options.success);
                    options.fail && (rawArgs$1.fail = options.fail);

                    isExistentEvent = true;
                    return rawArgs$1;
                }
            }

            if (!isExistentEvent) {
                // fixme 对于不在 on 的列表内的事件，拦截了 off ，该逻辑设计可与业务方商榷
                console.error('error：尝试移除一个未被注册的事件函数');

                nextTick(function () {
                    options.fail && options.fail({
                        status: 1,
                        message: 'removes a function that has not be registered'
                    });
                });

                delete options.jscallback;
                return options;
            }
        }
        return options;
    }

    /**
     * @file  入参处理逻辑
     * @author zhoudan03 tianyu05
     * @date 2019/6/12
     * @description
     */

    var irregularParamsHandlers = {
        'search.setQuery': function (params, descName) {
            var authority = apiContainer.apis[apiContainer.apiIndex[descName]].authority;
            // 安卓高版本由jsInterface方法修正为searchframe方式，且需要history为布尔类型
            if (isAndroid && authority === 'searchframe') {
                params.history = Boolean(params.history);
                params = {
                    searchType: JSON.stringify(params)
                };
            }
            // ios要求history为数值类型
            else if (isIOS) {
                params.history = Number(params.history);
            }
            return params;
        },
        // 低版本端能力，未对外暴露，转化新版端能力的参数
        'account.openLoginDialog': function (params) {
            // eslint-disable-next-line camelcase
            params.third_login = params.showThirdLogin;
            // eslint-disable-next-line camelcase
            params.login_type = params.loginType;
            return params;
        },
        'app.feedback': function (params) {
            // 在安卓端，该端能力默认值为2
            if (isAndroid) {
                params.type = params.type || '2';
            }
            return params;
        },

        'easyBrowser.request': function (params) {
            params.header = params.header || {};
            params.data = params.data || {};

            if (isAndroid) {
                params.header = JSON.stringify(params.header);
                params.data = JSON.stringify(params.data);
                return params;
            }
            return params;
        },

        'commonUI.showToastOld': function (params) {
            params = params || {};
            params.string = params.message;
            return params;
        },

        // todo 确认这个逻辑存在的必要性。旧版本  onPerformanceFlowEvent 端能力在安卓必须传参 min_v
        'easyBrowser.onPerformanceFlowEvent': function (params) {
            if (isAndroid) {
                // eslint-disable-next-line camelcase
                params.min_v = '16789504';
            }
            return params;
        },

        'easyBrowser.openHybrid': function (params) {
            params = params || {};
            params.type = 'Hybrid';
            params.backup && params.backup.url && (params.backup.url = encodeURIComponent(params.backup.url));
            return params;
        },

        // todo 使用低版本手百 校验 低版本的打开 hybrid 的历史逻辑。
        'easyBrowser.openHybridOld': function (params) {
            params = params || {};

            if (isAndroid) {
                var backupURL = params.backup && params.backup.url || '';
                var toolTIDs = params.style && params.style.toolbaricons && params.style.toolbaricons.tids || '';
                var intent = [
                    'S.backup=' + JSON.stringify({url: encodeURIComponent(backupURL)}),
                    'component=com.baidu.searchbox/.home.feed.FeedDetailActivity',
                    'S.toolbaricons=' + encodeURIComponent(JSON.stringify({toolids: toolTIDs})),
                    'S.menumode=' + (params.menumode || '')
                ].join(';');
                return {
                    intent: 'intent:#Intent;' + intent + ';end',
                    // eslint-disable-next-line camelcase
                    min_v: params.min_v || '16783629',
                    mode: '0'
                };
            }

            // 历史逻辑
            // 1. 和 url 字段。（不删有影响吗？）
            // 2. tids 要是没值，就不传 toolbar  （传了有影响吗？）
            // 3. 如果传了轻应用appid，那默认置 isla 为1 （让用户传就好了）
            else if (isIOS) {
                var toolTIDs$1 = params.style && params.style.toolbaricons && params.style.toolbaricons.tids || '';
                params.toolbar = JSON.stringify({toolids: toolTIDs$1});

                params.type = 'Hybrid';
                params.openurl = encodeURIComponent(params.url);
                params.isla =  params.isla;
                params.minver = '5.3.0.0';
                params.opentype = 1;
                params.append = 0;
                params.rbtnstyle = 2;

                // 历史逻辑:  style 字段所有元素都需要散在外面; 删除掉 style 字段。（散在外面，不会覆盖掉外层的值吗？todo 确认此举意义）
                if (params.style && typeof params.style === 'object') {
                    var style = params.style;
                    for (var key in style) {
                        if (style.hasOwnProperty(key)) {
                            params[key] = style[key];
                        }
                    }
                    delete params.style;
                }
                return params;
            }
            return params;
        },

        // 此端能力会用于 getNetworkType API 的低版本支持
        'device.getDeviceInfo': function (params) {
            params.keys = params.keys || ['netInfo', 'screenInfo'];

            return params;
        },

        'event.on': function (params) {
            params = eventParamsFilter('event.on', params);
            if (params.action === 'globalSettingChange') {
                // 判断有无_Box_对象，没有则注入进去
                /* eslint-disable no-underscore-dangle */
                /* istanbul ignore next */
                if (!window._Box_) {
                    /* istanbul ignore next */
                    window._Box_ = {};
                }
                /* istanbul ignore next */
                if (!window._Box_.event) {
                    /* istanbul ignore next */
                    window._Box_.event = {};
                }
                /* istanbul ignore next */
                if (!window._Box_.event.broadcast) {
                    /* istanbul ignore next */
                    window._Box_.event.broadcast = broadcast;
                }
                /* eslint-enable no-underscore-dangle */
                window._Box_.event.broadcast.on(
                    params.action,
                    params.jscallback ? window[params.jscallback] : function () {/* empty */}
                );
            }
            return params;
        },
        'event.off': function (params) {
            if (params.action === 'globalSettingChange' && window._Box_) {
                delete window._Box_;
            }
            params = eventParamsFilter('event.off', params);
            return params;
        }
    };

    /**
     * 格式化处理 params用于兼容不同时期的协议之间响应信息的格式存在的差异。
     *
     * @param {Object} params 入参信息
     * @param {string} handler 响应信息的处理标识（使用的是 descName 标识）
     * @return {Object} 处理后的参数
     */
    function normalizeParams(params, handler) {

        if (Object.keys(irregularParamsHandlers).indexOf(handler) > -1) {
            return irregularParamsHandlers[handler](params, handler);
        }

        return params;
    }

    /**
     * @file 初始化挂载所有 API
     * @author zhoudan03
     * @date 2019/6/1
     */

    /**
     * 从用户参数中，获取 用于传递给 jsNative 的，与 args 顺序一一对应的参数值的数组 （jsNative接受的是数组。）
     * {
     *     key1: value1,
     *     key2: value2,
     *     success(){},
     *     fail(){}
     * }
     *
     * =>  [value1, value2, success, fail]
     * =>  [undefined, value2, undefined]
     * fixme, 用户参数没有的 但描述表的时候  保证数组长度一致性 . 而不应该返回空数组
     *
     * @param {Object} userArgs 用户参数对象
     * @param {Array} descArgs 描述表中要求的参数数组
     * @return {Array} 用户参数值数组
     */
    function getParamsArray(userArgs, descArgs) {
        var params = [];

        // fixme success 和 fail 作为 args 传入。能否有统一的修正描述表的地方
        var requireArgs = descArgs.concat([
            {name: 'success', value: 'function='},
            {name: 'fail', value: 'function='}
        ]);

        if (userArgs && requireArgs.length > 0) {
            params = requireArgs.map(function (arg) {
                return userArgs[arg.name];
            });
        }

        return params;
    }

    /**
     * 调起对应端能力
     */
    function getInvoker(apiContainer, descName, userArgs, descArgs, event, needThrowError) {
        // 内部有报错直接透传给外部， 使得业务可以拿到错误信息
        // 这个主要针对非 throw 的错误消息， 同时会补充对应的 api 及 stack 信息
        function innerErrorHandle(eventName, error) {
            error.api = descName;
            /* istanbul ignore else */
            if (!error.stack) {
                var tmpError = new Error(
                    error.message
                    /* istanbul ignore next */
                    || '[Invoke Error]'
                );
                error.stack = tmpError.stack;
            }

            addEnvInfo(error);

            // 某些事件需要延迟触发
            if (error.needDelayEmit) {
                error.delayEmitCallback = function () {
                    delete error.needDelayEmit;
                    delete error.delayEmitCallback;
                    event.emit(eventName, error);
                };
                return;
            }

            event.emit(eventName, error);
        }

        try {
            // 抛出调用事件，统计调用量
            event.emit('invoke:start', addEnvInfo({
                api: descName,
                args: userArgs
            }));

             { // eslint-disable-line no-unused-labels
                event.emit('devtools:getInvoker', {apiContainer: apiContainer, userArgs: userArgs, descName: descName});
            }

            // 处理双端入参有diff情况
            var normalizedUserArgs = normalizeParams(userArgs, descName);
            var params = getParamsArray(normalizedUserArgs, descArgs);

            innerEvent.on('error:*', innerErrorHandle);
            apiContainer.invoke(descName, params);
            innerEvent.off('error:*', innerErrorHandle);
        }
        catch (error) {
            innerEvent.off('error:*', innerErrorHandle);
            var newError = error;
            var eventName = 'unknown';
            var errorMessage = error.message || '';

            if (/^\[.+? Argument Error\]/.test(errorMessage)) {
                eventName = 'arg-invalid';
                var argName = errorMessage.split(']')[1].split(' ')[0];
                newError = {
                    name: 'ArgInvalidError',
                    message: errorMessage,
                    stack: error.stack,
                    arg: argName
                };
            }

            // newError 是 number string 等基本类型时， 添加字段会报错
            try {
                newError.api = descName;
            }
            catch (err) {
                // empty
            }

            addEnvInfo(newError);

            event.emit(("error:" + eventName), newError);
             { // eslint-disable-line no-unused-labels
                event.emit('devtools:getInvokerError', newError);
            }

            if (needThrowError) {
                throw error;
            }
        }
    }

    /**
     * 获取 api 对应的处理函数
     *
     * @param {Object} apiContainer jsNative容器
     * @param {Object} desc 描述表
     * @return {Function} 开发者调用 一个具体的 API 的处理函数。
     *         Function.params {Object} userArgs  该函数接受的参数 userArgs 为用户参数
     */
    var generateCallApi = function (apiContainer, event) {
        return function (descName, userArgs) {
            debug('搜索禁止使用 call 方法调用端能力，请先判断canIuse之后使用语义化 api 调用');
            var index = apiContainer.apiIndex[descName];
            if (index === undefined) {
                var message = '暂不支持 API: [' + descName + ']';
                var error = new Error(message);
                // 用户调用之前未判断canIUse，则抛出异常
                event.emit('error:api-missed', addEnvInfo({
                    name: 'APIMissedError',
                    api: descName,
                    message: message,
                    stack: error.stack
                }));
                return;
            }

            var desc = apiContainer.apis[index];
            getInvoker(apiContainer, descName, userArgs, desc.args, event, false);
        };
    };

    // 根据描述表名称，生成不同的通信逻辑 ( "a.b.c" => boxx.a.b.c)
    var getSingleInvoker = function (apiContainer, desc, event) {
        return function (userArgs) {
            getInvoker(apiContainer, desc.name, userArgs, desc.args, event, true);
        };
    };

    /**
     * 根据描述表名称，生成不同的通信逻辑 ( "a.b.c" => boxx.a.b.c)
     *
     * @param {Object} boxx API容器
     * @param {Object} apiContainer jsNative容器
     * @param {string} apiName api名称
     * @param {string} desc 描述表
     */
    function generateSingleAPI(boxx, apiContainer, apiName, desc, event) {
        if (apiName.indexOf('.') > 0) {
            var apiNameSegments = apiName.split('.');
            var methodOwner = boxx;
            var i = 0;
            var len = apiNameSegments.length - 1;
            for (; i < len; i++) {
                var segment = apiNameSegments[i];
                methodOwner[segment] = methodOwner[segment] || {};
                methodOwner = methodOwner[segment];
            }
            methodOwner[apiNameSegments[i]] = getSingleInvoker(apiContainer, desc, event);
        }
        else {
            boxx[apiName] = getSingleInvoker(apiContainer, desc, event);
        }
    }

    /**
     * 初始化每个端能力 API
     */
    var initAPIs = function (boxx, apiContainer, event) {
        var apis = apiContainer.apis;
        // 生成描述表对应的 api
        for (var i = 0, len = apis.length; i < len; i++) {
            var desc = apis[i];
            var apiName = desc.name;
            if (apiName && desc.invoke) {
                generateSingleAPI(boxx, apiContainer, desc.name, desc, event);
            }
        }
    };

    /**
     * @file  生成 canIUse API
     * @author zhoudan03
     * @date 2019/8/9
     */

    function generateCanIUse(apiContainer) {

        /**
         * canIUse 函数，用于判断 API 是否存在，允许两种写法：boxx.canIUse('ABTest.getSidList') 或 boxx.canIUse('boxx.ABTest.getSidList')
         *
         * @param {string} apiName  api名称字符串
         * @param {boolean} apiSwitch  api开关，如小程序降级开关
         * @return {boolean} true 代表存在，false 不代表不存在
         */
        return function canIUse(apiName, apiSwitch) {
            if (arguments.length === 2 && !apiSwitch) {
                return false;
            }
            return apiContainer.apiIndex[apiName] > -1;
        };
    }

    /**
     * @file 重定向 API 以在低版本手百上 映射 API 到低版本端能力 ， 同时删除低版本的暴露
     * @author zhoudan03
     * @date 2019/8/9
     */

    // key 为对外输出的 API 名称，同时也是高版本存在的端能力的 name
    // value 为具有同样功能的低版本端能力，仅对内作为低版本兼容手段，不对外暴露
    var compatibleMap = {
        'account.login': 'account.openLoginDialog',
        'album.image.open': 'album.image.openOld',
        'commonUI.closeLoading': 'commonUI.closeLoadingOld',
        'commonUI.showToast': 'commonUI.showToastOld',
        'easyBrowser.openHybrid': 'easyBrowser.openHybridOld',
        'easyBrowser.performanceFlowLog': 'easyBrowser.onPerformanceFlowEvent',
        'device.getNetworkType': 'device.getDeviceInfo'
    };

    /**
     * 获取函数名称
     * @param {Object} boxx API容器
     * @param {string} apiName 比如 album.image.open
     * @return {Object} 返回对象的原因是避免 如 album.image.open 在js执行过程中，会被找引用关系，找不到会报错。
     * 因此传递 album.image 和 open 用于执行时再对 open 赋值
     */
    function getFunctionName(boxx, apiName) {
        if (apiName.indexOf('.') > 0) {
            var apiNameSegments = apiName.split('.');
            var methodOwner = boxx;

            var i = 0;
            var len = apiNameSegments.length - 1;
            for (; i < len; i++) {
                var segment = apiNameSegments[i];

                methodOwner[segment] = methodOwner[segment] || {};
                methodOwner = methodOwner[segment];
            }

            return {
                methodOwner: methodOwner,
                methodName: apiNameSegments[i]
            };
        }
        else {
            return {
                methodOwner: boxx,
                methodName: apiName
            };
        }
    }

    /**
     * 将低版本 API 函数引用挂载到高版本的 API 名称上，以在低版本上能使用旧端能力达到同样的功能支持。
     * 同时删除低版本 API 的引用，不对外暴露
     * @param {Object} boxx API容器
     */
    function beCompatibleWithLowVersion(boxx) {
        for (var key in compatibleMap) {
            if (compatibleMap.hasOwnProperty(key)) {
                // 如果不支持高版本，且支持低版本，则做个映射
                if (!boxx.canIUse(key) && boxx.canIUse(compatibleMap[key])) {
                    var newAPIObj = getFunctionName(boxx, key);
                    var oldAPIObj = getFunctionName(boxx, compatibleMap[key]);

                    newAPIObj.methodOwner[newAPIObj.methodName] = oldAPIObj.methodOwner[oldAPIObj.methodName];

                    delete oldAPIObj.methodOwner[oldAPIObj.methodName];
                }
                // 如果支持高版本，则直接删除低版本端能力
                else if (boxx.canIUse(key) && boxx.canIUse(compatibleMap[key])) {
                    var oldAPIObj$1 = getFunctionName(boxx, compatibleMap[key]);
                    delete oldAPIObj$1.methodOwner[oldAPIObj$1.methodName];
                }
            }
        }
    }

    /**
     * @file  封装 addAPI 方法，允许用户添加描述表生成描述表
     * @author zhoudan03
     * @date 2019/9/20
     */

    /**
     * 添加用户的描述表
     *
     * @param {Object} boxx api容器
     * @param {Object} apiContainer jsNative容器
     * @param {Object} description 描述表
     */
    function add(apiContainer, description) {

        if (!isCapacityExisting(description)) {
            return;
        }

        normalizeDescription(description);

        if (!description.invoke) {
            throw Error('[boxx] ' + description.name + ': must specify right invoke type in description');
        }

        apiContainer.add(description);
    }

    /**
     * 引入兜底描述表方法
     * @param {*} descriptions 兜底描述表
     */
    function setDefaultDescription(descriptions) {
        if (descriptions && Object.keys(descriptions).length > 0) {
            var descriptionsList = getLocalDescriptions(descriptions);
            for (var i = 0; i < descriptionsList.length; i++) {
                add(apiContainer, descriptionsList[i]);
            }
        }

        // 语义化 api 处理
        initAPIs(this, apiContainer, event);
        // 重定向特殊 API
        beCompatibleWithLowVersion(this);
    }

    /**
     * @file 主模块和所有子模块的入口文件，用于生成boxx单例
     * @author chenqi14
     * @data 2019/10/08
     */
    /**
     * init boxx
     *
     * @returns {object} boxx
     */
    function addApi() {
        var boxx = {};
        // 挂载环境变量
        boxx.env = env;
        boxx.canIUse = generateCanIUse(apiContainer);
        boxx.call = generateCallApi(apiContainer, event);
        boxx.setDefaultDescription = setDefaultDescription.bind(boxx);
        boxx.on = event.on;
        boxx.off = event.off;
        boxx.once = event.once;
        boxx.setDebug = setDebug;
        return boxx;
    }

    /**
     * 注入兜底描述表并初始化
     *
     * @param {object} boxx
     */
    function addDefaultdDescription(boxx) {
        var defaultDescriptions = {};
        try {
            defaultDescriptions = document
            && document.querySelectorAll('[data-for=boxx-description]')
            && document.querySelectorAll('[data-for=boxx-description]')[0]
            && document.querySelectorAll('[data-for=boxx-description]')[0].innerHTML
            && JSON.parse(document.querySelectorAll('[data-for=boxx-description]')[0].innerHTML)
            || {};
            if (Object.keys(defaultDescriptions).length > 0) {
                isHitLocDesc(true);
            }
            else {
                isHitLocDesc(false);
            }
        }
        catch (error) {
            defaultDescriptions = {};
            console.error(error);
        }
        boxx.setDefaultDescription(defaultDescriptions);
    }

    /**
     * create boxx
     *
     * @returns {object} boxx instance
     */
    function createBox() {
        initProcessor(apiContainer);
        // 厂商浏览器描述表，需要对描述表的字段标准化处理
        browserDescriptionList.forEach(normalizeDescription);
        // 若当前环境支持厂商浏览器，则使用browserDescriptionList，否则使用端描述表
        var descriptionsList = isSupportSwanInBrowser
            ? browserDescriptionList
            : getDescriptions(apiContainer);
        apiContainer.add(descriptionsList);

        var boxx = addApi();
        addDefaultdDescription(boxx);

        return boxx;
    }

    /**
     * @file boxx 手百端能力js库 入口文件
     * @author lihuanyu01
     * @date 2021/5/25
     */


    // 给 jsNative 注入兜底描述表
    var boxx = createBox();

    /**
     * @file boxx 手百端能力js库 入口文件（支持远程调试工具 devtools-pro 的端能力调试插件 boxx-monitor）
     * @author liuhuyue
     * @date 2021/8/13
     */

    var PREFIXER = 'jsNative';
    var isDevtools = typeof $devtools !== 'undefined' && $devtools.sendCommand && $devtools.registerEvent;
    if (isDevtools) {
        $devtools.boxxMonitor = {};
    }
    registerEvents(boxx, apiContainer);
    var eid = 0;

    boxx.on('devtools:getInvoker', function (ref) {
        var apiContainer = ref.apiContainer;
        var userArgs = ref.userArgs;
        var descName = ref.descName;

        eid++;
        var messageId;
        if (userArgs._ws_message_id) {
            messageId = userArgs._ws_message_id;
        }
        if (userArgs._ws_ismock && messageId) {
            sendCommand('mockResult', {id: messageId, res: userArgs._ws_mockresponse});
            // TODO 成功/失败判断,执行成功/失败回调
            return;
        }
        userArgs._ws_message_id && delete userArgs._ws_message_id;
        userArgs._ws_mockresponse && delete userArgs._ws_mockresponse;
        userArgs._ws_ismock && delete userArgs._ws_ismock;
        ['fail', 'success'].forEach(function (key) {
            var fn = (userArgs || {})[key];
            if (fn && typeof fn === 'string') {
                fn = eval('(' + fn + ')');
            }
            if (fn && typeof fn === 'function') {
                var newFn = (function (id) {
                    return function (res) {
                        sendCommand('invokeResult', {id: id, messageId: messageId, res: res});
                        fn._oldFn ? fn._oldFn(res) : fn(res);
                    };
                })(eid);
                newFn._oldFn = fn._oldFn || fn;
                userArgs[key] = newFn;
            }
        });
        if (isDevtools) {
            $devtools.boxxMonitor.eid = eid;
            $devtools.boxxMonitor[eid] = userArgs;
        }
        sendCommand('invoke', {
            desc: apiContainer.apis[apiContainer.apiIndex[descName]],
            args: userArgs,
            id: eid,
            messageId: messageId
        });
    });
    boxx.on('devtools:getInvokerError', function (ref) {
        var param = ref.arg;
        var message = ref.message;
        var name = ref.name;

        return sendCommand('showErrorMsg', {
        id: isDevtools && $devtools.boxxMonitor.eid,
        errorMsg: {param: param, message: message, name: name}
    });
    });
    boxx.on('devtools:wrapFunction', function (data) { return sendCommand('emit', data); });

    function sendCommand(name, data) {
        if (isDevtools) {
            $devtools.sendCommand((PREFIXER + "." + name), data);
        }
    }
    function addEvent(name, handler) {
        if (isDevtools) {
            $devtools.registerEvent((PREFIXER + "." + name), handler);
        }
    }
    function registerEvents(boxx, apiContainer) {
        if (isDevtools) {
            addEvent('getApis', function () {
                return apiContainer.apis;
            });
            addEvent('getEnv', function () {
                return boxx.env;
            });
            addEvent('invoke', function (ref) {
                var name = ref.name;
                var id = ref.id;

                var nameSegments = name.split('.');
                var methodOwner = boxx;
                nameSegments.forEach(function (segment) {
                    methodOwner = methodOwner[segment];
                });
                methodOwner($devtools.boxxMonitor[id]);
            });
            addEvent('invokeAgain', function (payload) {
                var name = payload.name;
                var args = payload.args;
                var id = payload.id;
                var isMock = payload.isMock;
                var mockresponse = payload.mockresponse;
                var nameSegments = name.split('.');
                var methodOwner = boxx;
                nameSegments.forEach(function (segment) {
                    methodOwner = methodOwner[segment];
                });
                /* eslint-disable camelcase */
                args._ws_message_id = id;
                args._ws_mockresponse = mockresponse;
                args._ws_ismock = isMock;
                /* eslint-enable camelcase */
                methodOwner(args);
            });
            addEvent('repeatBoxxEvent', function (ref) {
                var name = ref.name;
                var action = ref.action;
                var data = ref.data;

                return global$1[name](action, data);
            });
        }
    }

    return boxx;

})));
