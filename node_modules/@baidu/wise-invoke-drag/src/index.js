/**
 * @file 拖拽按钮回流
 * @author okaychen<chenglong13@baidu.com>
 */

import styles from './styles.css';
import merge from 'lodash-es/merge';
import isFunction from 'lodash-es/isFunction';
import {
    isRangeIn,
    changeStyle,
    COMMON_RANGE,
    COMMON_OPTION
}
from './utils/index.js';

class DragCreator {
    constructor(options) {
        merge(this, COMMON_OPTION, options);
        this.initData();
        this.render();
        this.insertCss();
        this.bindEvent();
    }

    initData() {
        // 最终偏移
        this.state = {
            oLeft: '',
            oTop: ''
        };
        // 避免移动中误触
        this.click = false;
        this.moving = false;
        // 动态偏移
        this.oW = null;
        this.oH = null;
        // 元素宽高
        this.dragWidth = null;
        this.dragHeight = null;
        // 页面宽高
        this.htmlWidth = null;
        this.htmlHeight = null;
        // 记录最初位置
        this.beginTop = [];
        this.beginLeft = [];
        // 页面-元素
        this.countWidth = null;
        this.countHeight = null;
        // 移除class
        this.removeClass = [
            'drag-radiusL',
            'drag-radiusR',
            'drag-duration',
            'drag-bottom'
        ];
    }

    // 记录拖拽位置
    changePos(oLeft, oTop) {
        this.state = {
            oLeft,
            oTop
        };
    }

    // 移动触发
    touchstart(e) {
        e = e.touches[0];

        // 触摸且没有处于移动中
        this.moving = false;

        this.oW = e.clientX - this.dragWrap.getBoundingClientRect().left;
        this.oH = e.clientY - this.dragWrap.getBoundingClientRect().top;

        let oLeft = e.clientX - this.oW;
        let oTop = e.clientY - this.oH;

        // 记录开始位置
        this.beginLeft.push(oLeft);
        this.beginTop.push(oTop);

        this.changePos(oLeft, oTop);
    }

    // 移动结束
    touchend(offsetType) {
        this.dragWrap.classList.add('drag-duration');
        const isDouble = offsetType === 'double';

        // 边界处理
        let isToLeft = this.state.oLeft < (this.countWidth / 2);
        let oLeft = isDouble
            ? (isToLeft ? 0 : this.countWidth + 10)
            : (isToLeft ? -COMMON_RANGE : this.countWidth + COMMON_RANGE);
        let oTop = this.state.oTop < 0
            ? 0
            : Math.min(this.state.oTop, this.countHeight - 50);

        // 复原处理
        let beginTop = this.beginTop[0];
        let beginLeft = this.beginLeft[0];
        let isRecover = isRangeIn(this.state.oTop, beginTop + COMMON_RANGE, beginTop - COMMON_RANGE)
            && isRangeIn(this.state.oLeft, beginLeft + COMMON_RANGE, beginLeft - COMMON_RANGE);

        // 复原or处理圆角
        if (isRecover) {
            oLeft = beginLeft;
            oTop = beginTop;
        } else {
            isToLeft
                ? this.dragWrap.classList.add('drag-radiusL')
                : this.dragWrap.classList.add('drag-radiusR');
        };

        this.changePos(oLeft, oTop);

        this.moving && changeStyle(this.dragWrap, oLeft, oTop);
    }

    // 移动中
    touchmove(e) {
        this.moving = true;
        this.moving && this.onmove(e);
    }

    onmove(e) {
        e.preventDefault();
        e = e.touches[0];

        // 移除上次移动添加的圆角和过渡class
        // 并且去掉bottom，避免bottom top同时作用变形
        this.removeClass.map((item) => this.dragWrap.classList.remove(item));

        // 限制拖拽边界
        let oLeft = e.clientX - this.oW < 0 ? 0 : Math.min(e.clientX - this.oW, this.countWidth);
        let oTop = e.clientY - this.oH < 0 ? 0 : Math.min(e.clientY - this.oH, this.countHeight);

        this.changePos(oLeft, oTop);
        changeStyle(this.dragWrap, oLeft, oTop);
    }

    // 渲染容器
    render(content) {
        const tpl = `
            <div class="drag-wrap drag-bottom"
                style="left: 50%;transform: translate(-50%, 0%)">
                ${content}
            </div>
        `;
        document.body.insertAdjacentHTML('beforeend', tpl);

        this.bindDom();
        this.bindData();
    }

    // 绑定dom
    bindDom() {
        this.dragWrapArr = document.querySelectorAll('.drag-wrap');

        // 支持多次实例化
        this.dragWrapArr.forEach((item) => this.dragWrap = item);
    }

    // 插入style
    insertCss() {
        document.head.insertAdjacentHTML('beforeend', styles);
    }

    // 回流事件
    backflow(e) {
        e && e.preventDefault();
        if (isFunction(this.invokeCallback)) {
            this.invokeCallback();
        }
    }

    // 绑定事件
    bindEvent() {
        this.dragWrap.addEventListener('click', (e => this.backflow(e)));
        // 如果需要支持拖拽~
        if (this.isNeedDrag) {
            this.dragWrap.addEventListener('touchstart', e => this.touchstart(e));
            this.dragWrap.addEventListener('touchend', e => this.touchend(e));
            this.dragWrap.addEventListener('touchmove', e => this.touchmove(e));
        }
    }

    // 初始化数值
    bindData() {
        this.dragWidth = this.dragWrap.offsetWidth;
        this.dragHeight = this.dragWrap.offsetHeight;

        this.htmlWidth = document.documentElement.clientWidth;
        this.htmlHeight = document.documentElement.clientHeight;

        this.countWidth = this.htmlWidth - this.dragWidth;
        this.countHeight = this.htmlHeight - this.dragHeight;
    }
}

class DragSingle extends DragCreator {
    constructor(...args) {
        super(...args);
    }

    render() {
        const singleContent = /* html */ `
            <div class="common-wrap single-pd" id="single-wrap">
                <img class="single-logo" src="${this.logo}" />
                <p class="single-title">${this.title}</p>
            </div>
        `;
        super.render(singleContent);
    }

    // 绑定dom
    bindDom() {
        super.bindDom();
        this.sWrap = document.querySelector('#single-wrap');
    }
}

export default {DragSingle};