
# mcp-sdk
策略中台SDK

# 如何贡献
```shell script
git add ./
npm run commit  交互式提交commit
git gpush

```

## 发布流程
1. 确保所有commit都已合入主干
2. `npm run version` 生成changelog、升级版本号
3. `git gppush` 合入代码
4. `npm run release` 打tag、发布npm包

#MCP SDK API和使用demo
 mcp-sdk提供了前端需要的基础api, 设置公参、拉取策略信息、判断点击退场状态、执行调起。
业务方FE可以按业务场景自行完成业务需求，并在关键位置执行sdk中的api。

## 注意！

【ios写剪贴板有系统限制】，不能静默或者异步写入，所以一定要先请求，再执行调起。

**不可以点击后发起请求，异步结果回来后执行调起。**
## API
#### getCommonParams`() => Object`
获取公参


---
#### setCommonParams`(config: Object，reset = false: boolean) => undefined`

```js
{
    app: '接口APP字段',
    scene: '场景',
    from: '渠道号',
    // 可选，不传会使用amis配置的信息
    invoke_id: '',
    channel_id: '',
    token_id: ''
}
```

设置公参，同名key会覆盖，不同key会合并至公参对象。
reset默认false，设置成true的时候，会把传入的config作为公参，清除之前的公参。


---
#### getInvokeInfo`(config: Object) => Object`
远端获取配置信息

```js
// config需要传入的参数
{
    app:'接口APP字段',
    scene:'场景',
    from:'渠道号',
    invoke_id,
    channel_id,
    token_id,
    invoke_info
}


// 这里是api中实际request发出的请求参数
// 会合并commonParams
{
    from,
    query, // 搜索词
    invoke_id,
    channel_id,
    token_id,
    req_type:0,
    req_content:{},
    invoke_info:{
        pos_1:[{
            // 自定义参数
             vid
        }]

}
```


---
#### execInvoke`(config:Object) => Promise`
执行调起
```js
{
posid,
invoke_info
log_id
}
```
返回值

|  返回值 | 类型 | 描述 |
| :----: | :----: | :---- |
| status | number | 调起成功定义`promise.resolve`:<br>10000: app或universal link调起成功<br>10001: 应用商店调起成功<br>10002: 下载链接调起成功<br>10003: 在安卓微信中应用宝调起成功<br>调起失败定义`promise.reject`:<br>20001-20003: 参数错误<br>20004: 口令复制失败<br>20005: toStore、downloadUrl为false时，调起失败(调起APP时失败)<br>20006: 不支持此系统<br>20007: downloadUrl为false时，调起失败(调起APP及应用商店时失败)<br>20008: IOS系统下调起universal link失败<br>20011: 不支持的appName，请检查AppName属性和当前版本<br>50001: 命中退避策略<br>50002: 当前策略为不调起|
|   msg  | string | 对状态码的描述 |


---
#### hitMcp`(posVal: Array,  index = 0: number) => boolean`
复杂业务状态下才会用到，可以根据这个api判断是否需要区分原有业务逻辑和mcp下的业务逻辑。
业务上的FE应该依次判断前两种策略状态来决定后续业务行为。

需要注意的是，如果需求就是命中mcp后点击调起，不需要这个Api.
业务对于没命中策略、命中策略返回不需要调起、调起失败，都是一个处理逻辑，
直接使用execInvoke判断statusCode即可。
```js
1. 通过hitMcp()判断是否命中了mcp策略？小流量状态下，或者某些策略场景，
   会告诉业务FE不要执行mcp行为。!need的情况下，走原有业务逻辑

3. 如果配置了点击退场策略，是否有命中点击退场策略？此策略可能会影响展现行为
 （比如点击是否出引导弹窗）

3. 执行调起行为
```

| 参数    |是否必须 | 类型 | 说明 | 默认值|
| :----:     | :----: | :----: | :----: | :----: |
| posVal |   是   | array | 每一个pos_id的数组值 |无|
| index |   否   | number | 要判断的物料索引，默认设为第一位，不用传 |0|

|  返回值 | 类型 | 描述 |
| :----: | :----: | :---- |
|     | boolean | 是否需要执行调起策略 |


```js
// demo
import {needInvoke, execInvoke} from '@baidu/mcp-sdk';
const invokeInfo = await getInvokeInfo({
            invoke_info: {
                pos_1: [{}]
            }
        });
 // pos_1这个调起位是否命中了mcp的策略？
const isHit = hitMcp(invokeInfo.action_rule.pos_1);

// 命中的，走mcp策略
if(isHit）{
  // 也许这里会需要 getExitInfo()处理展现逻辑?
  //  const isExit = getExitInfo('pos_1').isExit;
  // ...
  // 执行调起
  const logId = invokeInfo.log_id;
  const res = await execInvoke('pos_2', replacedInvokeInfo.action_rule.pos_1[0], logId);
} else {
    // 没有命中mcp策略，走原来业务逻辑
    // 执行页面原有逻辑，如点击跳转等
    ...
}
```

---
#### getExitInfo`(posId:string) => Object`
获取退场信息
```js
const exitInfo = getExitInfo('pos_1');
console.log(exitInfo);
/*
* {
*     isExit: true,  是否退场，true为退场
*     timeLeft: 54000  如已退场，剩余退场时间
* }
* */
```

---
#### isNotInvoke`(conf:Object) => boolean`
获取目前策略是否为不调起
```js
const conf = invokeInfo.action_rule.pos_2[0];
if (isNotInvoke(conf)) {
    // 此处为不进行调起的代码
}
else {
    const res = await execInvoke('pos_2', conf, logId);
}
/*
* 返回为true代表此策略为不调起
* 为false则为调起
* */
```

---
### replaceStubs`(invokeConf:Object, placeholders:Object) => Object`
替换invokeConf中的占位符，这里的invokeConf应该是mcp后端接口获取的对象，包含action_rule数组。
方法调用后不修改原始引用的值

```js
    {{query}}做替换
    const replacedInvokeInfo = replaceStubs(invokeInfo, {query: 'xxx'});
```


## demo示例
```javascript
import san from 'san';
import {execInvoke, getExitInfo, setCommonParams, getInvokeInfo} from '../../src';
import {replaceStubs} from '../../src/api/replaceStubs';

const App = san.defineComponent({
    template: `
        <div id="app">
            <div>ua：{{ua}}</div>
            <div class="cut">===========================================</div>

            <button class="btn" on-click="invoke">策略调起</button>

            <div class="cut">==============apm打包输出测试=============================</div>
            <button class="btn" on-click="invokeApm">策略调起</button>
            <div class="cut">==============apm打包输出测试=============================</div>


</div>
    `,
    initData() {
        return {
            invokeInfo: ''
        };
    },
   async attached() {
        setCommonParams({
            app: 'wise',
            scene: 'ipad',
            from: '渠道号',
            // 可选，不传会使用amis配置的信息
            invoke_id: '',
            channel_id: '',
            token_id: ''
        });
        const invokeInfo = await getInvokeInfo({
            invoke_info: {
                pos_1: [{}],
                pos_2: [{}],
                pos_3: [{}]
            }
        });
        console.log(invokeInfo);

        this.data.set('invokeInfo', invokeInfo);
        // 判断是否有点击退场的状态
        // 可能涉及到弹窗是否展现等业务，所以把状态暴露给业务方自行判断
        const isExit = getExitInfo('pos_2').isExit;
        console.log(isExit);

    },
    // 在调起按钮上绑定调起方法
    // 点击按钮执行以下操作
    async invoke() {
        const invokeInfo = this.data.get('invokeInfo');
         // pos_2这个调起位是否命中了mcp的策略？
        const isHit = hitMcp(invokeInfo.action_rule.pos_2);
        if (isHit) {
            // 执行替换
            // 替换结果会作为返回值
            // 不修改原始引用的数据
            const replacedInvokeInfo = replaceStubs(invokeInfo, {query: 'xxx'});
            const logId = invokeInfo.log_id;
            // 调起结果
            const res = await execInvoke('pos_2', replacedInvokeInfo.action_rule.pos_2[0], logId);
        }else {
        // 执行原有业务逻辑
        }
    }

new App().attach(document.body);

```
