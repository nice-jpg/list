import {getLocation} from './utils/utils'

/**
 * @file 打点重试机制
 * @author changyuqing@baidu.com
 *
 */
const maxStorageLength = 5;
let isStorageInit = false;
let origin = '';
let retryLogLists = null;

function setStorage(value) {
    if (!isStorageInit) {
        getStorage();
    }
    let now = Date.now();

    if (!retryLogLists[origin]) {
        // retryLogLists 中不存在当前页面对应的列表
        // 如果retryLogLists里面存放过多，则删除最旧的记录
        if (retryLogLists.length >= maxStorageLength) {
            let path = Object.keys(retryLogLists).reduce((pre, cur) => {
                if (retryLogLists[cur] !== 'length' && retryLogLists[cur].time <= pre.time) {
                    return {
                        time: retryLogLists[cur].time,
                        path: cur
                    };
                }
                return pre;
            }, {time: now, path: ''}).path;
            delete retryLogLists[path];
        } else {
            retryLogLists.length++;
        }
    }
    retryLogLists[origin] = {
        list: value,
        time: now
    };

    localStorage.setItem('RETRY_LOG_LIST', JSON.stringify(retryLogLists));

}

function clearStorage() {
    if (!isStorageInit) {
        getStorage();
    }
    if (retryLogLists[origin]) {
        delete retryLogLists[origin];
        retryLogLists.length--;
    }
    localStorage.setItem('RETRY_LOG_LIST', JSON.stringify(retryLogLists));

}

function getStorage() {
    if (!isStorageInit) {
        isStorageInit = true;
        origin = getLocation().origin + getLocation().pathname;
    }
    try {
        retryLogLists = JSON.parse(localStorage.getItem('RETRY_LOG_LIST')) || {length: 0};
    } catch (e) {
        retryLogLists = {length: 0};
    }
    return retryLogLists[origin]?.list || [];
}

export class RetryLogger {
    constructor({logFn = () => { }}) {
        this.logFn = logFn;
        this.retryLogList = this._getInitErrLogs();
        this.retryTimesMax = 3; // 最大重发次数
        this.retryLogListMax = 5; // 重试队列最大长度
        this._retryIntervalTimer = null;
    }

    // 从storage中读取遗留的日志
    _getInitErrLogs() {
        let logs = getStorage();
        return new Map(logs.map(item => {
            return [item[0], {
                ...item[1],
                failTimes: 1,
                sendCountDown: this._getDelayTime(item.failTimes)
            }];
        }));
    }

    _getDelayTime(failTimes) {
        // 延迟重发时间的配置。连续失败次数越多，发送延迟越久
        let timeMap = {
            0: 1, // s
            1: 1,
            2: 5
        };
        return timeMap[failTimes] || (10 + Math.floor(Math.random() * 5 + 1));
    }

    active() {
        if (!this._retryIntervalTimer && this.retryLogList.size > 0) {
            this._retryIntervalTimer = setInterval(() => {
                this._retryIntervalTimerHandler();
            }, 1000);
        }
    }

    addLog({url, loggerData, loggerId}) {
        this.retryLogList.set(loggerId, {
            url,
            loggerData,
            loggerId,
            failTimes: 1,
            sendCountDown: this._getDelayTime(1)
        });
        // 超出最大长度时 取出队列中最久的一条
        if (this.retryLogList.size > this.retryLogListMax) {
            let key = this.retryLogList.keys().next().value;
            this.retryLogList.delete(key);
        }

        this.active();
        // 把更新的数据更新到本地存储
        setStorage(Array.from(this.retryLogList));
    }

    removeLog(loggerId) {
        if (!loggerId) {
            return;
        }
        if (this.retryLogList.delete(loggerId)) {
            if (this.retryLogList.size === 0) {
                clearStorage();
            } else {
                // 更新本地缓存
                setStorage(this.retryLogList);
            }
        }
    }

    updateLog(loggerId) {
        if (!loggerId) {
            return;
        }
        let item = this.retryLogList.get(loggerId);
        if (item) {
            const curFailTimes = item.failTimes;
            // 如果超过最大重试次数 则不再重发 从队列中删除
            if (curFailTimes + 1 > this.retryTimesMax) {
                this.removeLog(loggerId);
            } else {
                item.failTimes = curFailTimes + 1;
                item.sendCountDown = this._getDelayTime(item.failTimes);
            }
        }
    }

    _retryIntervalTimerHandler() {
        this.retryLogList.forEach(logItem => {
            // 倒计时为-1时 表示该条日志正在被重新发送
            if (logItem.sendCountDown < 0) {
                return;
            } else if (+logItem.sendCountDown === 0) {
                // 倒计时已到 执行再次发送
                logItem.sendCountDown = -1; // 设置其正在方法
                this._sendLog(logItem);

            } else {
                // 倒计时计时 -1
                logItem.sendCountDown = logItem.sendCountDown - 1;
            }
        });
        if (this.retryLogList.size === 0) {
            clearInterval(this._retryIntervalTimer);
            this._retryIntervalTimer = null;
        }
    }

    _sendLog(logItem) {
        this.logFn(logItem.url, logItem.loggerData)
            .then(() => {
                this.removeLog(logItem.loggerId);
            })
            .catch(() => {
                this.updateLog(logItem.loggerId);
            });
    }

}