/**
 * @file browserslist
 * @author zhangsiyuan(zhangsiyuan@baidu.com)
 */
// browser并不是越多越好，够用即可
// 判断browser是否有意义，在于他是否是对各种调起rules有影响
// 对于没有意义的browser，比如遨游浏览器和opera这种，并没有什么区别
const browserMap = new Map([['wechat', /micromessenger/i], ['baiduboxatomic', /baiduboxatomic/i], ['qqbrowser', /\bm?qqbrowser\/([0-9.]+)(?!.* qq)/i], ['qq', /\bqq\/([0-9.]+)/i], ['weibo', /weibo__/i], ['uc', /((?:[\s\/])uc?\s?browser|(?:juc.+)ucweb)[\/\s]?([\w.]+)/i], ['360', /(qihu|qhbrowser|qihoobrowser|360browser)/i], ['baiduboxlite', /(lite|info) baiduboxapp/i], ['fortunecat', /fcapp/i], ['baiduboxmission', /mission baiduboxapp/i], ['baiduboxvision', /baiduboxvision/i], ['baiduboxapp', /baiduboxapp/i], ['tieba', /tieba/i], ['baiduhaokan', /haokan/i], ['bdminivideo', /bdminivideo/i], ['bdnetdisk', /netdisk/i], ['baidumap', /baidumap/i], ['baiduhi', /baiduhi_android/i], ['bddrama', /bddrama/i], ['knews', /knews/i], ['baiduboxsenior', /baiduboxsenior/i], ['wenku', /com.baidu.wenku/i], ['lemon', /lemonapp/i], ['baiduinput', /baiduinput/i], ['weibaapp', /weibaapp/i], ['youjia', /youjia/i], ['yike', /youa/i], ['bdwkst', /-HadesCore-.*student/i], ['askmybaby', /mybaby/i], ['tomas', /tomas/i], ['xiaoduapp', /xiaoduapp|oneapp|XDH-01-A1|FromApp\/XiaoDuApp| FromApp\/XiaoDuZaiJiaApp /i], ['yiju', /bdyiju/i], ['rap', /hiphop/i], ['wepod', /wepod/i], ['bdhealthapp', /bdhealthapp/i], ['yymobile', /.*yy([(])?(clientversion:)?([0-9.]+).*/gi], ['baiduhanyu', /dictapp/i], ['sogou', /sogoum(obilebrowser|se)/i], ['alipay', /alipayclient/i], ['taobao', /\baliapp\(tb\/([0-9.]+)\)/i], ['tianmao', /\baliapp\(tm\/([0-9.]+)\)/i], ['tao', /\btaobrowser\/([0-9.]+)/i], ['quark', /\bquark\/([0-9.]+)/i], ['xiaomi', /\bmiuibrowser\/([0-9.]+)/i], ['oppo', /\bheytapbrowser\/([0-9.]+)/i], ['vivo', /\bvivobrowser\/([0-9.]+)/i], ['meizu', /\bmzbrowser\/([0-9.]+)/i], ['huawei', /huaweibrowser\/([0-9.]+)/i], ['samsung', /\bsamsungbrowser\/([0-9.]+)/i], ['edge', /edge\/([0-9.]+)/i], ['firefox', /\bfirefox\/([0-9.ab]+)/i], ['chrome', /(?:chrome|crios|crmo)\/([0-9.]+)/i], ['safari', /\bversion\/([0-9.]+(?: beta)?)(?: mobile(?:\/[a-z0-9]+)?)? safari\//i]]);

/**
 * @file 手机厂商list
 * @author zhangsiyuan(zhangsiyuan@baidu.com)
 */
// 正则匹配不到的，给个默认值 '-'
const brandMap = {
  samsung: /.*Android.*(SAMSUNG|SM-).*/i,
  huawei: /.*huawei.*/i,
  honor: /.*honor.*/i,
  oppo: /.*(OPPO|heytap|p[a-z][a-z][a-z]\d0).*/i,
  vivo: /.*Android.*(vivo|v\d\d\d\d[a-z]?a?).*/i,
  xiaomi: /.*Android.*(Mi|M2011K2C).*/i,
  apple: /(iPhone|iPod|iPad|Macintosh)/i
};

/**
 * @file 环境判断
 * @author zhuzhibo <zhuzhibo@baidu.com>
 */
const ua = navigator.userAgent;

function detectIpad() {
  let isMobile = RegExp(/iPad/i).test(navigator.userAgent);

  if (!isMobile) {
    const isMac = RegExp(/Macintosh/i).test(navigator.userAgent);

    if (isMac && navigator.maxTouchPoints && navigator.maxTouchPoints > 2) {
      isMobile = true;
    }
  }

  return isMobile;
}

const IS_IPAD = detectIpad();
const IS_IOS = /(iPhone|iPod|iPad|Macintosh)/i.test(ua) || IS_IPAD;
const IS_ANDROID = /(Android)/i.test(ua);

function getIOSVersion() {
  let reg = /OS ((\d+_?){2,3})\s/i;

  if (IS_IOS) {
    let osv = reg.exec(navigator.userAgent); // @ts-ignore

    if ((osv === null || osv === void 0 ? void 0 : osv.length) > 0) {
      // @ts-ignore
      return osv[0].replace('OS', '').replace('os', '').replace(/\s+/g, '').replace(/_/g, '.');
    }
  }

  return '';
}

const IOS_VERSION = Number(getIOSVersion().split('.')[0]);

/**
 * @file ua parser
 * @author zhangsiyuan(zhangsiyuan@baidu.com)
 */
function getHostInfo() {
  const ua = navigator.userAgent;
  const os = IS_IOS ? 'ios' : IS_ANDROID ? 'android' : '-'; // 返回值默认-

  const res = {
    browser: '-',
    brand: '-',
    os
  }; // 正则匹配一下browser name

  for (const [browser, browserReg] of browserMap) {
    if (browserReg.test(ua)) {
      res.browser = browser;
      break;
    }
  } // 正则匹配一下brand


  for (let [brand, brandReg] of Object.entries(brandMap)) {
    if (brandReg.test(ua)) {
      res.brand = brand;
      break;
    }
  }

  return res;
}

/**
 * @file 手机厂商market头规则
 * @author zhangsiyuan(zhangsiyuan@baidu.com)
 */
// 这里的匹配规则一定要从头到尾
// 存在优先级的
// [browser, brand, marketScheme]
const androidStoreRules = [// 三星不支持market协议,优先级最高
['*', 'samsung', 'samsungapps'], // 微博是白名单机制，所以优先级要高,除了三星
['weibo', '*', 'market'], // 手百是白名单机制，所以优先级要高
['baiduboxapp', '*', 'market'], ['baiduboxlite', '*', 'market'], ['tomas', '*', 'market'], // 小米 红米 uc 搜狗需要走mi 商店
['xiaomi', 'xiaomi', 'mimarket'], ['uc', 'xiaomi', 'mimarket'], ['sogou', 'xiaomi', 'mimarket'], // qq浏览器比较特殊，华为荣耀只能走market，不然多重调起容易没反应
['qqbrowser', 'huawei', 'market'], ['qqbrowser', 'honor', 'market'], // 华为 荣耀机型都走自己的应用商店
['*', 'huawei', 'appmarket'], ['*', 'honor', 'appmarket'], // oppo
['oppo', 'oppo', 'oppomarket'], ['uc', 'oppo', 'oppomarket'], ['sogou', 'oppo', 'oppomarket'], ['quark', 'oppo', 'oppomarket'], // vivo
['uc', 'vivo', 'vivomarket'], ['sogou', 'vivo', 'vivomarket']];

/**
 * @file 安卓应用商店调起协议
 * @author zhangsiyuan(zhangsiyuan@baidu.com)
 */
const marketMap = {
  mimarket: pkgName => `mimarket://details?id=${pkgName}&back=true`,
  appmarket: pkgName => `appmarket://details?id=${pkgName}&back=true`,
  oppomarket: pkgName => `oppomarket://details?packagename=${pkgName}`,
  vivomarket: pkgName => `vivomarket://details?id=${pkgName}`,
  samsungapps: pkgName => `samsungapps://ProductDetail/${pkgName}?back=1`,
  market: pkgName => `market://details?id=${pkgName}`
};

/**
 * 获得当前机型 调用安卓市场协议的scheme
 *
 */
function getMarketScheme(pkgName) {
  const {
    browser,
    brand
  } = getHostInfo();
  let marketScheme = `market://details?id=${pkgName}`;

  for (const [browserRule, brandRule, schemeName] of androidStoreRules) {
    if ((browserRule === '*' || browser === browserRule) && (brandRule === '*' || brand === brandRule)) {
      marketScheme = marketMap[schemeName](pkgName);
      break;
    }
  } // 贴吧特殊case
  // 贴吧专用协议,贴吧不加后面参数生效不了


  if (browser === 'tieba') {
    marketScheme += '&enable_tieba_native_open=1';
  }

  return marketScheme;
}

/**
 * @file invokeTypeRules
 * @author zhangsiyuan(zhangsiyuan@baidu.com)
 */
const notUlinkRules = [['weibo', 'baiduboxapp'], ['uc', 'baiduboxapp'], ['quark', 'baiduboxapp'], ['chrome', '*']]; // [browser,appName][]

const notIframeRules = [['uc', '*'], ['chrome', '*'], ['samsung', '*']]; // 工具函数，检测是否匹配某个规则

const matchRules = (rules, browser, appName) => rules.some(([browserRule, appNameRule]) => {
  return (browserRule === '*' || browserRule === browser) && (appNameRule === '*' || appNameRule === appName);
}); // ios系统，且版本》9.或者是个iapd  无所谓版本了


const matchIosWithVersion = IS_IOS && IOS_VERSION > 9 || IS_IPAD;
function matchedUlink(browser, appName) {
  const notUlink = matchRules(notUlinkRules, browser, appName); // ios系统支持，且不在notUlink名单中
  return matchIosWithVersion && !notUlink;
}
function notMatchedIframe(browser, appName) {
  return matchIosWithVersion || matchRules(notIframeRules, browser, appName);
}

/**
 * @file schema 调起
 * @author zhuzhibo <zhuzhibo@baidu.com>
 * @author zsy
 */

/**
 *
 * invokeAction包含了
 * 直接使用location = scheme
 * 和iframe两种方式
 *
 */
function invokeAction(scheme, appName) {
  const {
    browser
  } = getHostInfo(); // 注意这里的appName，如果以后有规则匹配
  // 要去确认下!!!会不会影响单独的api  invokeMarket!!!

  if (notMatchedIframe(browser, appName)) {
    window.top.location.href = scheme;
    return;
  } // 其余一律走iframe调起
  let node = document.createElement('iframe');
  node.style.display = 'none';
  node.src = scheme;
  const body = document.body;
  body.appendChild(node); // 销毁 iframe

  setTimeout(() => {
    body.removeChild(node); // @ts-ignore

    node = null;
  }, 0);
}

/**
 * @file 调起情况检测
 * @author zhuzhibo(zhuzhibo@baidu.com)
 * @author zsy
 */

/**
 * 调起情况检测
 *
 */
function checkInvoke(timeout) {
  return new Promise((resolve, reject) => {
    const timer = setTimeout(() => {
      // 如果visibilitychange事件不触发，但是state会变化
      // 这里可以兜底判断回调
      // 但是这种概率还是挺小的
      if (document.visibilityState === 'hidden') {
        clearTimeout(timer);
        resolve();
        return;
      }

      reject();
    }, timeout);
    document.addEventListener('visibilitychange', () => {
      if (document.visibilityState === 'hidden') {
        clearTimeout(timer);
        resolve();
      }
    });
  });
}

/**
 * @file 返回值列表
 * @author zhuzhibo(zhuzhibo@baidu.com)
 * @author zsy
 */
const Status = {
  TRY_JUMP: 90001,
  INVOKE_SUCCESS: 10000,
  APPSTORE_SUCCESS: 10001,
  APK_SUCCESS: 10002,
  YYB_SUCCESS: 10003,
  FAILEDURL_SUCCESS: 10004,
  COPY_FAILED: 20004,
  INVOKE_FAIL: 20005,
  NOT_SUPPORT_SYSTEM: 20006,
  INVOKE_APPSTORE_FAIL: 20007,
  INVOKE_ULINK_FAIL: 20008,
  APPNAME_NOT_SUPPORT: 20011,
  NOT_SUPPORT_WX_TAG: 20012,
  PARAMS_ERROR: 21000
};

/**
 * @file 调起类型
 * @author zhangsiyuan(zhangsiyuan@baidu.com)
 */
// 只有这5种情况会去尝试调起并且可能失败
// 需要标志不同的statusCode
// 所以这里要区分一下
// 像yyb这种就不需要了，直接就确定了只有调起yyb成功的code了
const InvokeType = {
  DEEPLINK: "deeplink",
  ULINK: "ulink",
  SCHEME: "scheme",
  NOT_TRY: "notTry",
  ANDROID_MARKET: "market"
};

/**
 * @file: utils.js
 * @des: 通用方法库
 * @author: zhangjiaqi03
 * @date: 2020-08-17 17:30:44
 * @last modified by:   zhangjiaqi03
 * @last modified time: 2020-08-17 17:30:44
 */

/**
 * 将给定对象转成序列化的 queryString
 *
 * @param {Object} query 待转换对象
 * @return {string} queryString
 */
function toQueryString(query) {
  const search = Object.keys(query).reduce((res, key) => {
    const value = query[key];
    res += '&' + key + '=' + encodeURIComponent(value);
    return res;
  }, '');
  return search.slice(1);
}
/**
 * 生成一个随机id
 *
 * @return {string} id
 */

function getId() {
  let str = '';
  const dict = 'abcdefghijklmnopqrstuvwxyz01234567890';

  for (let i = 0, length = 8; i < length; ++i) {
    str += dict[Math.floor(Math.random() * dict.length)];
  }

  return str;
}
/**
 * formatParams
 * copy from ug-swan-logger
 * @param {Object} params params入参
 *
 * @returns {Object} 返回转化后数据
*/

function formatParams(params) {
  let tmp = { ...params
  }; // 遍历params参数 保证最终传参都是string

  Object.keys(tmp).forEach(key => {
    let param = tmp[key];

    if (!param || typeof param === 'string') {
      return;
    }

    let paramType = customTypeof(param); // Error

    if (paramType === 'error') {
      tmp[key] = JSON.stringify(param, Object.getOwnPropertyNames(param));
    } // Event
    else if (paramType === 'event') {
        let type = param.target.localName;
        let link = '';

        switch (param.target.localName) {
          case 'script':
            // 脚本加载报错
            link = param.target.src;
            break;

          case 'link':
            // 样式文件加载报错
            link = param.target.href;
            break;

          case 'img':
            // 图片加载报错
            link = param.target.src;
            break;
        }

        tmp[key] = JSON.stringify({
          type,
          link
        });
      } // ErrorEvent
      else if (paramType === 'errorevent') {
          var _param$colno, _param$lineno;

          tmp[key] = JSON.stringify({
            error: customTypeof(param.error) === 'error' ? JSON.stringify(param.error, Object.getOwnPropertyNames(param.error)) : 'errorevent',
            colno: (_param$colno = param.colno) !== null && _param$colno !== void 0 ? _param$colno : '',
            lineno: (_param$lineno = param.lineno) !== null && _param$lineno !== void 0 ? _param$lineno : '',
            message: param.message || ''
          });
        } else {
          tmp[key] = JSON.stringify(param);
        }
  });
  return tmp;
}
/**
 * customTypeof
 * @param {any} obj 待检测类型的数据
 *
 * @returns {string} 数据类型字符串
*/

function customTypeof(obj) {
  return Object.prototype.toString.call(obj).slice(8, -1).toLowerCase();
}

/**
 * @file: index.js
 * @des: 用户增长h5错误日志打点库
 * @author: zhangjiaqi03
 * @date: 2020-08-17 17:20:40
 * @last modified by:   zhangjiaqi03
 * @last modified time: 2020-08-17 17:20:40
 */
const DEFAULT_CONFIG = {
  // 业务标识
  app: '',
  // 上报地址
  url: 'https://activity.baidu.com/activity/felog/error',
  // 监听页面错误，自动上报
  watch: true
};
/**
 * H5错误打点类
 */

class H5ErrLog {
  /**
   * 原型
   */
  constructor() {
    // 配置
    this.config = {}; // 参数是否校验通过

    this.isCheckedParams = true;
  }
  /**
   * 初始化配置
   *
   * @param {Object} config 初始化配置
   * @returns {void}
   */


  init(config = {}) {
    this.config = Object.assign({}, DEFAULT_CONFIG, config);

    if (!this.config.app) {
      this.isCheckedParams = false;
      console.error('[h5-error-log]: app参数必填~');
      return;
    } // 重置isCheckedParams，防止多次init


    this.isCheckedParams = true;

    if (this.config.watch) {
      this.watch();
    }

    delete this.config.watch;
  }
  /**
   * 监控页面报错并上报
   *
   * @returns {void}
   */


  watch() {
    window.addEventListener('error', e => {
      this.send({
        level: 'error',
        type: 'page',
        content: e
      });
    }, true); // 捕获为catch的异步错误

    window.addEventListener('unhandledrejection', event => {
      event.preventDefault();
      this.send({
        level: 'unhandledrejection',
        type: 'page',
        content: event.reason
      });
    });
  }
  /**
   * 日志发送
   *
   * @param {Object} errInfo 错误信息入参
   * @param {string} errInfo.level 日志等级 info/error
   * @param {string} errInfo.type 日志类型 net/app/api/...等
   * @param {string} errInfo.content 日志错误信息
   * @param {Object} errInfo.ext 日志额外信息
   * @param {string} errInfo.ext.errmsg 日志额外信息字符串
   * @param {boolean} useSendbeacon 使用Sendbeacon发送日志，默认关闭
   *
   * @returns {void}
   */


  send(errInfo = {
    level: 'info',
    type: '-',
    content: '-',
    ext: {
      errmsg: ''
    }
  }, useSendbeacon = false) {
    if (!this.isCheckedParams) {
      console.error('[h5-error-log]: 参数校验失败，请检查init参数');
      return;
    }

    let data = { ...this.config,
      ...errInfo
    };
    data.h5 = '1';
    delete data.url;
    let queryString = toQueryString(formatParams(data)); // 如果sendBeacon失败则使用loadImage方式

    if (!useSendbeacon || useSendbeacon && !this.sendBeacon(queryString)) {
      this.loadImage(queryString);
    }
  }
  /**
   * 发送图片请求
   *
   * @param {string} query 拼接成get请求字符串
   *
   * @returns {void}
   */


  loadImage(query) {
    let img = new Image();
    let imgId = '_img_' + getId();
    window[imgId] = img;

    img.onload = img.onerror = img.onabort = function () {
      img = img.onload = img.onerror = img.onabort = null;
      delete window[imgId];
    };

    img.src = this.config.url + '?' + query;
  }
  /**
   * 通过sendBeacon发送请求
   * @param {string} query 拼接成请求字符串
   *
   * @returns {void}
   */


  sendBeacon(query) {
    if ('sendBeacon' in navigator) {
      return navigator.sendBeacon(`${this.config.url}?${query}`);
    }

    return false;
  }

} // 默认导出new好的实例


var index = new H5ErrLog(); // 导出构造函数

var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

function createCommonjsModule(fn) {
  var module = { exports: {} };
	return fn(module, module.exports), module.exports;
}

/**
 * Check if we're required to add a port number.
 *
 * @see https://url.spec.whatwg.org/#default-port
 * @param {Number|String} port Port number we need to check
 * @param {String} protocol Protocol we need to check against.
 * @returns {Boolean} Is it a default port for the given protocol
 * @api private
 */
var requiresPort = function required(port, protocol) {
  protocol = protocol.split(':')[0];
  port = +port;

  if (!port) return false;

  switch (protocol) {
    case 'http':
    case 'ws':
    return port !== 80;

    case 'https':
    case 'wss':
    return port !== 443;

    case 'ftp':
    return port !== 21;

    case 'gopher':
    return port !== 70;

    case 'file':
    return false;
  }

  return port !== 0;
};

var has = Object.prototype.hasOwnProperty
  , undef;

/**
 * Decode a URI encoded string.
 *
 * @param {String} input The URI encoded string.
 * @returns {String|Null} The decoded string.
 * @api private
 */
function decode(input) {
  try {
    return decodeURIComponent(input.replace(/\+/g, ' '));
  } catch (e) {
    return null;
  }
}

/**
 * Simple query string parser.
 *
 * @param {String} query The query string that needs to be parsed.
 * @returns {Object}
 * @api public
 */
function querystring(query) {
  var parser = /([^=?&]+)=?([^&]*)/g
    , result = {}
    , part;

  while (part = parser.exec(query)) {
    var key = decode(part[1])
      , value = decode(part[2]);

    //
    // Prevent overriding of existing properties. This ensures that build-in
    // methods like `toString` or __proto__ are not overriden by malicious
    // querystrings.
    //
    // In the case if failed decoding, we want to omit the key/value pairs
    // from the result.
    //
    if (key === null || value === null || key in result) continue;
    result[key] = value;
  }

  return result;
}

/**
 * Transform a query string to an object.
 *
 * @param {Object} obj Object that should be transformed.
 * @param {String} prefix Optional prefix.
 * @returns {String}
 * @api public
 */
function querystringify(obj, prefix) {
  prefix = prefix || '';

  var pairs = []
    , value
    , key;

  //
  // Optionally prefix with a '?' if needed
  //
  if ('string' !== typeof prefix) prefix = '?';

  for (key in obj) {
    if (has.call(obj, key)) {
      value = obj[key];

      //
      // Edge cases where we actually want to encode the value to an empty
      // string instead of the stringified value.
      //
      if (!value && (value === null || value === undef || isNaN(value))) {
        value = '';
      }

      key = encodeURIComponent(key);
      value = encodeURIComponent(value);

      //
      // If we failed to encode the strings, we should bail out as we don't
      // want to add invalid strings to the query.
      //
      if (key === null || value === null) continue;
      pairs.push(key +'='+ value);
    }
  }

  return pairs.length ? prefix + pairs.join('&') : '';
}

//
// Expose the module.
//
var stringify = querystringify;
var parse = querystring;

var querystringify_1 = {
	stringify: stringify,
	parse: parse
};

var slashes = /^[A-Za-z][A-Za-z0-9+-.]*:\/\//
  , protocolre = /^([a-z][a-z0-9.+-]*:)?(\/\/)?([\S\s]*)/i
  , whitespace = '[\\x09\\x0A\\x0B\\x0C\\x0D\\x20\\xA0\\u1680\\u180E\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200A\\u202F\\u205F\\u3000\\u2028\\u2029\\uFEFF]'
  , left = new RegExp('^'+ whitespace +'+');

/**
 * Trim a given string.
 *
 * @param {String} str String to trim.
 * @public
 */
function trimLeft(str) {
  return (str ? str : '').toString().replace(left, '');
}

/**
 * These are the parse rules for the URL parser, it informs the parser
 * about:
 *
 * 0. The char it Needs to parse, if it's a string it should be done using
 *    indexOf, RegExp using exec and NaN means set as current value.
 * 1. The property we should set when parsing this value.
 * 2. Indication if it's backwards or forward parsing, when set as number it's
 *    the value of extra chars that should be split off.
 * 3. Inherit from location if non existing in the parser.
 * 4. `toLowerCase` the resulting value.
 */
var rules = [
  ['#', 'hash'],                        // Extract from the back.
  ['?', 'query'],                       // Extract from the back.
  function sanitize(address) {          // Sanitize what is left of the address
    return address.replace('\\', '/');
  },
  ['/', 'pathname'],                    // Extract from the back.
  ['@', 'auth', 1],                     // Extract from the front.
  [NaN, 'host', undefined, 1, 1],       // Set left over value.
  [/:(\d+)$/, 'port', undefined, 1],    // RegExp the back.
  [NaN, 'hostname', undefined, 1, 1]    // Set left over.
];

/**
 * These properties should not be copied or inherited from. This is only needed
 * for all non blob URL's as a blob URL does not include a hash, only the
 * origin.
 *
 * @type {Object}
 * @private
 */
var ignore = { hash: 1, query: 1 };

/**
 * The location object differs when your code is loaded through a normal page,
 * Worker or through a worker using a blob. And with the blobble begins the
 * trouble as the location object will contain the URL of the blob, not the
 * location of the page where our code is loaded in. The actual origin is
 * encoded in the `pathname` so we can thankfully generate a good "default"
 * location from it so we can generate proper relative URL's again.
 *
 * @param {Object|String} loc Optional default location object.
 * @returns {Object} lolcation object.
 * @public
 */
function lolcation(loc) {
  var globalVar;

  if (typeof window !== 'undefined') globalVar = window;
  else if (typeof commonjsGlobal !== 'undefined') globalVar = commonjsGlobal;
  else if (typeof self !== 'undefined') globalVar = self;
  else globalVar = {};

  var location = globalVar.location || {};
  loc = loc || location;

  var finaldestination = {}
    , type = typeof loc
    , key;

  if ('blob:' === loc.protocol) {
    finaldestination = new Url(unescape(loc.pathname), {});
  } else if ('string' === type) {
    finaldestination = new Url(loc, {});
    for (key in ignore) delete finaldestination[key];
  } else if ('object' === type) {
    for (key in loc) {
      if (key in ignore) continue;
      finaldestination[key] = loc[key];
    }

    if (finaldestination.slashes === undefined) {
      finaldestination.slashes = slashes.test(loc.href);
    }
  }

  return finaldestination;
}

/**
 * @typedef ProtocolExtract
 * @type Object
 * @property {String} protocol Protocol matched in the URL, in lowercase.
 * @property {Boolean} slashes `true` if protocol is followed by "//", else `false`.
 * @property {String} rest Rest of the URL that is not part of the protocol.
 */

/**
 * Extract protocol information from a URL with/without double slash ("//").
 *
 * @param {String} address URL we want to extract from.
 * @return {ProtocolExtract} Extracted information.
 * @private
 */
function extractProtocol(address) {
  address = trimLeft(address);
  var match = protocolre.exec(address);

  return {
    protocol: match[1] ? match[1].toLowerCase() : '',
    slashes: !!match[2],
    rest: match[3]
  };
}

/**
 * Resolve a relative URL pathname against a base URL pathname.
 *
 * @param {String} relative Pathname of the relative URL.
 * @param {String} base Pathname of the base URL.
 * @return {String} Resolved pathname.
 * @private
 */
function resolve(relative, base) {
  if (relative === '') return base;

  var path = (base || '/').split('/').slice(0, -1).concat(relative.split('/'))
    , i = path.length
    , last = path[i - 1]
    , unshift = false
    , up = 0;

  while (i--) {
    if (path[i] === '.') {
      path.splice(i, 1);
    } else if (path[i] === '..') {
      path.splice(i, 1);
      up++;
    } else if (up) {
      if (i === 0) unshift = true;
      path.splice(i, 1);
      up--;
    }
  }

  if (unshift) path.unshift('');
  if (last === '.' || last === '..') path.push('');

  return path.join('/');
}

/**
 * The actual URL instance. Instead of returning an object we've opted-in to
 * create an actual constructor as it's much more memory efficient and
 * faster and it pleases my OCD.
 *
 * It is worth noting that we should not use `URL` as class name to prevent
 * clashes with the global URL instance that got introduced in browsers.
 *
 * @constructor
 * @param {String} address URL we want to parse.
 * @param {Object|String} [location] Location defaults for relative paths.
 * @param {Boolean|Function} [parser] Parser for the query string.
 * @private
 */
function Url(address, location, parser) {
  address = trimLeft(address);

  if (!(this instanceof Url)) {
    return new Url(address, location, parser);
  }

  var relative, extracted, parse, instruction, index, key
    , instructions = rules.slice()
    , type = typeof location
    , url = this
    , i = 0;

  //
  // The following if statements allows this module two have compatibility with
  // 2 different API:
  //
  // 1. Node.js's `url.parse` api which accepts a URL, boolean as arguments
  //    where the boolean indicates that the query string should also be parsed.
  //
  // 2. The `URL` interface of the browser which accepts a URL, object as
  //    arguments. The supplied object will be used as default values / fall-back
  //    for relative paths.
  //
  if ('object' !== type && 'string' !== type) {
    parser = location;
    location = null;
  }

  if (parser && 'function' !== typeof parser) parser = querystringify_1.parse;

  location = lolcation(location);

  //
  // Extract protocol information before running the instructions.
  //
  extracted = extractProtocol(address || '');
  relative = !extracted.protocol && !extracted.slashes;
  url.slashes = extracted.slashes || relative && location.slashes;
  url.protocol = extracted.protocol || location.protocol || '';
  address = extracted.rest;

  //
  // When the authority component is absent the URL starts with a path
  // component.
  //
  if (!extracted.slashes) instructions[3] = [/(.*)/, 'pathname'];

  for (; i < instructions.length; i++) {
    instruction = instructions[i];

    if (typeof instruction === 'function') {
      address = instruction(address);
      continue;
    }

    parse = instruction[0];
    key = instruction[1];

    if (parse !== parse) {
      url[key] = address;
    } else if ('string' === typeof parse) {
      if (~(index = address.indexOf(parse))) {
        if ('number' === typeof instruction[2]) {
          url[key] = address.slice(0, index);
          address = address.slice(index + instruction[2]);
        } else {
          url[key] = address.slice(index);
          address = address.slice(0, index);
        }
      }
    } else if ((index = parse.exec(address))) {
      url[key] = index[1];
      address = address.slice(0, index.index);
    }

    url[key] = url[key] || (
      relative && instruction[3] ? location[key] || '' : ''
    );

    //
    // Hostname, host and protocol should be lowercased so they can be used to
    // create a proper `origin`.
    //
    if (instruction[4]) url[key] = url[key].toLowerCase();
  }

  //
  // Also parse the supplied query string in to an object. If we're supplied
  // with a custom parser as function use that instead of the default build-in
  // parser.
  //
  if (parser) url.query = parser(url.query);

  //
  // If the URL is relative, resolve the pathname against the base URL.
  //
  if (
      relative
    && location.slashes
    && url.pathname.charAt(0) !== '/'
    && (url.pathname !== '' || location.pathname !== '')
  ) {
    url.pathname = resolve(url.pathname, location.pathname);
  }

  //
  // We should not add port numbers if they are already the default port number
  // for a given protocol. As the host also contains the port number we're going
  // override it with the hostname which contains no port number.
  //
  if (!requiresPort(url.port, url.protocol)) {
    url.host = url.hostname;
    url.port = '';
  }

  //
  // Parse down the `auth` for the username and password.
  //
  url.username = url.password = '';
  if (url.auth) {
    instruction = url.auth.split(':');
    url.username = instruction[0] || '';
    url.password = instruction[1] || '';
  }

  url.origin = url.protocol && url.host && url.protocol !== 'file:'
    ? url.protocol +'//'+ url.host
    : 'null';

  //
  // The href is just the compiled result.
  //
  url.href = url.toString();
}

/**
 * This is convenience method for changing properties in the URL instance to
 * insure that they all propagate correctly.
 *
 * @param {String} part          Property we need to adjust.
 * @param {Mixed} value          The newly assigned value.
 * @param {Boolean|Function} fn  When setting the query, it will be the function
 *                               used to parse the query.
 *                               When setting the protocol, double slash will be
 *                               removed from the final url if it is true.
 * @returns {URL} URL instance for chaining.
 * @public
 */
function set(part, value, fn) {
  var url = this;

  switch (part) {
    case 'query':
      if ('string' === typeof value && value.length) {
        value = (fn || querystringify_1.parse)(value);
      }

      url[part] = value;
      break;

    case 'port':
      url[part] = value;

      if (!requiresPort(value, url.protocol)) {
        url.host = url.hostname;
        url[part] = '';
      } else if (value) {
        url.host = url.hostname +':'+ value;
      }

      break;

    case 'hostname':
      url[part] = value;

      if (url.port) value += ':'+ url.port;
      url.host = value;
      break;

    case 'host':
      url[part] = value;

      if (/:\d+$/.test(value)) {
        value = value.split(':');
        url.port = value.pop();
        url.hostname = value.join(':');
      } else {
        url.hostname = value;
        url.port = '';
      }

      break;

    case 'protocol':
      url.protocol = value.toLowerCase();
      url.slashes = !fn;
      break;

    case 'pathname':
    case 'hash':
      if (value) {
        var char = part === 'pathname' ? '/' : '#';
        url[part] = value.charAt(0) !== char ? char + value : value;
      } else {
        url[part] = value;
      }
      break;

    default:
      url[part] = value;
  }

  for (var i = 0; i < rules.length; i++) {
    var ins = rules[i];

    if (ins[4]) url[ins[1]] = url[ins[1]].toLowerCase();
  }

  url.origin = url.protocol && url.host && url.protocol !== 'file:'
    ? url.protocol +'//'+ url.host
    : 'null';

  url.href = url.toString();

  return url;
}

/**
 * Transform the properties back in to a valid and full URL string.
 *
 * @param {Function} stringify Optional query stringify function.
 * @returns {String} Compiled version of the URL.
 * @public
 */
function toString(stringify) {
  if (!stringify || 'function' !== typeof stringify) stringify = querystringify_1.stringify;

  var query
    , url = this
    , protocol = url.protocol;

  if (protocol && protocol.charAt(protocol.length - 1) !== ':') protocol += ':';

  var result = protocol + (url.slashes ? '//' : '');

  if (url.username) {
    result += url.username;
    if (url.password) result += ':'+ url.password;
    result += '@';
  }

  result += url.host + url.pathname;

  query = 'object' === typeof url.query ? stringify(url.query) : url.query;
  if (query) result += '?' !== query.charAt(0) ? '?'+ query : query;

  if (url.hash) result += url.hash;

  return result;
}

Url.prototype = { set: set, toString: toString };

//
// Expose the URL parser and some additional properties that might be useful for
// others or testing.
//
Url.extractProtocol = extractProtocol;
Url.location = lolcation;
Url.trimLeft = trimLeft;
Url.qs = querystringify_1;

var urlParse = Url;

var strictUriEncode = str => encodeURIComponent(str).replace(/[!'()*]/g, x => `%${x.charCodeAt(0).toString(16).toUpperCase()}`);

var token = '%[a-f0-9]{2}';
var singleMatcher = new RegExp(token, 'gi');
var multiMatcher = new RegExp('(' + token + ')+', 'gi');

function decodeComponents(components, split) {
	try {
		// Try to decode the entire string first
		return decodeURIComponent(components.join(''));
	} catch (err) {
		// Do nothing
	}

	if (components.length === 1) {
		return components;
	}

	split = split || 1;

	// Split the array in 2 parts
	var left = components.slice(0, split);
	var right = components.slice(split);

	return Array.prototype.concat.call([], decodeComponents(left), decodeComponents(right));
}

function decode$1(input) {
	try {
		return decodeURIComponent(input);
	} catch (err) {
		var tokens = input.match(singleMatcher);

		for (var i = 1; i < tokens.length; i++) {
			input = decodeComponents(tokens, i).join('');

			tokens = input.match(singleMatcher);
		}

		return input;
	}
}

function customDecodeURIComponent(input) {
	// Keep track of all the replacements and prefill the map with the `BOM`
	var replaceMap = {
		'%FE%FF': '\uFFFD\uFFFD',
		'%FF%FE': '\uFFFD\uFFFD'
	};

	var match = multiMatcher.exec(input);
	while (match) {
		try {
			// Decode as big chunks as possible
			replaceMap[match[0]] = decodeURIComponent(match[0]);
		} catch (err) {
			var result = decode$1(match[0]);

			if (result !== match[0]) {
				replaceMap[match[0]] = result;
			}
		}

		match = multiMatcher.exec(input);
	}

	// Add `%C2` at the end of the map to make sure it does not replace the combinator before everything else
	replaceMap['%C2'] = '\uFFFD';

	var entries = Object.keys(replaceMap);

	for (var i = 0; i < entries.length; i++) {
		// Replace all decoded components
		var key = entries[i];
		input = input.replace(new RegExp(key, 'g'), replaceMap[key]);
	}

	return input;
}

var decodeUriComponent = function (encodedURI) {
	if (typeof encodedURI !== 'string') {
		throw new TypeError('Expected `encodedURI` to be of type `string`, got `' + typeof encodedURI + '`');
	}

	try {
		encodedURI = encodedURI.replace(/\+/g, ' ');

		// Try the built in decoder first
		return decodeURIComponent(encodedURI);
	} catch (err) {
		// Fallback to a more advanced decoder
		return customDecodeURIComponent(encodedURI);
	}
};

var splitOnFirst = (string, separator) => {
	if (!(typeof string === 'string' && typeof separator === 'string')) {
		throw new TypeError('Expected the arguments to be of type `string`');
	}

	if (separator === '') {
		return [string];
	}

	const separatorIndex = string.indexOf(separator);

	if (separatorIndex === -1) {
		return [string];
	}

	return [
		string.slice(0, separatorIndex),
		string.slice(separatorIndex + separator.length)
	];
};

var queryString = createCommonjsModule(function (module, exports) {




const isNullOrUndefined = value => value === null || value === undefined;

function encoderForArrayFormat(options) {
	switch (options.arrayFormat) {
		case 'index':
			return key => (result, value) => {
				const index = result.length;

				if (
					value === undefined ||
					(options.skipNull && value === null) ||
					(options.skipEmptyString && value === '')
				) {
					return result;
				}

				if (value === null) {
					return [...result, [encode(key, options), '[', index, ']'].join('')];
				}

				return [
					...result,
					[encode(key, options), '[', encode(index, options), ']=', encode(value, options)].join('')
				];
			};

		case 'bracket':
			return key => (result, value) => {
				if (
					value === undefined ||
					(options.skipNull && value === null) ||
					(options.skipEmptyString && value === '')
				) {
					return result;
				}

				if (value === null) {
					return [...result, [encode(key, options), '[]'].join('')];
				}

				return [...result, [encode(key, options), '[]=', encode(value, options)].join('')];
			};

		case 'comma':
		case 'separator':
			return key => (result, value) => {
				if (value === null || value === undefined || value.length === 0) {
					return result;
				}

				if (result.length === 0) {
					return [[encode(key, options), '=', encode(value, options)].join('')];
				}

				return [[result, encode(value, options)].join(options.arrayFormatSeparator)];
			};

		default:
			return key => (result, value) => {
				if (
					value === undefined ||
					(options.skipNull && value === null) ||
					(options.skipEmptyString && value === '')
				) {
					return result;
				}

				if (value === null) {
					return [...result, encode(key, options)];
				}

				return [...result, [encode(key, options), '=', encode(value, options)].join('')];
			};
	}
}

function parserForArrayFormat(options) {
	let result;

	switch (options.arrayFormat) {
		case 'index':
			return (key, value, accumulator) => {
				result = /\[(\d*)\]$/.exec(key);

				key = key.replace(/\[\d*\]$/, '');

				if (!result) {
					accumulator[key] = value;
					return;
				}

				if (accumulator[key] === undefined) {
					accumulator[key] = {};
				}

				accumulator[key][result[1]] = value;
			};

		case 'bracket':
			return (key, value, accumulator) => {
				result = /(\[\])$/.exec(key);
				key = key.replace(/\[\]$/, '');

				if (!result) {
					accumulator[key] = value;
					return;
				}

				if (accumulator[key] === undefined) {
					accumulator[key] = [value];
					return;
				}

				accumulator[key] = [].concat(accumulator[key], value);
			};

		case 'comma':
		case 'separator':
			return (key, value, accumulator) => {
				const isArray = typeof value === 'string' && value.includes(options.arrayFormatSeparator);
				const isEncodedArray = (typeof value === 'string' && !isArray && decode(value, options).includes(options.arrayFormatSeparator));
				value = isEncodedArray ? decode(value, options) : value;
				const newValue = isArray || isEncodedArray ? value.split(options.arrayFormatSeparator).map(item => decode(item, options)) : value === null ? value : decode(value, options);
				accumulator[key] = newValue;
			};

		default:
			return (key, value, accumulator) => {
				if (accumulator[key] === undefined) {
					accumulator[key] = value;
					return;
				}

				accumulator[key] = [].concat(accumulator[key], value);
			};
	}
}

function validateArrayFormatSeparator(value) {
	if (typeof value !== 'string' || value.length !== 1) {
		throw new TypeError('arrayFormatSeparator must be single character string');
	}
}

function encode(value, options) {
	if (options.encode) {
		return options.strict ? strictUriEncode(value) : encodeURIComponent(value);
	}

	return value;
}

function decode(value, options) {
	if (options.decode) {
		return decodeUriComponent(value);
	}

	return value;
}

function keysSorter(input) {
	if (Array.isArray(input)) {
		return input.sort();
	}

	if (typeof input === 'object') {
		return keysSorter(Object.keys(input))
			.sort((a, b) => Number(a) - Number(b))
			.map(key => input[key]);
	}

	return input;
}

function removeHash(input) {
	const hashStart = input.indexOf('#');
	if (hashStart !== -1) {
		input = input.slice(0, hashStart);
	}

	return input;
}

function getHash(url) {
	let hash = '';
	const hashStart = url.indexOf('#');
	if (hashStart !== -1) {
		hash = url.slice(hashStart);
	}

	return hash;
}

function extract(input) {
	input = removeHash(input);
	const queryStart = input.indexOf('?');
	if (queryStart === -1) {
		return '';
	}

	return input.slice(queryStart + 1);
}

function parseValue(value, options) {
	if (options.parseNumbers && !Number.isNaN(Number(value)) && (typeof value === 'string' && value.trim() !== '')) {
		value = Number(value);
	} else if (options.parseBooleans && value !== null && (value.toLowerCase() === 'true' || value.toLowerCase() === 'false')) {
		value = value.toLowerCase() === 'true';
	}

	return value;
}

function parse(query, options) {
	options = Object.assign({
		decode: true,
		sort: true,
		arrayFormat: 'none',
		arrayFormatSeparator: ',',
		parseNumbers: false,
		parseBooleans: false
	}, options);

	validateArrayFormatSeparator(options.arrayFormatSeparator);

	const formatter = parserForArrayFormat(options);

	// Create an object with no prototype
	const ret = Object.create(null);

	if (typeof query !== 'string') {
		return ret;
	}

	query = query.trim().replace(/^[?#&]/, '');

	if (!query) {
		return ret;
	}

	for (const param of query.split('&')) {
		let [key, value] = splitOnFirst(options.decode ? param.replace(/\+/g, ' ') : param, '=');

		// Missing `=` should be `null`:
		// http://w3.org/TR/2012/WD-url-20120524/#collect-url-parameters
		value = value === undefined ? null : ['comma', 'separator'].includes(options.arrayFormat) ? value : decode(value, options);
		formatter(decode(key, options), value, ret);
	}

	for (const key of Object.keys(ret)) {
		const value = ret[key];
		if (typeof value === 'object' && value !== null) {
			for (const k of Object.keys(value)) {
				value[k] = parseValue(value[k], options);
			}
		} else {
			ret[key] = parseValue(value, options);
		}
	}

	if (options.sort === false) {
		return ret;
	}

	return (options.sort === true ? Object.keys(ret).sort() : Object.keys(ret).sort(options.sort)).reduce((result, key) => {
		const value = ret[key];
		if (Boolean(value) && typeof value === 'object' && !Array.isArray(value)) {
			// Sort object keys, not values
			result[key] = keysSorter(value);
		} else {
			result[key] = value;
		}

		return result;
	}, Object.create(null));
}

exports.extract = extract;
exports.parse = parse;

exports.stringify = (object, options) => {
	if (!object) {
		return '';
	}

	options = Object.assign({
		encode: true,
		strict: true,
		arrayFormat: 'none',
		arrayFormatSeparator: ','
	}, options);

	validateArrayFormatSeparator(options.arrayFormatSeparator);

	const shouldFilter = key => (
		(options.skipNull && isNullOrUndefined(object[key])) ||
		(options.skipEmptyString && object[key] === '')
	);

	const formatter = encoderForArrayFormat(options);

	const objectCopy = {};

	for (const key of Object.keys(object)) {
		if (!shouldFilter(key)) {
			objectCopy[key] = object[key];
		}
	}

	const keys = Object.keys(objectCopy);

	if (options.sort !== false) {
		keys.sort(options.sort);
	}

	return keys.map(key => {
		const value = object[key];

		if (value === undefined) {
			return '';
		}

		if (value === null) {
			return encode(key, options);
		}

		if (Array.isArray(value)) {
			return value
				.reduce(formatter(key), [])
				.join('&');
		}

		return encode(key, options) + '=' + encode(value, options);
	}).filter(x => x.length > 0).join('&');
};

exports.parseUrl = (url, options) => {
	options = Object.assign({
		decode: true
	}, options);

	const [url_, hash] = splitOnFirst(url, '#');

	return Object.assign(
		{
			url: url_.split('?')[0] || '',
			query: parse(extract(url), options)
		},
		options && options.parseFragmentIdentifier && hash ? {fragmentIdentifier: decode(hash, options)} : {}
	);
};

exports.stringifyUrl = (object, options) => {
	options = Object.assign({
		encode: true,
		strict: true
	}, options);

	const url = removeHash(object.url).split('?')[0] || '';
	const queryFromUrl = exports.extract(object.url);
	const parsedQueryFromUrl = exports.parse(queryFromUrl, {sort: false});

	const query = Object.assign(parsedQueryFromUrl, object.query);
	let queryString = exports.stringify(query, options);
	if (queryString) {
		queryString = `?${queryString}`;
	}

	let hash = getHash(object.url);
	if (object.fragmentIdentifier) {
		hash = `#${encode(object.fragmentIdentifier, options)}`;
	}

	return `${url}${queryString}${hash}`;
};
});

/**
 * @file send error
 * @author zhangsiyuan(zhangsiyuan@baidu.com)
 */
index.init({
  url: 'https://activity.baidu.com/activity/felog/log',
  app: 'ug-invoke-app_prod02',
  watch: false
});
function getRandomNumber() {
  return Math.floor(100 * Math.random());
} // 当次调起  是否命中抽样
// query上_uia_h=1参数优先级最高
// 或者计算抽样比例

function isHit(statRatio) {
  let url = new urlParse(window.location.href);
  let query = queryString.parse(url.query) || {};
  return query._uia_h === '1' || getRandomNumber() < statRatio;
}
/**
 *
 *
 * ug-invoke-app行为统计打点
 * 尝试调起
 * 异常报错
 * 调起成功、失败、应用商店等
 * status必须传，其他的会根据invokeapp第一次进入的时候的缓存发出
 * 如果有单次覆盖参数，可以在这个方法里传，不影响缓存
 *
 *
 */

function sendH5ErrLog(options, status, useSendBeacon = true) {
  if (options.isHitStat) {
    // 前面这三个不需要打点了
    const {
      marketScheme,
      isHitStat,
      pkgName,
      ...rest
    } = options;
    const uiaVer = window.__UIA_VERSION__ || '-';
    index.send({ ...rest,
      uiaVer,

      /* eslint-disable */
      _uia_status: status
      /* eslint-enable */

    }, useSendBeacon);
  }
}

/**
 * @file 尝试调起失败处理
 * @author zhangsiyuan(zhangsiyuan@baidu.com)
 */
async function handleInvokeFailed(options, invokeType) {
  // 之所以sendH5Errlog不在最后处理
  // 是因为跳页面就销毁上下文，打点一定要在跳转前发出
  if (invokeType === InvokeType.ULINK) {
    sendH5ErrLog(options, Status.INVOKE_ULINK_FAIL);
    return Promise.reject(Status.INVOKE_ULINK_FAIL);
  }

  if (options.toStore) {
    if (IS_ANDROID && invokeType !== InvokeType.ANDROID_MARKET) {
      return invokeAndroidMarket(options);
    } else if (IS_IOS && options.iosStoreUrl) {
      sendH5ErrLog(options, Status.APPSTORE_SUCCESS);
      location.href = options.iosStoreUrl;
      return Status.APPSTORE_SUCCESS;
    }
  }

  if (IS_ANDROID && options.apkUrl) {
    sendH5ErrLog(options, Status.APK_SUCCESS);
    location.href = options.apkUrl;
    return Status.APK_SUCCESS;
  }

  if (options.failedUrl) {
    sendH5ErrLog(options, Status.FAILEDURL_SUCCESS);
    location.href = options.failedUrl;
    return Status.FAILEDURL_SUCCESS;
  } // 前面已经处理过android去market的场景
  // 还能进入这里，说明安卓调起应用商店失败了


  if (options.toStore && IS_ANDROID && invokeType === InvokeType.ANDROID_MARKET) {
    sendH5ErrLog(options, Status.INVOKE_APPSTORE_FAIL);
    return Promise.reject(Status.INVOKE_APPSTORE_FAIL);
  }

  sendH5ErrLog(options, Status.INVOKE_FAIL);
  return Promise.reject(Status.INVOKE_FAIL);
}

/**
 * @file invoke 类型
 * @author zhangsiyuan(zhangsiyuan@baidu.com)
 */
async function invokeWithType(options, invokeType) {

  if (invokeType === InvokeType.ULINK) {
    // 贴吧调起其他端ulink需要拼一个参数，对值没要求[旺柴]
    if (getHostInfo().browser === 'tieba') {
      options.ulink += '&_client_version=250';
    }
    window.top.location.href = options.ulink;
  } else if (invokeType === InvokeType.ANDROID_MARKET && options.marketScheme) {
    invokeAction(options.marketScheme, options.appName);
  } else if (invokeType === InvokeType.SCHEME) {
    invokeAction(options.scheme, options.appName);
  }

  try {
    await checkInvoke(options.timeout);
    const status = invokeType === InvokeType.ANDROID_MARKET ? Status.APPSTORE_SUCCESS : Status.INVOKE_SUCCESS;
    sendH5ErrLog(options, status);
    return status;
  } catch (e) {
    return handleInvokeFailed(options, invokeType);
  }
}

/**
 * @file 调起应用商店
 * @author zhuzhibo(zhuzhibo@baidu.com)
 */

async function invokeAndroidMarket(options) {
  options.marketScheme = getMarketScheme(options.pkgName);
  return invokeWithType(options, InvokeType.ANDROID_MARKET);
} // 专门给外边人写的单独的api

async function invokeMarket(pkgName, timeout = 2000) {
  const scheme = getMarketScheme(pkgName); // 函数签名需要一个AppName，但其实invokeMarket并不会用到
  // 所以这里随意传入一个好了了

  invokeAction(scheme, 'baiduinput');

  try {
    await checkInvoke(timeout);
    return Status.APPSTORE_SUCCESS;
  } catch (e) {
    return Promise.reject(Status.INVOKE_APPSTORE_FAIL);
  }
}

/**
 * @file appconfig
 * @author zhangsiyuan(zhangsiyuan@baidu.com)
 * @see http://agroup.baidu.com/ceug-fe/md/article/2799135
 */
// 兼容一下第三方的appName名字
const appConfigMap = {
  baiduboxapp: {
    getUlink(scheme, target) {
      return `https://boxer.baidu.com/scheme?scheme=${encodeURIComponent(scheme)}&target=${encodeURIComponent(target)}`;
    },

    appStoreUrl: 'https://itunes.apple.com/cn/app/id382201985?mt=8',
    scheme: 'baiduboxapp://v11/appTab/select?item=home&upgrade=0',
    pkgName: 'com.baidu.searchbox',
    wxAppid: 'wx3fcdd8310a136ff8'
  },
  baiduboxlite: {
    getUlink(scheme, target) {
      return `https://wakeup.baidu.com/baiduboxlite/scheme?scheme=${encodeURIComponent(scheme)}&target=${encodeURIComponent(target)}`;
    },

    appStoreUrl: 'https://itunes.apple.com/cn/app/id1281873118?mt=8',
    scheme: 'baiduboxlite://v11/appTab/select?item=home&upgrade=0',
    pkgName: 'com.baidu.searchbox.lite'
  },
  baiduhaokan: {
    getUlink(scheme, target) {
      const path = scheme.replace('baiduhaokan://', '');
      const hasQuestionMark = path.includes('?');
      return 'https://hku.baidu.com/h5/share/s/' + path + (hasQuestionMark ? '&' : '?') + `target=${encodeURIComponent(target)}`;
    },

    appStoreUrl: 'https://itunes.apple.com/cn/app/bai-du-hao-kan/id1092031003',
    scheme: 'baiduhaokan://home/index',
    pkgName: 'com.baidu.haokan'
  },
  bdminivideo: {
    getUlink(scheme, target) {
      return `https://vv.baidu.com/feedvideoui/ulink?scheme=${encodeURIComponent(scheme)}&target=${encodeURIComponent(target)}`;
    },

    appStoreUrl: 'https://itunes.apple.com/cn/app/%E5%85%A8%E6%B0%91%E5%B0%8F%E8%A7%86%E9%A2%91/id1329385145?mt=8',
    scheme: 'bdminivideo://home/index',
    pkgName: 'com.baidu.minivideo'
  },
  tieba: {
    appStoreUrl: 'https://itunes.apple.com/app/apple-store/id477927812?pt=328057&ct=bottom_layer&mt=8',
    pkgName: 'com.baidu.tieba',

    // 贴吧没有提供ulink
    getUlink() {
      return '';
    },

    scheme: 'com.baidu.tieba://unidispatch/homepage',
    wxAppid: 'wx289a8c58bca4c71e'
  },
  bdnetdisk: {
    getUlink(scheme, target) {
      return `https://snsyun.baidu.com/wap/snsdeeplink?scheme=${encodeURIComponent(scheme)}&target=${encodeURIComponent(target)}`;
    },

    pkgName: 'com.baidu.netdisk',
    appStoreUrl: 'https://itunes.apple.com/cn/app/%E7%99%BE%E5%BA%A6%E7%BD%91%E7%9B%98/id547166701?mt=8',
    scheme: 'bdnetdisk://n/action.EXTERNAL_ACTIVITY?m_n_v=10.0.20',
    wxAppid: 'wx65cffe5f882034d1'
  },
  iqiyi: {
    getUlink() {
      return '';
    },

    pkgName: 'com.qiyi.video',
    appStoreUrl: 'https://apps.apple.com/cn/app/id393765873',
    scheme: 'iqiyi://'
  },
  baidumap: {
    getUlink(scheme, target) {
      return `https://clientmap.baidu.com/map/maplink.php?cburl=${encodeURIComponent(target)}&openapi=${encodeURIComponent(scheme)}`;
    },

    appStoreUrl: 'https://itunes.apple.com/cn/app/id452186370',
    scheme: 'baidumap://map?src=uginvoke',
    pkgName: 'com.baidu.BaiduMap'
  },
  bddrama: {
    getUlink(scheme, target) {
      return `https://ulinkmvideo.baidu.com/wisedrama/system/ulink?scheme=${encodeURIComponent(scheme)}&target=${encodeURIComponent(target)}`;
    },

    appStoreUrl: 'https://apps.apple.com/cn/app/%E7%95%AA%E4%B9%90/id1484301936',
    pkgName: 'com.baidu.mv.drama',
    scheme: 'bddrama://home?source='
  },
  wenku: {
    getUlink() {
      return '';
    },

    appStoreUrl: 'https://apps.apple.com/cn/app/id426340811',
    pkgName: 'com.baidu.wenku',
    scheme: 'bdwenku://wenku/operation?type=136&tab=find'
  },
  lemon: {
    getUlink(scheme, target) {
      return `https://wakeup.baidu.com/lemonapp/scheme?scheme=${encodeURIComponent(scheme)}&target=${encodeURIComponent(target)}`;
    },

    appStoreUrl: 'http://click.hm.baidu.com/app.gif?ap=1801081&ch=47556',
    scheme: 'lemon://share?type=13',
    pkgName: 'com.baidu.lemon'
  },
  baiduinput: {
    // 百度输入法不支持失败后跳转链接
    getUlink(scheme) {
      return `https://srf.baidu.com/?from=1024129m&c=apple&e=imehd&native_url=${encodeURIComponent(scheme)}`;
    },

    appStoreUrl: 'https://itunes.apple.com/app/apple-store/id916139408?pt=625805&ct=1024129m&mt=8',
    scheme: 'baiduimsettings2://superskin',
    pkgName: 'com.baidu.input'
  },
  baiduboxvision: {
    getUlink(scheme, target) {
      return `https://wakeup.baidu.com/baiduboxvision/scheme?scheme=${encodeURIComponent(scheme)}&target=${encodeURIComponent(target)}`;
    },

    appStoreUrl: 'https://apps.apple.com/cn/app/id1526110789',
    scheme: 'baiduboxvision://appTab/select?item=home',
    pkgName: 'com.baidu.searchbox.vision'
  },
  weibaapp: {
    getUlink() {
      return '';
    },

    appStoreUrl: 'https://apps.apple.com/cn/app/%E5%BE%AE%E5%8F%AD/id1410178720',
    scheme: 'lazybd://com.melon.lazymelon/home',
    pkgName: 'com.melon.lazymelon'
  },
  youjia: {
    getUlink() {
      return '';
    },

    appStoreUrl: 'https://apps.apple.com/cn/app/id1490227077',
    scheme: 'youjia://app/homepage',
    pkgName: 'com.baidu.autocar'
  },
  askmybaby: {
    getUlink() {
      return '';
    },

    appStoreUrl: 'https://apps.apple.com/cn/app/%E5%AE%9D%E5%AE%9D%E7%9F%A5%E9%81%93-%E7%A7%91%E5%AD%A6%E5%A4%87%E5%AD%95%E6%80%80%E5%AD%95%E8%82%B2%E5%84%BF%E5%8A%A9%E6%89%8B/id858401906',
    scheme: 'askmybaby://com.baidu.mbaby/',
    pkgName: 'com.baidu.mbaby'
  },
  yike: {
    // 一刻相册不支持失败后跳转链接
    getUlink(scheme) {
      return `https://photo.baidu.com/app/scheme?&scheme=${encodeURIComponent(scheme)}`;
    },

    appStoreUrl: 'https://apps.apple.com/cn/app/%E4%B8%80%E5%88%BB%E7%9B%B8%E5%86%8C-%E7%99%BE%E5%BA%A6%E7%BD%91%E7%9B%98%E5%87%BA%E5%93%81/id1467852587',
    scheme: 'youa://youa.com/home',
    pkgName: 'com.baidu.youavideo'
  },
  baiduhanyu: {
    getUlink(scheme, target) {
      return `https://wakeup.baidu.com/baidudict/scheme?scheme=${encodeURIComponent(scheme)}&target=${encodeURIComponent(target)}`;
    },

    appStoreUrl: 'https://apps.apple.com/cn/app/1/id1065829176',
    scheme: 'baidudict://com.baidu.dict',
    pkgName: 'com.baidu.dict'
  },
  yoopu: {
    getUlink(scheme, target) {
      return `https://wakeup.baidu.com/yoopu/scheme?scheme=${encodeURIComponent(scheme)}&target=${encodeURIComponent(target)}`;
    },

    appStoreUrl: 'https://itunes.apple.com/cn/app/id1533615786?mt=8',
    scheme: 'yoopu://',
    pkgName: 'com.baidu.yoopu'
  },
  tomas: {
    getUlink(scheme, target) {
      return `https://wakeup.baidu.com/tomas/scheme?scheme=${encodeURIComponent(scheme)}&target=${encodeURIComponent(target)}`;
    },

    appStoreUrl: 'https://apps.apple.com/cn/app/id1546173008',
    scheme: 'tomas://',
    pkgName: 'com.baidu.searchbox.tomas'
  },
  fortunecat: {
    getUlink(scheme, target) {
      return `https://wakeup.baidu.com/fortunecat/scheme?scheme=${encodeURIComponent(scheme)}&target=${encodeURIComponent(target)}`;
    },

    appStoreUrl: 'https://apps.apple.com/cn/app/id1523487452',
    scheme: 'fortunecat://invoke?p=%7B%22type%22%3A0%2C%22source%22%3A1%7D&ubc_ext=%7B%22invoke_channel%22%3A%221024634f%22%7D',
    pkgName: 'com.baidu.fortunecat'
  },
  yiju: {
    getUlink(scheme, target) {
      return `https://ulinkmvideo.baidu.com/yiju/system/ulink?scheme=${encodeURIComponent(scheme)}&target=${encodeURIComponent(target)}`;
    },

    appStoreUrl: 'https://apps.apple.com/cn/app/id1548246673',
    scheme: 'bdyiju://home/index',
    pkgName: 'com.baidu.yiju'
  },
  bdhealthapp: {
    getUlink(scheme, target) {
      return `https://jiankang.baidu.com/scheme?scheme=${encodeURIComponent(scheme)}&target=${encodeURIComponent(target)}`;
    },

    appStoreUrl: 'https://apps.apple.com/cn/app/id1555616850',
    scheme: 'bdhealthapp://app/home',
    pkgName: 'com.baidu.bdhealth'
  },
  bdwkst: {
    getUlink() {
      return '';
    },

    appStoreUrl: 'https://apps.apple.com/cn/app/id1527030248',
    scheme: 'bdwkst://student/operation?type=136',
    pkgName: 'com.baidu.student'
  },
  rap: {
    getUlink(scheme, target) {
      return `https://ulinkmvideo.baidu.com/wisedrama/system/yinciulink?scheme=${encodeURIComponent(scheme)}&target=${encodeURIComponent(target)}`;
    },

    appStoreUrl: 'https://apps.apple.com/cn/app/id1528455665',
    scheme: 'bdhiphop://',
    pkgName: 'com.baidu.rap'
  },
  wepod: {
    getUlink(scheme, target) {
      return `https://ulinkmvideo.baidu.com/wisedrama/system/wepodulink?scheme=${encodeURIComponent(scheme)}&target=${encodeURIComponent(target)}`;
    },

    appStoreUrl: 'https://apps.apple.com/cn/app/id1541812473',
    scheme: 'bdwepod://',
    pkgName: 'com.baidu.wepod'
  },
  yymobile: {
    getUlink(scheme) {
      return `https://ulink.yy.com/urlscheme?type=scheme&action=${encodeURIComponent(scheme)}&autodownload=1`;
    },

    appStoreUrl: 'https://apps.apple.com/app/id427941017',
    scheme: 'yymobile://',
    pkgName: 'com.duowan.mobile'
  },
  baiduboxsenior: {
    getUlink(scheme, target) {
      return `https://wakeup.baidu.com/baiduboxsenior/scheme?scheme=${encodeURIComponent(scheme)}&target=${encodeURIComponent(target)}`;
    },

    appStoreUrl: 'https://apps.apple.com/cn/app/id1581796662',
    scheme: 'baiduboxsenior://v11/appTab/select?item=home&upgrade=0',
    pkgName: 'com.baidu.searchbox.senior'
  },
  knews: {
    getUlink() {
      return '';
    },

    appStoreUrl: '',
    scheme: 'knews://v11/appTab/select?item=home&upgrade=0',
    pkgName: 'com.miui.knews'
  },
  xiaoduapp: {
    getUlink(scheme, target) {
      return `https://wakeup.baidu.com/xiaoduapp/scheme?scheme=${encodeURIComponent(scheme)}&target=${encodeURIComponent(target)}`;
    },

    appStoreUrl: 'https://itunes.apple.com/cn/app/%E5%B0%8F%E5%BA%A6%E8%93%9D%E7%89%99/id1437733193?mt=8',
    scheme: 'xiaoduapp://',
    pkgName: 'com.baidu.duer.superapp'
  }
};

/**
 * @file 生成唯一id
 * @see https://github.com/baidu/san/blob/master/src/util/guid.js
 * @author weijiaxun <weijiaxun@baidu.com>
 */
/**
 * 唯一id的起始值
 *
 * @inner
 * @type {number}
 */
var guidIndex = 1;
/**
 * 唯一id的前缀
 *
 * @inner
 * @type {string}
 */
var guidPrefix = ((new Date()).getTime() + Math.floor((Math.random() * 100000000) + 1)).toString(16).slice(8);
/**
 * 获取唯一id
 *
 * @inner
 * @return {string} 唯一id
 */
function getId$1() {
    return '_' + guidPrefix + (guidIndex++);
}

/**
 * @file 创建全局函数
 * @author weijiaxun <weijiaxun@baidu.com>
 */
/**
 * 将传入函数转换成全局函数，返回其全局名称字符串
 *
 * @param {Function} func query 对象
 * @return {string} 将 function 字符串化后的 query 对象
 */
function toGlobalFunc(func) {
    var funcName = getId$1();
    window[funcName] = function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        return func.apply(window, ([]).slice.call(args, 0));
    };
    return funcName;
}

/**
 * @file 判断变量类型
 * @author weijiaxun <weijiaxun@baidu.com>
 */
/**
 * 获取变量类型
 *
 * @param {*} value 待验变量
 * @return {string} 类型字符串
 */
function getVariableType(value) {
    var typeString = Object.prototype.toString.call(value);
    var match = typeString.match(/\[object ([A-z]+)\]/);
    return match ? match[1].toLowerCase() : '';
}

/**
 * @file 将参数列表转换为纯 string 类型的列表
 * @author weijiaxun <weijiaxun@baidu.com>
 */
/**
 * 将参数列表字符串化
 *
 * @param {Array} args 参数列表
 * @param {boolean} stringify 是否使用 JSON.stringify 处理 value 中的对象
 * @return {Array<string>} 字符串化的参数列表
 */
function stringifyArgs(args, stringify) {
    if (stringify === void 0) { stringify = true; }
    return args.map(function (arg) {
        var type = getVariableType(arg);
        switch (type) {
            case 'string':
                return arg;
            case 'function':
                return toGlobalFunc(arg);
            default:
                return stringify ? JSON.stringify(arg) : arg;
        }
    });
}

/**
 * @file 将 query 请求对象字符串化
 * @author weijiaxun <weijiaxun@baidu.com>
 */
/**
 * 将 query 请求对象中的 value 全部转换成 string 类型
 *
 * @param {Object} query query 对象
 * @param {boolean} stringify 是否使用 JSON.stringify 处理 value 中的对象
 * @return {Object} 转换后的 query 对象
 */
var stringifyQuery = function (query, stringify) {
    if (query === void 0) { query = {}; }
    if (stringify === void 0) { stringify = true; }
    return Object
        .keys(query).reduce(function (result, key) {
        var value = query[key];
        switch (getVariableType(value)) {
            case 'null':
            case 'undefined':
                result[key] = '';
                break;
            case 'array':
                result[key] = stringify
                    ? JSON.stringify(stringifyArgs(value, false))
                    : stringifyArgs(value, false);
                break;
            case 'object':
                result[key] = stringify
                    ? JSON.stringify(stringifyQuery(value, false))
                    : stringifyQuery(value, false);
                break;
            case 'function':
                result[key] = toGlobalFunc(value);
                break;
            default:
                result[key] = value;
        }
        return result;
    }, {});
};

/**
 * @file 将给定对象转成序列化的 queryString
 * @author weijiaxun <weijiaxun@baidu.com>
 */
/**
 * 将给定对象转成序列化的 queryString
 *
 * @param {Object} query 待转换对象
 * @return {string} queryString
 */
function toQueryString$1(query) {
    var search = Object.keys(query)
        .reduce(function (res, key) {
        var value = query[key];
        res += '&' + key + '=' + encodeURIComponent(value);
        return res;
    }, '');
    return search.slice(1);
}

/**
 * @file deeplink map
 * @author zhangsiyuan(zhangsiyuan@baidu.com)
 */
// 手百
const boxDeeplinkConfig = {
  getScheme(appUrl, callback) {
    return 'baiduboxapp://v7/vendor/ad/deeplink?' + `${toQueryString$1(stringifyQuery({
      params: {
        appUrl
      }
    }))}` + `&callback=${toGlobalFunc(callback)}`;
  },

  successCode: 0
}; // 百度看看

const baiduboxvision = {
  getScheme(appUrl, callback) {
    return 'baiduboxvision://v7/vendor/ad/deeplink?' + `${toQueryString$1(stringifyQuery({
      params: {
        appUrl
      }
    }))}` + `&callback=${toGlobalFunc(callback)}`;
  },

  successCode: 0
}; // 全民

const bdminivideo = {
  getScheme(appUrl, callback) {
    return 'bdminivideo://growth/launch3rdApp?' + toQueryString$1(stringifyQuery({
      callback: callback,
      params: {
        scheme: appUrl
      }
    }, true));
  },

  successCode: 0
};
const deeplinkConfigMap = {
  baiduboxapp: boxDeeplinkConfig,
  baiduboxlite: boxDeeplinkConfig,
  tomas: boxDeeplinkConfig,
  baiduboxvision,
  // 好看的端能力launch3rdApp有问题，调起失败也会返回成功的信息
  // 暂时搁置不处理
  bdminivideo
};
// 类型保护
// Browser => DeeplinkApp
function isDeeplinkApp(browser) {
  return Object.keys(deeplinkConfigMap).includes(browser);
}

/**
 * @file 调起应用宝
 * @author zhuzhibo(zhuzhibo@baidu.com)
 * @author zsy
 */
/**
 * 调起应用宝
 */

function openYYB(options) {
  const YYBUrl = `https://a.app.qq.com/o/simple.jsp?pkgname=${options.pkgName}`;
  sendH5ErrLog(options, Status.YYB_SUCCESS);
  location.href = `${YYBUrl}&android_schema=${encodeURIComponent(options.scheme)}`;
  return Status.YYB_SUCCESS;
}

/**
 * @file 不尝试调起的规则配置
 * @author zhangsiyuan(zhangsiyuan@baidu.com)
 */
// 这里的匹配规则一定要从头到尾
// 存在优先级的
// [browser, appName, os]
// 从当前browser调起至目标appName，不尝试调起，直接走失败路径
const notTryJumpRules = [['xiaomi', 'baiduboxapp', 'android'], ['uc', 'baiduboxapp', 'android'], ['oppo', 'baiduboxapp', 'android'], ['vivo', 'baiduboxapp', 'android'], ['wechat', 'baiduboxapp', 'android']];

/**
 * @file 检查是否处于黑名单浏览器中
 * @author zhuzhibo <zhuzhibo@baidu.com>
 */

/**
 * 检查是否处于黑名单浏览器中
 */
function checkNotTryJump(browser, appName, os) {
  for (const [browserRule, appNameRule, osRule] of notTryJumpRules) {
    if ((browserRule === '*' || browserRule === browser) && (appNameRule === '*' || appNameRule === appName) && (osRule === '*' || osRule === os)) {
      return true;
    }
  }

  return false;
}

/**
 * @file na deeplink能力
 * @author zhangsiyuan(zhangsiyuan@baidu.com)
 */
async function naDeeplink(options, browser) {
  return new Promise(resolve => {
    const {
      getScheme,
      successCode
    } = deeplinkConfigMap[browser]; // 回调是小程序触发的，类型很难搞啊

    function callback(result) {
      let res = JSON.parse(result);

      if (+res.status === successCode) {
        sendH5ErrLog(options, Status.INVOKE_SUCCESS);
        resolve(Status.INVOKE_SUCCESS);
      } else {
        resolve(handleInvokeFailed(options, InvokeType.DEEPLINK));
      }
    }

    invokeAction(getScheme(options.scheme, callback), options.appName);
  });
}

function select(element) {
    var selectedText;

    if (element.nodeName === 'SELECT') {
        element.focus();

        selectedText = element.value;
    }
    else if (element.nodeName === 'INPUT' || element.nodeName === 'TEXTAREA') {
        var isReadOnly = element.hasAttribute('readonly');

        if (!isReadOnly) {
            element.setAttribute('readonly', '');
        }

        element.select();
        element.setSelectionRange(0, element.value.length);

        if (!isReadOnly) {
            element.removeAttribute('readonly');
        }

        selectedText = element.value;
    }
    else {
        if (element.hasAttribute('contenteditable')) {
            element.focus();
        }

        var selection = window.getSelection();
        var range = document.createRange();

        range.selectNodeContents(element);
        selection.removeAllRanges();
        selection.addRange(range);

        selectedText = selection.toString();
    }

    return selectedText;
}

var select_1 = select;

/**
 * Inner class which performs selection from either `text` or `target`
 * properties and then executes copy or cut operations.
 */
class ClipboardAction {
  /**
   * @param {Object} options
   */
  constructor(options) {
    this.resolveOptions(options);
    this.initSelection();
  }

  /**
   * Defines base properties passed from constructor.
   * @param {Object} options
   */
  resolveOptions(options = {}) {
    this.action = options.action;
    this.container = options.container;
    this.emitter = options.emitter;
    this.target = options.target;
    this.text = options.text;
    this.trigger = options.trigger;

    this.selectedText = '';
  }

  /**
   * Decides which selection strategy is going to be applied based
   * on the existence of `text` and `target` properties.
   */
  initSelection() {
    if (this.text) {
      this.selectFake();
    } else if (this.target) {
      this.selectTarget();
    }
  }

  /**
   * Creates a fake textarea element, sets its value from `text` property,
   */
  createFakeElement() {
    const isRTL = document.documentElement.getAttribute('dir') === 'rtl';

    this.fakeElem = document.createElement('textarea');
    // Prevent zooming on iOS
    this.fakeElem.style.fontSize = '12pt';
    // Reset box model
    this.fakeElem.style.border = '0';
    this.fakeElem.style.padding = '0';
    this.fakeElem.style.margin = '0';
    // Move element out of screen horizontally
    this.fakeElem.style.position = 'absolute';
    this.fakeElem.style[isRTL ? 'right' : 'left'] = '-9999px';
    // Move element to the same position vertically
    let yPosition = window.pageYOffset || document.documentElement.scrollTop;
    this.fakeElem.style.top = `${yPosition}px`;

    this.fakeElem.setAttribute('readonly', '');
    this.fakeElem.value = this.text;

    return this.fakeElem;
  }

  /**
   * Get's the value of fakeElem,
   * and makes a selection on it.
   */
  selectFake() {
    const fakeElem = this.createFakeElement();

    this.fakeHandlerCallback = () => this.removeFake();

    this.fakeHandler =
      this.container.addEventListener('click', this.fakeHandlerCallback) ||
      true;

    this.container.appendChild(fakeElem);

    this.selectedText = select_1(fakeElem);

    this.copyText();

    this.removeFake();
  }

  /**
   * Only removes the fake element after another click event, that way
   * a user can hit `Ctrl+C` to copy because selection still exists.
   */
  removeFake() {
    if (this.fakeHandler) {
      this.container.removeEventListener('click', this.fakeHandlerCallback);
      this.fakeHandler = null;
      this.fakeHandlerCallback = null;
    }

    if (this.fakeElem) {
      this.container.removeChild(this.fakeElem);
      this.fakeElem = null;
    }
  }

  /**
   * Selects the content from element passed on `target` property.
   */
  selectTarget() {
    this.selectedText = select_1(this.target);
    this.copyText();
  }

  /**
   * Executes the copy operation based on the current selection.
   */
  copyText() {
    let succeeded;

    try {
      succeeded = document.execCommand(this.action);
    } catch (err) {
      succeeded = false;
    }

    this.handleResult(succeeded);
  }

  /**
   * Fires an event based on the copy operation result.
   * @param {Boolean} succeeded
   */
  handleResult(succeeded) {
    this.emitter.emit(succeeded ? 'success' : 'error', {
      action: this.action,
      text: this.selectedText,
      trigger: this.trigger,
      clearSelection: this.clearSelection.bind(this),
    });
  }

  /**
   * Moves focus away from `target` and back to the trigger, removes current selection.
   */
  clearSelection() {
    if (this.trigger) {
      this.trigger.focus();
    }
    document.activeElement.blur();
    window.getSelection().removeAllRanges();
  }

  /**
   * Sets the `action` to be performed which can be either 'copy' or 'cut'.
   * @param {String} action
   */
  set action(action = 'copy') {
    this._action = action;

    if (this._action !== 'copy' && this._action !== 'cut') {
      throw new Error('Invalid "action" value, use either "copy" or "cut"');
    }
  }

  /**
   * Gets the `action` property.
   * @return {String}
   */
  get action() {
    return this._action;
  }

  /**
   * Sets the `target` property using an element
   * that will be have its content copied.
   * @param {Element} target
   */
  set target(target) {
    if (target !== undefined) {
      if (target && typeof target === 'object' && target.nodeType === 1) {
        if (this.action === 'copy' && target.hasAttribute('disabled')) {
          throw new Error(
            'Invalid "target" attribute. Please use "readonly" instead of "disabled" attribute'
          );
        }

        if (
          this.action === 'cut' &&
          (target.hasAttribute('readonly') || target.hasAttribute('disabled'))
        ) {
          throw new Error(
            'Invalid "target" attribute. You can\'t cut text from elements with "readonly" or "disabled" attributes'
          );
        }

        this._target = target;
      } else {
        throw new Error('Invalid "target" value, use a valid Element');
      }
    }
  }

  /**
   * Gets the `target` property.
   * @return {String|HTMLElement}
   */
  get target() {
    return this._target;
  }

  /**
   * Destroy lifecycle.
   */
  destroy() {
    this.removeFake();
  }
}

/**
 * @file 剪贴板操作
 * @author zhuzhibo <zhuzhibo@baidu.com>
 * @author zsy
 */
/**
 * 基于 clipboard.js 的默认复制剪贴板方法
 *
 */

function copyText(token) {
  return new Promise((resolve, reject) => {
    new ClipboardAction({
      action: 'copy',
      text: token,
      container: document.body,
      emitter: {
        emit(type) {

          if (type === 'success') {
            resolve();
          } else {
            reject();
          }
        }

      }
    });
  });
}

/**
 * @file NA能力  写剪贴板
 * @author zhangsiyuan(zhangsiyuan@baidu.com)
 */

const naCopy = text => new Promise((resolve, reject) => {
  window._naCopyCb_ = function (res) {
    // 调起成功
    if (res && Number(JSON.parse(res).status) === 0) {
      resolve('naCopyDone');
    } else {
      reject(res);
    }
  };

  const params = encodeURIComponent(JSON.stringify({
    data: text
  }));
  invokeAction(`baiduboxapp://v19/utils/setClipboardData?params=${params}&callback=_naCopyCb_`, 'baiduboxapp');
});
/**
 *
 * 兜底Promise.race  HOC
 *
 */

async function raceTime(time, func, ...args) {
  return Promise.race([func(...args), new Promise((resolve, reject) => {
    // 超时  调用失败
    setTimeout(() => reject(`调用超时！: ${func.name}`), time);
  })]);
} //  包装一下超时调用
// 使用这个方法更安全
// 不会hang住

const invokeNaCopy = text => raceTime(500, naCopy, text);

async function execCopy(options) {
  try {
    await copyText(options.token);
  } catch (e) {
    // 手百端内  可以试试  端能力写剪贴板
    let naCopyRes = false;

    if (options.browser === 'baiduboxapp') {
      try {
        await invokeNaCopy(options.token);
        naCopyRes = true;
      } catch (err) {
        // todo  考虑上报吗？
        console.log(err);
      }
    } // 复制失败以后


    if (!naCopyRes) {
      sendH5ErrLog(options, Status.COPY_FAILED); // 打开这个选项的，直接中断调起流程，返回错误

      if (options.checkTokenCopied) {
        return Promise.reject(Status.COPY_FAILED);
      }
    }
  }
}

/**
 * @file execInvoke index
 * @author zhuzhibo(zhuzhibo@baidu.com)
 */
async function execInvoke(options) {
  // 开始 尝试调起！打点！
  // 复制口令可能失败，也要算到尝试调起的结果中
  // 所以这里要提到最前
  sendH5ErrLog(options, Status.TRY_JUMP); // 处理口令

  if (options.token) {
    await execCopy(options);
  }

  const {
    browser,
    appName,
    os
  } = options; // 安卓和ios才有调起的意义
  // 其他系统直接报错就行了

  if (IS_IOS || IS_ANDROID) {
    // 应用宝调起
    if (IS_ANDROID && options.toYYB && browser === 'wechat') {
      return openYYB(options);
    } // deeplink调起
    else if (options.useDeeplink && /baidu\.com/i.test(location.href) && isDeeplinkApp(browser)) {
        return naDeeplink(options, browser);
      } // 黑名单浏览器不尝试调起，注意这里的notTryJump行为，本意上因为知道无法成功调起，所以不做操作直接调起失败
      else if (options.useNotTryList && checkNotTryJump(browser, appName, os)) {
          return handleInvokeFailed(options, InvokeType.NOT_TRY);
        } // ulink调起
        else if (options.ulink && matchedUlink(browser, appName)) {
            return invokeWithType(options, InvokeType.ULINK);
          } // scheme调起


    return invokeWithType(options, InvokeType.SCHEME);
  }

  return Promise.reject(Status.NOT_SUPPORT_SYSTEM);
}

/**
 * @file invoke
 * @author zhangsiyuan(zhangsiyuan@baidu.com)
 */
async function invokeApp({
  appName,
  token = '',
  scheme = '',
  toStore = true,
  toYYB = true,
  ulink,
  timeout = 2500,
  useDeeplink = false,
  apkUrl = '',
  failedUrl = '',
  useNotTryList = true,
  checkTokenCopied = true,
  iosStoreUrl = '',
  statRatio = 10
}) {
  // 不支持的端appName，应该直接抛错，不能用百度做回退
  if (!Object.keys(appConfigMap).includes(appName)) {
    return Promise.reject(Status.APPNAME_NOT_SUPPORT);
  } // 处理下参数


  const {
    appStoreUrl,
    pkgName,
    scheme: defaultScheme,
    getUlink
  } = appConfigMap[appName];
  const finalScheme = scheme || defaultScheme;
  const finalAppStoreUrl = iosStoreUrl || appStoreUrl;
  const finalUlink = ulink !== null && ulink !== void 0 ? ulink : getUlink(finalScheme, toStore ? finalAppStoreUrl : failedUrl);
  const isHitStat = isHit(statRatio);
  return execInvoke({ ...getHostInfo(),
    isHitStat,
    appName,
    token,
    apkUrl,
    failedUrl,
    pkgName,
    scheme: finalScheme,
    iosStoreUrl: finalAppStoreUrl,
    toStore,
    toYYB,
    timeout,
    useDeeplink,
    ulink: finalUlink,
    useNotTryList,
    checkTokenCopied,
    statRatio
  });
}
async function invokeTpApp({
  token = '',
  scheme,
  toStore = false,
  toYYB = false,
  ulink = '',
  timeout = 2500,
  apkUrl = '',
  failedUrl = '',
  checkTokenCopied = true,
  iosStoreUrl = '',
  pkgName
}) {
  if (!scheme || (toStore || toYYB) && !pkgName) {
    console.error('invokeTpApp参数错误，请检查！');
    return Promise.reject(Status.PARAMS_ERROR);
  }

  const statRatio = 10;
  const isHitStat = isHit(statRatio);
  return execInvoke({ ...getHostInfo(),
    isHitStat,
    appName: 'tp',
    token,
    apkUrl,
    failedUrl,
    pkgName,
    scheme,
    iosStoreUrl,
    toStore,
    toYYB,
    timeout,
    useDeeplink: false,
    ulink,
    useNotTryList: false,
    checkTokenCopied,
    statRatio
  });
}

/**
 * @file 对微信开放标签支持的检测
 * @author zhangsiyuan(zhangsiyuan@baidu.com)
 */
function supportWxTag(options, appConfig) {
  const hasAppid = !!appConfig.wxAppid;
  const isWechat = getHostInfo().browser === 'wechat';
  return hasAppid && isWechat && !!options.wxInfo.appId;
}

/**
 * @file 创建微信开放标签
 * @author zhuzhibo(zhuzhibo@baidu.com)
 */

function _openYYB(pkgName, scheme) {
  const YYBUrl = `https://a.app.qq.com/o/simple.jsp?pkgname=${pkgName}`;
  location.href = `${YYBUrl}&android_schema=${encodeURIComponent(scheme)}`;
}

function insertDom(targetDom, scheme, appid) {
  const wxTag = document.createElement('wx-open-launch-app');
  wxTag.setAttribute('id', 'ug-wx-btn');
  wxTag.setAttribute('appid', appid);
  wxTag.setAttribute('extinfo', scheme);
  wxTag.setAttribute('style', 'position: absolute; left: 0; right: 0; top: 0; bottom: 0;');
  const wxScript = document.createElement('script');
  wxScript.setAttribute('type', 'text/wxtag-template');
  const wxBtn = document.createElement('div');
  wxBtn.setAttribute('style', 'width: 100%; height: 100%; position: absolute; bottom: 0px;');
  wxScript.appendChild(wxBtn);
  wxTag.appendChild(wxScript);
  targetDom.appendChild(wxTag);
}

function execCreateWxTag(options, appConfig) {
  var _options$debug;

  options.scheme = options.scheme || appConfig.scheme; // 创建标签插入DOM中

  insertDom(options.targetDom, options.scheme, appConfig.wxAppid); // 创建监听事件

  document.addEventListener('WeixinOpenTagsError', e => {
    if (options.onFailed) {
      options.onFailed({
        status: Status.NOT_SUPPORT_WX_TAG,
        msg: '不支持微信开放标签',
        e
      });
    }
  });
  const btn = document.querySelector('#ug-wx-btn');
  btn.addEventListener('click', async () => {
    // 复制口令
    if (options.token) {
      await copyText(options.token);
    }

    if (options.onClick) {
      options.onClick();
    }
  });
  btn.addEventListener('launch', () => {
    if (options.onSucceed) {
      options.onSucceed({
        status: Status.INVOKE_SUCCESS,
        msg: '调起成功'
      });
    }
  });
  btn.addEventListener('error', e => {
    if (options.onFailed) {
      if (options.toYYB) {
        _openYYB(appConfig.pkgName, options.scheme);
      }

      options.onFailed({
        status: Status.INVOKE_FAIL,
        msg: '调起失败',
        e
      });
    }
  }); // 注入数据

  /* global wx */
  // @ts-ignore

  wx.config({
    debug: (_options$debug = options.debug) !== null && _options$debug !== void 0 ? _options$debug : false,
    appId: options.wxInfo.appId,
    timestamp: options.wxInfo.timestamp,
    nonceStr: options.wxInfo.nonceStr,
    signature: options.wxInfo.signature,
    jsApiList: ['onMenuShareWeibo', 'onMenuShareTimeline', // 分享到朋友圈
    'onMenuShareAppMessage', // 分享给好友
    'onMenuShareQZone', // 分享到QQ空间
    'onMenuShareQQ', // 分享到QQ好友
    'updateAppMessageShareData', // 新版分享给好友
    'updateTimelineShareData' // 新版分享朋友圈
    ],
    openTagList: ['wx-open-launch-app']
  });
}

function createWxTag(options) {
  options.appName = options.appName || 'baiduboxapp';
  const appConfig = appConfigMap[options.appName];

  if (!supportWxTag(options, appConfig)) {
    if (options.onFailed) {
      options.onFailed({
        status: Status.NOT_SUPPORT_WX_TAG,
        msg: '不支持微信开放标签'
      });
    }

    return;
  }
  /* global wx */
  // @ts-ignore


  if (typeof wx !== 'object') {
    const scriptTag = document.createElement('script');
    scriptTag.setAttribute('src', '//res.wx.qq.com/open/js/jweixin-1.6.0.js');
    scriptTag.setAttribute('type', 'text/javascript');

    scriptTag.onload = () => {
      execCreateWxTag(options, appConfig);
    };

    document.getElementsByTagName('head')[0].appendChild(scriptTag);
  } else {
    console.log('[ug-invoke-app] 检测到微信JS-SDK已被引入，请确保SDK版本大于等于1.6.0');
    execCreateWxTag(options, appConfig);
  }
}

/**
 * @file index
 * @author zhangsiyuan(zhangsiyuan@baidu.com)
 */
// 全局版本号，确认线上版本
window.__UIA_VERSION__ = '2.3.5';

export { appConfigMap, createWxTag, getHostInfo, invokeApp, invokeMarket, invokeTpApp };
