/**
 * @file mutationObserver
 * @author zhangsiyuan(zhangsiyuan@baidu.com)
 */

import {getInvokeInfo} from '../api/getInvokeInfo';
import {simulateInterval} from './markupUtils';

/**
 * example
 *
 * {
 *     posid01:[{}],
 *     posid02:[{},{}],
 * }
 *
 */
export let tempInvokeConf = {};

/**
 * example
 *
 * {
 *     posid01: 1,
 *     posid02: 15
 * }
 *
 */
export let tempSelectIndex = {};

// 轮询请求后端
// 成功后把temp信息置空
export function pollingRequest() {
    // const interval = 200;
    // simulateInterval(async () => {
    //     // 如果tempInveokeConf不是个空对象
    //     // 说明这个周期有增量信息
    //     if (Object.keys(tempInvokeConf).length) {
    //         try {
    //             const res = await getInvokeInfo(tempInvokeConf, tempSelectIndex);
    //             console.log(res);
    //             tempInvokeConf = tempSelectIndex = {};
    //         }
    //         catch (err) {
    //             console.log('polling request error: ');
    //             console.log(err);
    //             // todo 错误处理打点 请求异常
    //         }
    //     }
    // }, interval);
}

// 每次mutationobserver触发时
// 执行这个函数来合并增量元素
export function composeInvokeData({mcpPosid, mcpPosIndex, mcpConfig, mcpSuccess, mcpFailed}) {
    // // 增量物料
    // // 放入暂存区
    // if (tempInvokeConf[mcpPosid] && tempInvokeConf[mcpPosid].length) {
    //     tempInvokeConf[mcpPosid].push(mcpConfig);
    // }
    // else {
    //     tempInvokeConf[mcpPosid] = [mcpConfig];
    // }
    // // 如果这是事件循环中第一个拿到的增量id的index
    // // 把它存入tempSelectIndex
    // // 每一轮事件循环结尾请求时带上，请求回来置空
    // Number(mcpPosIndex)
    // && !tempSelectIndex[mcpPosid]
    // && (tempSelectIndex[mcpPosid] = Number(mcpPosIndex));
}

/**
 * 监听处理新增元素
 *
 * @param {HTMLElement} targetNode 要监听的祖先dom元素
 */
export function observeAddedNodes(targetNode) {
    // let config = {attributes: false, childList: true, subtree: true};
    // // Callback function to execute when mutations are observed
    // const mutationCallback = mutationsList => {
    //     for (let mutation of mutationsList) {
    //         mutation.addedNodes.forEach(node => {
    //
    //             // 如果某一个添加进来的node节点有mcpPosid的自定义属性
    //             // 把posid合并去请求一次，然后存进全局配置
    //             if (node.dataset?.mcpPosid) {
    //                 const {
    //                     mcpPosid,
    //                     mcpPosIndex = 0,
    //                     mcpConfig,
    //                     mcpSuccess,
    //                     mcpFailed
    //                 } = node.dataset;
    //                 composeInvokeData({mcpPosid, mcpPosIndex, mcpConfig, mcpSuccess, mcpFailed});
    //             }
    //         });
    //     }
    // };
    //
    // let observer = new MutationObserver(mutationCallback);
    //
    // observer.observe(targetNode, config);
}

/**
 * 处理已经渲染的标记元素
 *
 * @param {HTMLElement} targetNode 要监听的祖先dom元素
 */
export function processExistNodes(targetNode) {
    // // todo 入参校验？不是htmlElement如何提示？
    // const nodeList = targetNode.querySelectorAll('[data-mcp-posid]');
    //
    // for (let node of nodeList) {
    //     const {
    //         mcpPosid,
    //         mcpPosIndex = 0,
    //         mcpConfig,
    //         mcpSuccess,
    //         mcpFailed
    //     } = node.dataset;
    //     composeInvokeData({mcpPosid, mcpPosIndex, mcpConfig, mcpSuccess, mcpFailed});
    // }
}

