import merge from 'lodash.merge';
import axios from 'axios';

function _typeof(obj) {
  "@babel/helpers - typeof";

  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof = function (obj) {
      return typeof obj;
    };
  } else {
    _typeof = function (obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
  }

  return _typeof(obj);
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    });
    keys.push.apply(keys, symbols);
  }

  return keys;
}

function _objectSpread2(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};

    if (i % 2) {
      ownKeys(Object(source), true).forEach(function (key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys(Object(source)).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }

  return target;
}

/**
 * 字符串化query
 *
 * [注]：
 * 默认：如果`value`是数组，其`toString`会自动转为逗号分隔的字符串
 * 这里：如果 是 Array 和 Object 参数 都进行 JSON.stringify + encodeURIComponent 了
 *
 * @param {Object} query 查询条件
 * @return {string}
 */

function stringify() {
  var query = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

  if (!query) {
    return '';
  }

  var search = '';

  for (var key in query) {
    if (query.hasOwnProperty(key)) {
      var value = query[key];

      if (value == null) {
        value = '';
      } else if (_typeof(value) === 'object') {
        value = JSON.stringify(value);
      }

      search += '&' + encodeURIComponent(key) + '=' + encodeURIComponent(value);
    }
  }

  return search.slice(1);
}
/**
 * 在url上加指定参数
 *
 * @param  {string} url  url
 * @param {Object} query 参数对象
 * @example
 * {
 *    a: 1
 * }
 * @return {string}    添加参数后的url
 */

function renderUrl() {
  var url = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
  var query = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  return url + (~url.indexOf('?') ? '&' : '?') + stringify(query);
}
/**
 * getUrl
 *
 * @param   {string}  url       请求url
 * @param   {Object}  params    参数
 * @return  {string}  更新url(过滤为空的参数)
 */

var getUrl = function getUrl(url, params) {
  var realParams = {};
  Object.keys(params).forEach(function (item) {
    // TODO params[item]是不是有可能为0
    params[item] && (realParams[item] = params[item]);
  });

  if (Object.keys(realParams).length === 0) {
    return url;
  }

  return renderUrl(url, realParams);
};
/**
 * 获得key对应的cookie值
 * @param {string} sKey cookie的key
 * @return {string} cookie的value
 */

var getCookieByName = function getCookieByName(sKey) {
  var cookie = typeof document !== "undefined" && document.cookie || '';
  return decodeURIComponent(cookie.replace(new RegExp('(?:(?:^|.*;)\\s*' + encodeURIComponent(sKey).replace(/[-.+*]/g, '\\$&') + '\\s*\\=\\s*([^;]*).*$)|^.*$'), '$1')) || '';
};

/**
 * @file ubcLog的conf配置
 * @author songzimei<songzimei@baidu.com>
 */
var CONFIG = {
  UBC_URL: 'https://mbd.baidu.com/ztbox',
  TEST_UBC_URL: 'http://bjyz-mco-searchbox201609-m12xi3-044.bjyz.baidu.com:8080/ztbox',
  DEFAULT_LOG_DATA: {
    cateid: '99',
    actiondata: {
      // 外部填写（ubcID）
      id: '0',
      // 日志类型：0—事件类（web类）1—流类型（客户端)
      type: '0',
      timestamp: 0,
      content: {
        // 页面名称
        page: '-',
        // 区块位置
        type: '-',
        // 页面来源
        value: '-',
        // 资源来源
        source: 'default',
        // 日志类型
        from: 'act',
        // 扩展字段
        ext: {
          apptype: '-'
        }
      }
    }
  },
  DEFAULT_QUERY: {
    action: 'zpblog',
    v: '2.0',
    appname: 'baiduboxapp',
    from: '',
    cfrom: '',
    smfw: ''
  }
};
var CONFIG_MERGE = {
  UBC_URL: 'https://mbd.baidu.com/ztbox',
  TEST_UBC_URL: 'http://bjyz-mco-searchbox201609-m12xi3-044.bjyz.baidu.com:8080/ztbox',
  DEFAULT_LOG_DATA: {
    cateid: '101',
    data: []
  },
  DEFAULT_QUERY: {
    action: 'mpblog',
    v: '2.0',
    appname: 'baiduboxapp',
    from: '',
    cfrom: '',
    smfw: '',
    sid: '',
    sn: ''
  }
};

/**
 * 使用图片来发请求
 *
 * @param {string} url 上报服务地址
 * @param {Object} logData 上报的数据
 * @param {Object} [options] 额外参数
 * @param {Object} [options.useSendBeacon] 是否使用sendBeancon
 * @param {Object} [options.useXhr] 是否使用useXhr
 * @return {Promise} 结束回调
 */

function smartSend(url, logData) {
  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  var method = 'get';
  var params = {
    data: logData
  };
  var data = {};
  var axiosParams = options.axiosParams || {};

  if ((axiosParams.method + '').toLowerCase() === 'post') {
    method = 'post';
    data = 'data=' + encodeURIComponent(JSON.stringify(logData));
    params = {};
  }

  return axios(_objectSpread2({
    headers: {
      'Content-Type': 'application/x-www-form-urlencoded'
    },
    url: url,
    method: method,
    params: params,
    data: data
  }, axiosParams));
}

var version = "1.0.3";

/**
 * @file MergeLogger
 *
 * @author changyuqing@baidu.com
 */
var MergeLogger = /*#__PURE__*/function () {
  function MergeLogger(_ref) {
    var _ref$logFn = _ref.logFn,
        logFn = _ref$logFn === void 0 ? function () {} : _ref$logFn;

    _classCallCheck(this, MergeLogger);

    this.logFn = logFn;
    this.logArray = [];
    this.mergeNumMax = 5;
    this.mergeInterval = 5;
    this.timeId = null;
  }

  _createClass(MergeLogger, [{
    key: "set",
    value: function set(_ref2) {
      var mergeNumMax = _ref2.mergeNumMax,
          mergeInterval = _ref2.mergeInterval;

      if (mergeNumMax) {
        this.mergeNumMax = mergeNumMax;
      }

      if (mergeInterval) {
        this.mergeInterval = mergeInterval;
      }
    }
  }, {
    key: "add",
    value: function add(logData) {
      var _this = this;

      this.logArray.push(logData);

      if (this.logArray.length === 1) {
        // 如果是进入队列的第一个日志，此时开启一个定时器
        this.timeId = setTimeout(function () {
          _this.clearAll();
        }, this.mergeInterval * 1000);
      } else if (this.logArray.length >= this.mergeNumMax) {
        // 如果进入队列的日志个数达到上限，就直接发送
        this.clearAll();
      }
    }
  }, {
    key: "clearAll",
    value: function clearAll() {
      if (this.logArray.length > 0) {
        // 如果队列里面存在待发送的日志，调用发送函数进行发送
        this.logFn(this.logArray); // 清空日志队列

        this.logArray = [];
      }

      if (this.timeId) {
        clearTimeout(this.timeId);
        this.timeId = null;
      }
    }
  }]);

  return MergeLogger;
}();

/**
 * @file 打点重试机制
 * @author changyuqing@baidu.com
 *
 */
var RetryLogger = /*#__PURE__*/function () {
  function RetryLogger(_ref) {
    var _ref$logFn = _ref.logFn,
        logFn = _ref$logFn === void 0 ? function () {} : _ref$logFn;

    _classCallCheck(this, RetryLogger);

    this.logFn = logFn;
    this.retryLogList = [];
    this.retryTimesMax = 3; // 最大重发次数

    this.retryLogListMax = 5; // 重试队列最大长度

    this._retryIntervalTimer = null;
  }

  _createClass(RetryLogger, [{
    key: "_getDelayTime",
    value: function _getDelayTime(failTimes) {
      // 延迟重发时间的配置。连续失败次数越多，发送延迟越久
      var timeMap = {
        0: 1,
        // s
        1: 1,
        2: 5
      };
      return timeMap[failTimes] || 10 + Math.floor(Math.random() * 5 + 1);
    }
  }, {
    key: "active",
    value: function active() {
      var _this = this;

      if (!this._retryIntervalTimer && this.retryLogList.size > 0) {
        this._retryIntervalTimer = setInterval(function () {
          _this._retryIntervalTimerHandler();
        }, 1000);
      }
    }
  }, {
    key: "addLog",
    value: function addLog(_ref2) {
      var url = _ref2.url,
          loggerData = _ref2.loggerData,
          loggerId = _ref2.loggerId;
      this.retryLogList.set(loggerId, {
        url: url,
        loggerData: loggerData,
        loggerId: loggerId,
        failTimes: 1,
        sendCountDown: this._getDelayTime(1)
      }); // 超出最大长度时 取出队列中最久的一条

      if (this.retryLogList.size > this.retryLogListMax) {
        var key = this.retryLogList.keys().next().value;
        this.retryLogList["delete"](key);
      }

      this.active();
    }
  }, {
    key: "removeLog",
    value: function removeLog(loggerId) {
      if (!loggerId) {
        return;
      }

      this.retryLogList["delete"](loggerId);
    }
  }, {
    key: "updateLog",
    value: function updateLog(loggerId) {
      if (!loggerId) {
        return;
      }

      var item = this.retryLogList.get(loggerId);

      if (item) {
        var curFailTimes = item.failTimes; // 如果超过最大重试次数 则不再重发 从队列中删除

        if (curFailTimes + 1 > this.retryTimesMax) {
          this.removeLog(loggerId);
        } else {
          item.failTimes = curFailTimes + 1;
          item.sendCountDown = this._getDelayTime(item.failTimes);
        }
      }
    }
  }, {
    key: "_retryIntervalTimerHandler",
    value: function _retryIntervalTimerHandler() {
      var _this2 = this;

      this.retryLogList.forEach(function (logItem) {
        // 倒计时为-1时 表示该条日志正在被重新发送
        if (logItem.sendCountDown < 0) {
          return;
        } else if (+logItem.sendCountDown === 0) {
          // 倒计时已到 执行再次发送
          logItem.sendCountDown = -1; // 设置其正在方法

          _this2._sendLog(logItem);
        } else {
          // 倒计时计时 -1
          logItem.sendCountDown = logItem.sendCountDown - 1;
        }
      });

      if (this.retryLogList.size === 0) {
        clearInterval(this._retryIntervalTimer);
        this._retryIntervalTimer = null;
      }
    }
  }, {
    key: "_sendLog",
    value: function _sendLog(logItem) {
      var _this3 = this;

      this.logFn(logItem.url, logItem.loggerData).then(function () {
        _this3.removeLog(logItem.loggerId);
      })["catch"](function () {
        _this3.updateLog(logItem.loggerId);
      });
    }
  }]);

  return RetryLogger;
}();

/**
 * @file sha256 简化的sha256算法
 * @author geraintluff
 * @link https://github.com/geraintluff/sha256
 */
var sha256 = function sha256(ascii) {
  function rightRotate(value, amount) {
    return value >>> amount | value << 32 - amount;
  }

  var maxWord = Math.pow(2, 32);
  var lengthProperty = 'length';
  var i, j; // Used as a counter across the whole file

  var result = '';
  var words = [];
  var asciiBitLength = ascii[lengthProperty] * 8; //* caching results is optional - remove/add slash from front of this line to toggle
  // Initial hash value: first 32 bits of the fractional parts of the square roots of the first 8 primes
  // (we actually calculate the first 64, but extra values are just ignored)

  var hash = sha256.h = sha256.h || []; // Round constants: first 32 bits of the fractional parts of the cube roots of the first 64 primes

  var k = sha256.k = sha256.k || [];
  var primeCounter = k[lengthProperty];
  /*/
   var hash = [], k = [];
   var primeCounter = 0;
   //*/

  var isComposite = {};

  for (var candidate = 2; primeCounter < 64; candidate++) {
    if (!isComposite[candidate]) {
      for (i = 0; i < 313; i += candidate) {
        isComposite[i] = candidate;
      }

      hash[primeCounter] = Math.pow(candidate, .5) * maxWord | 0;
      k[primeCounter++] = Math.pow(candidate, 1 / 3) * maxWord | 0;
    }
  }

  ascii += '\x80'; // Append Ƈ' bit (plus zero padding)

  while (ascii[lengthProperty] % 64 - 56) {
    ascii += '\x00';
  } // More zero padding


  for (i = 0; i < ascii[lengthProperty]; i++) {
    j = ascii.charCodeAt(i);
    if (j >> 8) return; // ASCII check: only accept characters in range 0-255

    words[i >> 2] |= j << (3 - i) % 4 * 8;
  }

  words[words[lengthProperty]] = asciiBitLength / maxWord | 0;
  words[words[lengthProperty]] = asciiBitLength; // process each chunk

  for (j = 0; j < words[lengthProperty];) {
    var w = words.slice(j, j += 16); // The message is expanded into 64 words as part of the iteration

    var oldHash = hash; // This is now the undefined working hash", often labelled as variables a...g
    // (we have to truncate as well, otherwise extra entries at the end accumulate

    hash = hash.slice(0, 8);

    for (i = 0; i < 64; i++) {
      // let i2 = i + j;
      // Expand the message into 64 words
      // Used below if
      var w15 = w[i - 15],
          w2 = w[i - 2]; // Iterate

      var a = hash[0],
          e = hash[4];
      var temp1 = hash[7] + (rightRotate(e, 6) ^ rightRotate(e, 11) ^ rightRotate(e, 25)) // S1
      + (e & hash[5] ^ ~e & hash[6]) // ch
      + k[i] // Expand the message schedule if needed
      + (w[i] = i < 16 ? w[i] : w[i - 16] + (rightRotate(w15, 7) ^ rightRotate(w15, 18) ^ w15 >>> 3) // s0
      + w[i - 7] + (rightRotate(w2, 17) ^ rightRotate(w2, 19) ^ w2 >>> 10) // s1
      | 0); // This is only used once, so *could* be moved below, but it only saves 4 bytes and makes things unreadble

      var temp2 = (rightRotate(a, 2) ^ rightRotate(a, 13) ^ rightRotate(a, 22)) + ( // S0
      a & hash[1] ^ a & hash[2] ^ hash[1] & hash[2]); // maj

      hash = [temp1 + temp2 | 0].concat(hash); // We don't bother trimming off the extra ones, they're harmless as long as we're truncating when we do the slice()

      hash[4] = hash[4] + temp1 | 0;
    }

    for (i = 0; i < 8; i++) {
      hash[i] = hash[i] + oldHash[i] | 0;
    }
  }

  for (i = 0; i < 8; i++) {
    for (j = 3; j + 1; j--) {
      var b = hash[i] >> j * 8 & 255;
      result += (b < 16 ? 0 : '') + b.toString(16);
    }
  }

  return result;
};

/**
 *
 * @constructor ubc业务日志类
 * @description ubc业务日志类
 *
 * @example
 * new Ubclogger({
 *     serverId:123,
 *     idfrom:'res_fuli',
 *     page:'index'
 * })
 */

var UbcLogger = /*#__PURE__*/function () {
  /**
   * Create a UbcLogger
   *
   * @class UbcLogger
   * @param {Object} [options]                        初始化入参
   * @param {number} [options.serverId]               活动serverId
   * @param {string} [options.page]                   页面page名称
   * @param {string} [options.from]                   日志类型
   * @param {Object} [options.queryParams]            ubcUrl上的query(appname,from,cfrom,smfw)
   * @param {boolean} [options.testMode=false]        true走线下地址; false或者为空走线上ubc地址
   * @param {string} [options.testUrl]                打点数据上传地址;传入后，打点数据将发送至该地址
   * @param {string} [options.source]                 资源位source
   * @param {string} [options.idfrom]                 资源位idfrom(等价于资源位source，优先级更高)
   * @param {Object} [options.logMergeOpt]            日志合并参数配置
   * @param {Object} [options.logMergeOpt.ifAutoMerge] 是否开启自动合并，默认不开启
   * @param {Object} [options.logMergeOpt.mergeNumMax] 最大日志合并数量
   * @param {Object} [options.logMergeOpt.mergeInterval] 合并时间间隔
   * @param {boolean} [options.logErrRetry]            是否开启日志重试
   * @param {Object} [options.axiosParams]            透传axiosParams参数
   *
   *
   */
  function UbcLogger() {
    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    _classCallCheck(this, UbcLogger);

    // ubcLog
    this.ubcParams = {}; // 是否初始化

    this.logInited = false; // set后的options

    this.options = {}; // 合并打点

    this.mergeLogger = null; // 打点重试机制

    this.retryLogger = null;

    this._initUbcParams(); // 初始化设置参数


    this.set(Object.assign({
      duration: 3,
      testMode: false,
      apptype: 1
    }, options));
  }
  /**
   * _initUbcParams
   *
   * @private
   */


  _createClass(UbcLogger, [{
    key: "_initUbcParams",
    value: function _initUbcParams() {
      this.ubcParams = {};
      this.ubcDefaultLogData = CONFIG.DEFAULT_LOG_DATA; // merge默认数据

      merge(this.ubcParams, this.ubcDefaultLogData);
    }
    /**
     * _initUbcUrl
     *
     * @private
     * @param {Object} options  options入参
     */

  }, {
    key: "_initUbcUrl",
    value: function _initUbcUrl() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      // 获取ubcUrl
      var query = options.queryParams || {};
      this.ubcUrl = getUrl(options.testMode ? options.testUrl ? options.testUrl : CONFIG.TEST_UBC_URL : CONFIG.UBC_URL, merge({}, CONFIG.DEFAULT_QUERY, query));
      this.ubcMergeUrl = getUrl(options.testMode ? options.testUrl ? options.testUrl : CONFIG_MERGE.TEST_UBC_URL : CONFIG_MERGE.UBC_URL, merge({}, CONFIG_MERGE.DEFAULT_QUERY, query));
    }
    /**
     * set
     * options可不填，缺省字段会以上次设置的为准
     * @example
     * ubclogger.set({
     *     serverId:123,
     *     idfrom:'res_fuli',
     *     page:'index'
     * })
     * @param {Object} [options]                  初始化入参
     * @param {number} [options.serverId]               活动serverId
     * @param {string} [options.page]                   页面page名称
     * @param {string} [options.from]                   日志类型
     * @param {Object} [options.queryParams]            ubcUrl上的query(appname,from,cfrom,smfw)
     * @param {string} [options.testMode]         true走线下地址; false或者为空走线上ubc地址
     * @param {string} [options.testUrl]                打点数据上传地址;传入后，打点数据将发送至该地址
     * @param {string} [options.source]                 资源位source
     * @param {string} [options.idfrom]                 资源位idfrom(等价于资源位source，优先级更高)
     * @param {Object} [options.logMergeOpt]            日志合并参数配置
     * @param {boolean} [options.logMergeOpt.ifAutoMerge] 是否开启自动合并，默认不开启
     * @param {number} [options.logMergeOpt.mergeNumMax] 最大日志合并数量
     * @param {number} [options.logMergeOpt.mergeInterval] 合并时间间隔
     * @param {boolean} [options.logErrRetry]            是否开启日志重试
     * @param {Object} [options.axiosParams]            透传axiosParams参数
     *
     */

  }, {
    key: "set",
    value: function set() {
      var _this = this;

      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      this.options = _objectSpread2(_objectSpread2({}, this.options), options);

      this._initUbcUrl(this.options); // 配置serverId,source(idfrom),page


      merge(this.ubcParams, {
        actiondata: {
          id: this.options.serverId,
          content: {
            source: this.options.source || this.options.idfrom,
            page: this.options.page,
            from: this.options.from,
            ext: {
              apptype: this.options.apptype
            }
          }
        }
      });

      if (+this.options.serverId) {
        this.logInited = true;
      }

      if (this.options.logMergeOpt) {
        // 初始化mergeLogger
        if (!this.mergeLogger) {
          this.mergeLogger = new MergeLogger({
            logFn: function logFn(paramsList) {
              return _this._sendMerge(paramsList, _this.options);
            }
          });
        } // 修改mergeLogger选项


        this.mergeLogger.set(this.options.logMergeOpt);
      } // 初始化retryLogger


      if (this.options.logErrRetry && !this.retryLogger) {
        this.retryLogger = new RetryLogger({
          logFn: function logFn(url, logData) {
            logData.actiondata.metadata.uploadTimeStamp = Date.now();
            return smartSend(url, logData, _objectSpread2(_objectSpread2({}, _this.options), {}, {
              useXhr: true
            }));
          }
        });
      }
    }
    /**
     * 发送普通点
     * @private
     * @param  {Object} params  打点自定义参数
     * @param  {Object} options 额外参数
     * @param  {boolean} options.useSendBeacon 是否使用SendBeacon API发送请求
     * @return {Promise} promise 打点成功发送返回then
     */

  }, {
    key: "_send",
    value: function _send() {
      var _this2 = this;

      var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var logData = {};
      var now = Date.now(); // 事件打点正常处理

      var baiduId = getCookieByName('BAIDUID');

      if (baiduId && this.options.logErrRetry) {
        // 获得没有加metadata的logData
        merge(logData, this.ubcParams, {
          actiondata: {
            timestamp: now,
            content: params
          }
        }); // 通过baiduId和logData计算摘要值（logData里面已经包含了当前时间戳）

        var loggerId = sha256(baiduId + JSON.stringify(logData));
        logData.actiondata.metadata = {
          md5: loggerId,
          uploadTimeStamp: now
        };
        return smartSend(this.ubcUrl, logData, _objectSpread2(_objectSpread2({}, options), {}, {
          useXhr: true
        })).then(function (data) {
          // 打点成功后通知retryLogger
          _this2.retryLogger.active();

          return data;
        })["catch"](function (err) {
          //向队列中加一条日志
          _this2.retryLogger.addLog({
            url: _this2.ubcUrl,
            loggerData: logData,
            loggerId: loggerId
          });

          return Promise.reject(err);
        });
      } else {
        merge(logData, this.ubcParams, {
          actiondata: {
            timestamp: now,
            content: params
          }
        });
        return smartSend(this.ubcUrl, logData, options);
      }
    }
    /**
     * 发送合并点
     * @private
     * @param  {Array} paramsList  打点自定义参数
     * @param  {Object} options 额外参数
     * @param  {boolean} options.useSendBeacon 是否使用SendBeacon API发送请求
     * @param  {string} options.loggerId 发送请求时指定loggerId
     * @return {Promise} promise 打点成功发送返回then
     */

  }, {
    key: "_sendMerge",
    value: function _sendMerge() {
      var paramsList = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var logData = {};
      var now = Date.now(); // 事件打点正常处理

      var actiondata = this.ubcParams.actiondata;
      var data = paramsList.map(function (params) {
        var tempLogData = {};
        merge(tempLogData, actiondata, {
          timestamp: now,
          content: params
        });
        return tempLogData;
      });
      logData = _objectSpread2(_objectSpread2({}, CONFIG_MERGE.DEFAULT_LOG_DATA), {}, {
        data: data
      });
      return smartSend(this.ubcMergeUrl, logData, options);
    }
    /**
     * send
     * @example
     * ubclogger.send({
     *     page: 'y_ent_login',
     *     type: 'login_clk',
     *     value: 'login',
     *     ext: {
     *         p1: 'login'
     *     }
     * })
     * @param  {Object} params  打点自定义参数
     * @param  {Object} [options] 额外选项
     * @param  {boolean} [options.useSendBeacon] 是否使用SendBeacon API发送请求
     * @return {Promise} promise 打点成功发送返回then
     */

  }, {
    key: "send",
    value: function send() {
      var _this$options, _this$options$logMerg;

      var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var options = arguments.length > 1 ? arguments[1] : undefined;

      if (!this.logInited) {
        throw 'UBC SDK serverId can not be empty!';
      }

      options = _objectSpread2(_objectSpread2({}, this.options), options);

      if ((_this$options = this.options) !== null && _this$options !== void 0 && (_this$options$logMerg = _this$options.logMergeOpt) !== null && _this$options$logMerg !== void 0 && _this$options$logMerg.ifAutoMerge) {
        this.mergeLogger.add(params);
        return Promise.resolve();
      } else {
        return this._send(params, options);
      }
    }
    /**
     * sendMergeLog
     * @example
     * ubclogger.sendMergeLog({
     *     page: 'y_ent_login',
     *     type: 'login_clk',
     *     value: 'login',
     *     ext: {
     *         p1: 'login'
     *     }
     * })
     * @param  {Object} params  打点自定义参数
     * @return {Promise} promise 打点成功发送返回then
     */

  }, {
    key: "sendMergeLog",
    value: function sendMergeLog() {
      var _this$options2;

      var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      if (!this.logInited) {
        throw 'UBC SDK serverId can not be empty!';
      }

      if ((_this$options2 = this.options) !== null && _this$options2 !== void 0 && _this$options2.logMergeOpt) {
        this.mergeLogger.add(params);
        return Promise.resolve();
      } else {
        return this._send(params);
      }
    }
    /**
     * getVersion 获得当前sdk版本
     * @return {string} 当前sdk版本
     */

  }, {
    key: "getVersion",
    value: function getVersion() {
      return version;
    }
  }]);

  return UbcLogger;
}();

/**
 * @file es 文件入口
 * @author changyuqing@baidu.com
 */
var UbcLogger$1 = UbcLogger;
var ubcLogger = new UbcLogger();

export { UbcLogger$1 as UbcLogger, ubcLogger };
