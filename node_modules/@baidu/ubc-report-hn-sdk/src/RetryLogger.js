/**
 * @file 打点重试机制
 * @author changyuqing@baidu.com
 *
 */

export class RetryLogger {
    constructor({logFn = () => { }}) {
        this.logFn = logFn;
        this.retryLogList = [];
        this.retryTimesMax = 3; // 最大重发次数
        this.retryLogListMax = 5; // 重试队列最大长度
        this._retryIntervalTimer = null;
    }

    _getDelayTime(failTimes) {
        // 延迟重发时间的配置。连续失败次数越多，发送延迟越久
        let timeMap = {
            0: 1, // s
            1: 1,
            2: 5
        };
        return timeMap[failTimes] || (10 + Math.floor(Math.random() * 5 + 1));
    }

    active() {
        if (!this._retryIntervalTimer && this.retryLogList.size > 0) {
            this._retryIntervalTimer = setInterval(() => {
                this._retryIntervalTimerHandler();
            }, 1000);
        }
    }

    addLog({url, loggerData, loggerId}) {
        this.retryLogList.set(loggerId, {
            url,
            loggerData,
            loggerId,
            failTimes: 1,
            sendCountDown: this._getDelayTime(1)
        });
        // 超出最大长度时 取出队列中最久的一条
        if (this.retryLogList.size > this.retryLogListMax) {
            let key = this.retryLogList.keys().next().value;
            this.retryLogList.delete(key);
        }

        this.active();
    }

    removeLog(loggerId) {
        if (!loggerId) {
            return;
        }
        this.retryLogList.delete(loggerId);
    }

    updateLog(loggerId) {
        if (!loggerId) {
            return;
        }
        let item = this.retryLogList.get(loggerId);
        if (item) {
            const curFailTimes = item.failTimes;
            // 如果超过最大重试次数 则不再重发 从队列中删除
            if (curFailTimes + 1 > this.retryTimesMax) {
                this.removeLog(loggerId);
            } else {
                item.failTimes = curFailTimes + 1;
                item.sendCountDown = this._getDelayTime(item.failTimes);
            }
        }
    }

    _retryIntervalTimerHandler() {
        this.retryLogList.forEach(logItem => {
            // 倒计时为-1时 表示该条日志正在被重新发送
            if (logItem.sendCountDown < 0) {
                return;
            } else if (+logItem.sendCountDown === 0) {
                // 倒计时已到 执行再次发送
                logItem.sendCountDown = -1; // 设置其正在方法
                this._sendLog(logItem);

            } else {
                // 倒计时计时 -1
                logItem.sendCountDown = logItem.sendCountDown - 1;
            }
        });
        if (this.retryLogList.size === 0) {
            clearInterval(this._retryIntervalTimer);
            this._retryIntervalTimer = null;
        }
    }

    _sendLog(logItem) {
        this.logFn(logItem.url, logItem.loggerData)
            .then(() => {
                this.removeLog(logItem.loggerId);
            })
            .catch(() => {
                this.updateLog(logItem.loggerId);
            });
    }

}