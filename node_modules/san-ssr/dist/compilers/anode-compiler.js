"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ANodeCompiler = void 0;
const expr_compiler_1 = require("../target-js/compilers/expr-compiler");
const assert_1 = __importDefault(require("assert"));
const lodash_1 = require("lodash");
const element_compiler_1 = require("./element-compiler");
const stringifier_1 = require("../target-js/compilers/stringifier");
const anode_util_1 = require("../utils/anode-util");
const TypeGuards = __importStar(require("../utils/type-guards"));
/**
 * ANode 编译
 *
 * 负责单个 ComponentClass 的编译，每个 ANodeCompiler 对应于一个 ComponentInfo。
 */
class ANodeCompiler {
    /**
     * @param componentInfo 要被编译的节点所在组件的信息
     * @param componentTree 当前组件所在的组件树
     * @param ssrOnly san-ssr 当做模板引擎来使用（产出 HTML 更简单，但无法反解）
     * @param emitter 代码输出器，产出代码塞到这里面
     */
    constructor(componentInfo, ssrOnly, emitter) {
        this.componentInfo = componentInfo;
        this.ssrOnly = ssrOnly;
        this.emitter = emitter;
        this.ssrIndex = 0;
        this.inScript = false;
        this.elementCompiler = new element_compiler_1.ElementCompiler(this, emitter);
    }
    compile(aNode, isRootElement) {
        if (TypeGuards.isATextNode(aNode))
            return this.compileText(aNode);
        if (TypeGuards.isAIfNode(aNode))
            return this.compileIf(aNode);
        if (TypeGuards.isAForNode(aNode))
            return this.compileFor(aNode);
        if (TypeGuards.isASlotNode(aNode))
            return this.compileSlot(aNode);
        if (TypeGuards.isATemplateNode(aNode))
            return this.compileTemplate(aNode);
        if (TypeGuards.isAFragmentNode(aNode))
            return this.compileFragment(aNode);
        const childComponentReference = this.generateRef(aNode);
        if (childComponentReference) {
            return this.compileComponent(aNode, childComponentReference, isRootElement);
        }
        return this.compileElement(aNode, isRootElement);
    }
    generateRef(aNode) {
        if (aNode.directives.is) {
            this.emitter.writeLine(`let ref = ctx.refs[${expr_compiler_1.expr(aNode.directives.is.value)}];`);
            return 'ref';
        }
        if (this.componentInfo.childComponents.has(aNode.tagName)) {
            return this.componentInfo.childComponents.get(aNode.tagName).toString();
        }
    }
    compileText(aNode) {
        const { emitter } = this;
        const shouldEmitComment = TypeGuards.isExprTextNode(aNode.textExpr) && aNode.textExpr.original && !this.ssrOnly && !this.inScript;
        const outputType = this.inScript ? 'rawhtml' : 'html';
        if (shouldEmitComment)
            emitter.writeHTMLLiteral('<!--s-text-->');
        emitter.writeHTMLExpression(expr_compiler_1.expr(aNode.textExpr, outputType));
        if (shouldEmitComment)
            emitter.writeHTMLLiteral('<!--/s-text-->');
    }
    compileTemplate(aNode) {
        // if、for 等区块 wrap，只渲染内容。
        // 注意：<template> 为组件根节点时，tagName=null, isATemplateNode=false
        this.elementCompiler.inner(aNode);
    }
    compileFragment(aNode) {
        if (TypeGuards.isATextNode(aNode.children[0]) && !this.ssrOnly && !this.inScript) {
            this.emitter.writeHTMLLiteral('<!--s-frag-->');
        }
        this.elementCompiler.inner(aNode);
        if (TypeGuards.isATextNode(aNode.children[aNode.children.length - 1]) && !this.ssrOnly && !this.inScript) {
            this.emitter.writeHTMLLiteral('<!--/s-frag-->');
        }
    }
    compileIf(aNode) {
        const { emitter } = this;
        // output if
        const ifDirective = aNode.directives.if;
        const aNodeWithoutIf = Object.assign({}, aNode);
        delete aNodeWithoutIf.directives.if;
        emitter.writeIf(expr_compiler_1.expr(ifDirective.value), () => this.compile(aNodeWithoutIf, false));
        // output elif and else
        for (const elseANode of aNode.elses || []) {
            const elifDirective = elseANode.directives.elif;
            if (elifDirective) {
                emitter.writeLine('else if (' + expr_compiler_1.expr(elifDirective.value) + ') {');
            }
            else {
                emitter.writeLine('else {');
            }
            emitter.indent();
            this.compile(elseANode, false);
            emitter.unindent();
            emitter.writeLine('}');
        }
    }
    compileFor(aNode) {
        const { emitter } = this;
        const forElementANode = {
            children: aNode.children,
            props: aNode.props,
            events: aNode.events,
            tagName: aNode.tagName,
            directives: Object.assign({}, aNode.directives)
        };
        delete forElementANode.directives.for;
        const { item, index, value } = aNode.directives.for;
        const list = emitter.genID('list');
        const i = emitter.genID('i');
        emitter.writeLine('let ' + list + ' = ' + expr_compiler_1.expr(value) + ';');
        emitter.writeIf(list + ' instanceof Array', () => {
            // for array
            emitter.writeFor(`let ${i} = 0; ${i} < ${list}.length; ${i}++`, () => {
                if (index)
                    emitter.writeLine(`ctx.data.${index} = ${i};`);
                emitter.writeLine(`ctx.data.${item} = ${list}[${i}];`);
                this.compile(forElementANode, false);
            });
        });
        // for object
        emitter.beginElseIf(`typeof ${list} === "object"`);
        emitter.writeFor(`let ${i} in ${list}`, () => {
            emitter.writeIf(`${list}[${i}] != null`, () => {
                if (index)
                    emitter.writeLine(`ctx.data.${index} = ${i};`);
                emitter.writeLine(`ctx.data.${item} = ${list}[${i}];`);
                this.compile(forElementANode, false);
            });
        });
        emitter.endIf();
    }
    compileSlot(aNode) {
        const { emitter } = this;
        assert_1.default(!this.inScript, '<slot> is not allowed inside <script>');
        emitter.nextLine('(');
        emitter.writeAnonymousFunction([], () => {
            emitter.nextLine('const defaultRender = ');
            this.compileSlotRenderer(aNode.children);
            emitter.feedLine(';');
            emitter.writeBlock('let data =', () => {
                if (aNode.directives.bind) {
                    emitter.writeLine('...' + expr_compiler_1.expr(aNode.directives.bind.value) + ',');
                }
                for (const item of aNode.vars || []) {
                    emitter.writeLine(`"${item.name}": ${expr_compiler_1.expr(item.expr)},`);
                }
            });
            const nameProp = anode_util_1.getANodePropByName(aNode, 'name');
            const slotNameExpr = nameProp ? expr_compiler_1.expr(nameProp.expr) : '""';
            emitter.writeLine(`let slotName = ${slotNameExpr};`);
            emitter.writeLine('let render = ctx.slots[slotName] || defaultRender;');
            emitter.writeLine('html += render(parentCtx, data);');
        });
        emitter.feedLine(')();');
    }
    compileElement(aNode, isRootElement) {
        this.elementCompiler.tagStart(aNode);
        if (aNode.tagName === 'script')
            this.inScript = true;
        if (isRootElement && !this.ssrOnly && !this.inScript) {
            this.emitter.writeIf('!noDataOutput', () => this.emitter.writeDataComment());
        }
        this.elementCompiler.inner(aNode);
        this.inScript = false;
        this.elementCompiler.tagEnd(aNode);
    }
    compileComponent(aNode, ref, isRootElement) {
        const { emitter } = this;
        const defaultSourceSlots = [];
        const sourceSlotCodes = new Map();
        assert_1.default(!this.inScript, 'component reference is not allowed inside <script>');
        for (const child of aNode.children) { // nodes without children (like pATextNode) has been taken over by other methods
            const slotBind = !child.textExpr && anode_util_1.getANodePropByName(child, 'slot');
            if (slotBind) {
                const slotName = slotBind.expr.value;
                if (!sourceSlotCodes.has(slotName)) {
                    sourceSlotCodes.set(slotName, {
                        children: [],
                        prop: slotBind
                    });
                }
                sourceSlotCodes.get(slotName).children.push(child);
            }
            else {
                defaultSourceSlots.push(child);
            }
        }
        const slots = emitter.genID('slots');
        emitter.writeLine(`let ${slots} = {};`);
        if (defaultSourceSlots.length) {
            emitter.nextLine(`${slots}[""] = `);
            this.compileSlotRenderer(defaultSourceSlots);
            emitter.feedLine(';');
        }
        for (const sourceSlotCode of sourceSlotCodes.values()) {
            emitter.nextLine(`${slots}[${expr_compiler_1.expr(sourceSlotCode.prop.expr)}] = `);
            this.compileSlotRenderer(sourceSlotCode.children);
            emitter.feedLine(';');
        }
        const ndo = isRootElement ? 'noDataOutput' : 'true';
        emitter.nextLine('html += ');
        emitter.writeFunctionCall(`sanSSRResolver.getRenderer(${ref})`, [this.componentDataCode(aNode), ndo, 'parentCtx', stringifier_1.stringifier.str(aNode.tagName) + `, ${slots}`]);
    }
    compileSlotRenderer(content) {
        const { emitter } = this;
        emitter.writeAnonymousFunction(['parentCtx', 'data'], () => {
            if (!content.length) {
                emitter.writeLine('return "";');
                return;
            }
            emitter.writeLine('let html = "";');
            emitter.writeLine('ctx = {...ctx, data: Object.assign({}, ctx.data, data)};');
            for (const child of content)
                this.compile(child, false);
            emitter.writeLine('return html;');
        });
    }
    componentDataCode(aNode) {
        const givenData = '{' + aNode.props.map(prop => {
            const key = stringifier_1.stringifier.str(lodash_1.camelCase(prop.name));
            const val = expr_compiler_1.expr(prop.expr);
            return `${key}: ${val}`;
        }).join(', ') + '}';
        const bindDirective = aNode.directives.bind;
        return bindDirective ? `Object.assign(${expr_compiler_1.expr(bindDirective.value)}, ${givenData})` : givenData;
    }
}
exports.ANodeCompiler = ANodeCompiler;
//# sourceMappingURL=anode-compiler.js.map