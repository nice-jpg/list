"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getPropertyAssignmentName = exports.getObjectLiteralPropertyKeys = exports.getChildComponents = exports.getPropertyStringArrayValue = exports.getPropertyStringValue = exports.getComponentDeclarations = exports.isChildClassOf = exports.getComponentClassIdentifier = exports.getSanImportDeclaration = void 0;
const ts_morph_1 = require("ts-morph");
const debug_1 = __importDefault(require("debug"));
const component_reference_1 = require("../models/component-reference");
const debug = debug_1.default('ts-ast-util');
function getSanImportDeclaration(sourceFile) {
    return sourceFile.getImportDeclaration(node => node.getModuleSpecifierValue() === 'san');
}
exports.getSanImportDeclaration = getSanImportDeclaration;
function getComponentClassIdentifier(sourceFile) {
    const declaration = getSanImportDeclaration(sourceFile);
    if (!declaration)
        return;
    const namedImports = declaration.getNamedImports();
    for (const namedImport of namedImports) {
        const name = namedImport.getName();
        if (name !== 'Component')
            continue;
        const alias = namedImport.getAliasNode();
        if (alias)
            return alias.getText();
        return 'Component';
    }
}
exports.getComponentClassIdentifier = getComponentClassIdentifier;
function isChildClassOf(clazz, parentClass) {
    const extendClause = clazz.getHeritageClauseByKind(ts_morph_1.SyntaxKind.ExtendsKeyword);
    if (!extendClause)
        return false;
    const typeNode = extendClause.getTypeNodes().find(x => x.getText() === parentClass);
    if (!typeNode)
        return false;
    return true;
}
exports.isChildClassOf = isChildClassOf;
function getComponentDeclarations(sourceFile) {
    const componentClassIdentifier = getComponentClassIdentifier(sourceFile);
    if (!componentClassIdentifier)
        return [];
    return sourceFile.getClasses().filter(clazz => isChildClassOf(clazz, componentClassIdentifier));
}
exports.getComponentDeclarations = getComponentDeclarations;
function getPropertyStringValue(clazz, memberName, defaultValue) {
    const member = clazz.getProperty(memberName);
    if (!member)
        return defaultValue;
    const init = member.getInitializer();
    if (!init)
        return defaultValue;
    // 字符串常量，取其字面值
    const value = getLiteralText(init);
    if (value !== undefined)
        return value;
    // 变量，找到定义处，取其字面值（非字面量跑错）
    if (ts_morph_1.TypeGuards.isIdentifier(init)) {
        const identName = init.getText();
        const file = clazz.getSourceFile();
        const decl = file.getVariableDeclarationOrThrow(identName);
        const value = decl.getInitializer();
        if (!value)
            throw new Error(`${JSON.stringify(decl.getParent().getText())} not supported, specify a string literal for "${memberName}"`);
        const str = getLiteralText(value);
        if (str === undefined) {
            throw new Error(`${JSON.stringify(value.getText())} not supported, specify a string literal for "${memberName}"`);
        }
        return str;
    }
    throw new Error(`invalid "${memberName}" property`);
}
exports.getPropertyStringValue = getPropertyStringValue;
function getPropertyStringArrayValue(clazz, memberName) {
    const member = clazz.getProperty(memberName);
    if (!member)
        return undefined;
    const init = member.getInitializer();
    if (!init)
        return undefined;
    if (!ts_morph_1.TypeGuards.isArrayLiteralExpression(init)) {
        throw new Error(`invalid "${memberName}": "${init.getText()}", array literal expected`);
    }
    return init.getElements().map(element => getLiteralText(element));
}
exports.getPropertyStringArrayValue = getPropertyStringArrayValue;
function getLiteralText(expr) {
    if (ts_morph_1.TypeGuards.isStringLiteral(expr) || ts_morph_1.TypeGuards.isNoSubstitutionTemplateLiteral(expr)) {
        return expr.getLiteralValue();
    }
}
function getChildComponents(clazz, defaultClassDeclaration) {
    const member = clazz.getProperty('components');
    const ret = new Map();
    if (!member)
        return ret;
    // 对引入的名称做索引，例如
    //
    // import XList from './list'
    // 索引为
    // 'XList' => { specifier: './list', named: false }
    const file = clazz.getSourceFile();
    const importedNames = new Map();
    for (const decl of file.getImportDeclarations()) {
        const specifier = decl.getModuleSpecifier().getLiteralValue();
        const defaultImport = decl.getDefaultImport();
        if (defaultImport) {
            importedNames.set(defaultImport.getText(), { specifier, named: false });
        }
        for (const namedImport of decl.getNamedImports()) {
            importedNames.set(namedImport.getName(), { specifier, named: true });
        }
    }
    // 子组件声明遍历，例如
    //
    // components: {
    //     'x-list': XList
    // }
    // 解析后的子组件信息为
    // 'x-list' => { specifier: './list', id: '0' }
    const init = member.getInitializerIfKindOrThrow(ts_morph_1.SyntaxKind.ObjectLiteralExpression);
    for (const prop of init.getProperties()) {
        if (!ts_morph_1.TypeGuards.isPropertyAssignment(prop))
            throw new Error(`${JSON.stringify(prop.getText())} not supported`);
        const propName = getPropertyAssignmentName(prop);
        const childComponentClassName = prop.getInitializerIfKindOrThrow(ts_morph_1.SyntaxKind.Identifier).getText();
        if (importedNames.has(childComponentClassName)) { // 子组件来自外部源文件
            const { specifier, named } = importedNames.get(childComponentClassName);
            ret.set(propName, new component_reference_1.ComponentReference(specifier, component_reference_1.componentID(!named, childComponentClassName)));
        }
        else { // 子组件来自当前源文件
            const isDefault = !!defaultClassDeclaration && defaultClassDeclaration.getName() === childComponentClassName;
            ret.set(propName, new component_reference_1.ComponentReference('.', component_reference_1.componentID(isDefault, childComponentClassName)));
        }
    }
    return ret;
}
exports.getChildComponents = getChildComponents;
function getObjectLiteralPropertyKeys(clazz, propertyName) {
    const prop = clazz.getProperty(propertyName);
    if (!prop)
        return [];
    const init = prop.getInitializerIfKindOrThrow(ts_morph_1.SyntaxKind.ObjectLiteralExpression);
    return init.getProperties().map(prop => {
        if (ts_morph_1.TypeGuards.isPropertyAssignment(prop))
            return getPropertyAssignmentName(prop);
        if (ts_morph_1.TypeGuards.isShorthandPropertyAssignment(prop))
            return getPropertyAssignmentName(prop);
        if (ts_morph_1.TypeGuards.isMethodDeclaration(prop))
            return getPropertyAssignmentName(prop);
        throw new Error('object property not recognized');
    });
}
exports.getObjectLiteralPropertyKeys = getObjectLiteralPropertyKeys;
function getPropertyAssignmentName(prop) {
    const nameNode = prop.getNameNode();
    return ts_morph_1.TypeGuards.isStringLiteral(nameNode) ? nameNode.getLiteralValue() : prop.getName();
}
exports.getPropertyAssignmentName = getPropertyAssignmentName;
//# sourceMappingURL=ts-ast-util.js.map