"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.assertVariableDeclarator = exports.assertObjectExpression = exports.assertArrayExpression = exports.assertIdentifier = exports.assertLiteral = exports.assertProperty = exports.isArrayExpression = exports.isExportDefaultDeclaration = exports.isProperty = exports.isClassExpression = exports.isClassDeclaration = exports.isThisExpression = exports.isAssignmentExpression = exports.isExpressionStatement = exports.isImportSpecifier = exports.isImportDefaultSpecifier = exports.isObjectExpression = exports.isObjectPattern = exports.isCallExpression = exports.isVariableDeclarator = exports.isVariableDeclaration = exports.isLiteral = exports.isTemplateLiteral = exports.isIdentifier = exports.isBinaryExpression = exports.isMemberExpression = exports.isRequire = exports.findDefaultExport = exports.location = exports.getMemberAssignmentsTo = exports.getLiteralValue = exports.getStringValue = exports.getClassName = exports.isClass = exports.getPropertiesFromObject = exports.getPropertyFromObject = exports.addStringPropertyForObject = exports.getConstructor = exports.getMembersFromClassDeclaration = exports.getStringArrayValue = exports.findExportNames = exports.findESMImports = exports.findScriptRequires = exports.isExportsMemberExpression = exports.isModuleExports = exports.isRequireSpecifier = exports.getRequireSpecifier = exports.filterByType = void 0;
const acorn_walk_1 = require("acorn-walk");
const assert_1 = __importStar(require("assert"));
const OPERATORS = {
    '+': (l, r) => l + r
};
function filterByType(node, type) {
    const results = [];
    acorn_walk_1.simple(node, {
        [type]: (node) => results.push(node)
    });
    return results;
}
exports.filterByType = filterByType;
function getRequireSpecifier(node) {
    const arg = node['arguments'][0];
    assertLiteral(arg);
    return arg.value;
}
exports.getRequireSpecifier = getRequireSpecifier;
function isRequireSpecifier(node, spec) {
    return isRequire(node) && getRequireSpecifier(node) === spec;
}
exports.isRequireSpecifier = isRequireSpecifier;
function isModuleExports(node) {
    // exports = Foo
    if (isIdentifier(node) && node['name'] === 'exports')
        return true;
    // module.exports = Foo
    if (isMemberExpression(node) && node.object['name'] === 'module' && node.property['name'] === 'exports')
        return true;
    return false;
}
exports.isModuleExports = isModuleExports;
function isExportsMemberExpression(expr) {
    return isMemberExpression(expr) &&
        getStringValue(expr['object']) === 'exports';
}
exports.isExportsMemberExpression = isExportsMemberExpression;
function* findScriptRequires(node) {
    for (const decl of filterByType(node, 'VariableDeclaration')) {
        const { id, init } = decl.declarations[0];
        if (!init)
            continue;
        if (isRequire(init)) {
            const specifier = getRequireSpecifier(init);
            if (isIdentifier(id))
                yield [id.name, specifier, 'default'];
            if (isObjectPattern(id)) {
                for (const [key, value] of getPropertiesFromObject(id)) {
                    assertIdentifier(value);
                    yield [value.name, specifier, key];
                }
            }
        }
        // const C = require('san').Component
        if (isMemberExpression(init) && isRequire(init.object)) {
            const specifier = getRequireSpecifier(init.object);
            assertIdentifier(id);
            yield [id.name, specifier, getStringValue(init.property)];
        }
    }
}
exports.findScriptRequires = findScriptRequires;
function* findESMImports(root) {
    for (const node of filterByType(root, 'ImportDeclaration')) {
        const relativeFile = node.source.value;
        for (const spec of node['specifiers']) {
            if (isImportDefaultSpecifier(spec)) {
                yield [spec.local.name, relativeFile, 'default'];
            }
            if (isImportSpecifier(spec)) {
                yield [spec.local.name, relativeFile, spec.imported.name];
            }
        }
    }
}
exports.findESMImports = findESMImports;
/**
 * 找到每个 localName 对应的 exportName。
 */
function findExportNames(root) {
    const names = [];
    acorn_walk_1.simple(root, {
        ExportDefaultDeclaration(node) {
            const decl = node['declaration'];
            // export default Foo
            if (isIdentifier(decl))
                names.push([decl.name, 'default']);
        },
        ExportNamedDeclaration(node) {
            if (isVariableDeclaration(node['declaration'])) {
                // export const foo = Foo, bar = Bar
                for (const decl of node['declaration'].declarations) {
                    assertVariableDeclarator(decl);
                    assertIdentifier(decl.id);
                    assertIdentifier(decl.init);
                    names.push([decl.init.name, decl.id.name]);
                }
            }
        },
        AssignmentExpression: (node) => {
            const { left, right } = node;
            // module.exports.foo = bar
            if (isIdentifier(right) && isMemberExpression(left) && isModuleExports(left.object)) {
                names.push([right.name, getStringValue(left.property)]);
            }
            if (isModuleExports(left)) {
                // module.exports = Foo
                if (isIdentifier(right)) {
                    names.push([right.name, 'default']);
                }
                // module.exports = {foo: bar}
                if (isObjectExpression(right)) {
                    for (const [exported, value] of getPropertiesFromObject(right)) {
                        assertIdentifier(value);
                        names.push([value.name, exported]);
                    }
                }
            }
        }
    });
    return names;
}
exports.findExportNames = findExportNames;
function getStringArrayValue(expr) {
    assertArrayExpression(expr);
    return expr.elements.map(getLiteralValue);
}
exports.getStringArrayValue = getStringArrayValue;
function* getMembersFromClassDeclaration(expr) {
    for (const decl of expr.body.body) {
        if (decl['kind'] === 'constructor') {
            const constructorDecl = decl;
            for (const expr of constructorDecl.value.body.body) {
                if (isExpressionStatement(expr) &&
                    isAssignmentExpression(expr.expression) &&
                    isMemberAssignment(expr.expression.left))
                    yield [getStringValue(expr.expression.left['property']), expr.expression.right];
            }
        }
        yield [getStringValue(decl.key), decl.value];
    }
}
exports.getMembersFromClassDeclaration = getMembersFromClassDeclaration;
function getConstructor(expr) {
    for (const method of expr.body.body) {
        if (method.kind === 'constructor')
            return method;
    }
}
exports.getConstructor = getConstructor;
function addStringPropertyForObject(expr, key, value) {
    expr.properties.push({
        type: 'Property',
        method: false,
        shorthand: false,
        computed: false,
        key: { type: 'Identifier', name: key },
        value: { type: 'Literal', value: value, raw: JSON.stringify(value) },
        kind: 'init'
    });
}
exports.addStringPropertyForObject = addStringPropertyForObject;
function getPropertyFromObject(obj, propertyName) {
    for (const [key, val] of getPropertiesFromObject(obj)) {
        if (key === propertyName)
            return val;
    }
}
exports.getPropertyFromObject = getPropertyFromObject;
function* getPropertiesFromObject(obj) {
    for (const prop of obj.properties) {
        assertProperty(prop);
        yield [getStringValue(prop.key), prop.value];
    }
}
exports.getPropertiesFromObject = getPropertiesFromObject;
function isMemberAssignment(expr) {
    return isMemberExpression(expr) && isThisExpression(expr.object);
}
function isClass(node) {
    return isClassExpression(node) || isClassDeclaration(node);
}
exports.isClass = isClass;
function getClassName(node) {
    if (isClass(node) && node.id)
        return node.id.name;
    return '';
}
exports.getClassName = getClassName;
function getStringValue(node) {
    if (isIdentifier(node))
        return node['name'];
    if (isLiteral(node))
        return node['value'];
    throw new Error(`${location(node)} cannot evaluate string value`);
}
exports.getStringValue = getStringValue;
function getLiteralValue(node) {
    if (isBinaryExpression(node)) {
        const left = getLiteralValue(node.left);
        const right = getLiteralValue(node.right);
        const op = OPERATORS[node.operator];
        assert_1.default(op, `operator "${node.operator}" not supported'`);
        return op(left, right);
    }
    if (isLiteral(node))
        return node.value;
    if (isTemplateLiteral(node)) {
        assert_1.equal(node.expressions.length, 0, 'template expressions are not supported');
        return node.quasis.map(quasis => quasis.value.cooked).join('');
    }
    throw new Error(`${location(node)} expected literal`);
}
exports.getLiteralValue = getLiteralValue;
function getMemberAssignmentsTo(program, objName) {
    const results = [];
    acorn_walk_1.simple(program, {
        AssignmentExpression(node) {
            const expr = node;
            if (isMemberExpression(expr.left) && isIdentifier(expr.left.object) && expr.left.object.name === objName) {
                results.push([getStringValue(expr.left.property), expr.right]);
            }
        }
    });
    return results;
}
exports.getMemberAssignmentsTo = getMemberAssignmentsTo;
function location(node) {
    return `[${node['start']},${node['end']})`;
}
exports.location = location;
function findDefaultExport(node) {
    let result;
    acorn_walk_1.simple(node, {
        ExportDefaultDeclaration(node) {
            result = node.declaration;
        },
        AssignmentExpression(node) {
            const expr = node;
            if (isModuleExports(expr.left))
                result = expr.right;
        }
    });
    return result;
}
exports.findDefaultExport = findDefaultExport;
function isRequire(node) {
    return isCallExpression(node) && node.callee['name'] === 'require';
}
exports.isRequire = isRequire;
function isMemberExpression(expr) {
    return expr.type === 'MemberExpression';
}
exports.isMemberExpression = isMemberExpression;
function isBinaryExpression(expr) {
    return expr.type === 'BinaryExpression';
}
exports.isBinaryExpression = isBinaryExpression;
function isIdentifier(expr) {
    return expr.type === 'Identifier';
}
exports.isIdentifier = isIdentifier;
function isTemplateLiteral(expr) {
    return expr.type === 'TemplateLiteral';
}
exports.isTemplateLiteral = isTemplateLiteral;
function isLiteral(expr) {
    return expr.type === 'Literal';
}
exports.isLiteral = isLiteral;
function isVariableDeclaration(expr) {
    return expr.type === 'VariableDeclaration';
}
exports.isVariableDeclaration = isVariableDeclaration;
function isVariableDeclarator(expr) {
    return expr.type === 'VariableDeclarator';
}
exports.isVariableDeclarator = isVariableDeclarator;
function isCallExpression(expr) {
    return expr.type === 'CallExpression';
}
exports.isCallExpression = isCallExpression;
function isObjectPattern(expr) {
    return expr.type === 'ObjectPattern';
}
exports.isObjectPattern = isObjectPattern;
function isObjectExpression(expr) {
    return expr.type === 'ObjectExpression';
}
exports.isObjectExpression = isObjectExpression;
function isImportDefaultSpecifier(expr) {
    return expr.type === 'ImportDefaultSpecifier';
}
exports.isImportDefaultSpecifier = isImportDefaultSpecifier;
function isImportSpecifier(expr) {
    return expr.type === 'ImportSpecifier';
}
exports.isImportSpecifier = isImportSpecifier;
function isExpressionStatement(expr) {
    return expr.type === 'ExpressionStatement';
}
exports.isExpressionStatement = isExpressionStatement;
function isAssignmentExpression(expr) {
    return expr.type === 'AssignmentExpression';
}
exports.isAssignmentExpression = isAssignmentExpression;
function isThisExpression(expr) {
    return expr.type === 'ThisExpression';
}
exports.isThisExpression = isThisExpression;
function isClassDeclaration(expr) {
    return expr.type === 'ClassDeclaration';
}
exports.isClassDeclaration = isClassDeclaration;
function isClassExpression(expr) {
    return expr.type === 'ClassExpression';
}
exports.isClassExpression = isClassExpression;
function isProperty(expr) {
    return expr.type === 'Property';
}
exports.isProperty = isProperty;
function isExportDefaultDeclaration(node) {
    return node.type === 'ExportDefaultDeclaration';
}
exports.isExportDefaultDeclaration = isExportDefaultDeclaration;
function isArrayExpression(expr) {
    return expr.type === 'ArrayExpression';
}
exports.isArrayExpression = isArrayExpression;
function assertProperty(expr) {
    assert_1.default(isProperty(expr));
}
exports.assertProperty = assertProperty;
function assertLiteral(expr) {
    assert_1.default(isLiteral(expr));
}
exports.assertLiteral = assertLiteral;
function assertIdentifier(expr) {
    assert_1.default(isIdentifier(expr));
}
exports.assertIdentifier = assertIdentifier;
function assertArrayExpression(expr) {
    assert_1.default(isArrayExpression(expr));
}
exports.assertArrayExpression = assertArrayExpression;
function assertObjectExpression(expr) {
    assert_1.default(isObjectExpression(expr));
}
exports.assertObjectExpression = assertObjectExpression;
function assertVariableDeclarator(expr) {
    assert_1.default(isVariableDeclarator(expr));
}
exports.assertVariableDeclarator = assertVariableDeclarator;
//# sourceMappingURL=js-ast-util.js.map