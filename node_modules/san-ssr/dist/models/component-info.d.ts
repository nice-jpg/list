import type { SanComponentConfig, ANode } from 'san';
import type { ClassDeclaration } from 'ts-morph';
import { Node } from 'estree';
import { ComponentReference, DynamicComponentReference } from './component-reference';
import { ComponentClass } from './component';
export declare type TagName = string;
export interface ComponentInfo {
    id: string;
    root: ANode;
    childComponents: Map<TagName, ComponentReference>;
    hasMethod(name: string): boolean;
    initData?(): any;
    getComputedNames(): string[];
    getFilterNames(): string[];
    hasDynamicComponent(): boolean;
}
/**
 * 提供一个组件信息的封装，包括：
 * - computed name 列表、filters name 列表、root ANode
 * - 从 TypeScript 来的还有 sourceFile、classDeclaration 等
 *
 * Note：这里只是存数据，它的创建由具体 parser 负责
 */
declare abstract class ComponentInfoImpl<R extends ComponentReference = ComponentReference> {
    /**
     * 见 component-reference.ts 的说明
     */
    readonly id: string;
    readonly root: ANode;
    readonly childComponents: Map<TagName, R>;
    constructor(
    /**
     * 见 component-reference.ts 的说明
     */
    id: string, root: ANode, childComponents: Map<TagName, R>);
    abstract hasMethod(name: string): boolean;
    abstract getComputedNames(): string[];
    abstract getFilterNames(): string[];
    hasDynamicComponent(): boolean;
}
export declare class DynamicComponentInfo extends ComponentInfoImpl<DynamicComponentReference> implements ComponentInfo {
    readonly componentClass: ComponentClass;
    /**
     * 归一化的 proto。
     *
     * 确保 computed 等属性都出现在 proto 上，
     * 用于 compileToRenderer() 和 compileToSource()
     */
    readonly proto: SanComponentConfig<{}, {}>;
    constructor(id: string, root: ANode, childComponents: Map<TagName, DynamicComponentReference>, componentClass: ComponentClass);
    initData(): Partial<{}>;
    hasMethod(name: string): boolean;
    getComputedNames(): string[];
    getFilterNames(): string[];
}
export declare class JSComponentInfo extends ComponentInfoImpl<ComponentReference> {
    readonly className: string;
    readonly sourceCode: string;
    private readonly properties;
    constructor(id: string, className: string, properties: Map<string, Node>, sourceCode: string);
    hasMethod(name: string): boolean;
    getComputedNames(): string[];
    getFilterNames(): string[];
    getComponentsDelcarations(): Generator<[string, Node]>;
    private getObjectPropertyKeys;
}
export declare class TypedComponentInfo extends ComponentInfoImpl implements ComponentInfo {
    readonly classDeclaration: ClassDeclaration;
    private computedNames;
    private filterNames;
    constructor(id: string, root: ANode, childComponents: Map<TagName, ComponentReference>, classDeclaration: ClassDeclaration);
    hasMethod(name: string): boolean;
    getComputedNames(): string[];
    getFilterNames(): string[];
}
export {};
