"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TypedComponentInfo = exports.JSComponentInfo = exports.DynamicComponentInfo = void 0;
const parse_template_1 = require("../parsers/parse-template");
const anode_util_1 = require("../utils/anode-util");
const ts_ast_util_1 = require("../utils/ts-ast-util");
const js_ast_util_1 = require("../utils/js-ast-util");
/**
 * 提供一个组件信息的封装，包括：
 * - computed name 列表、filters name 列表、root ANode
 * - 从 TypeScript 来的还有 sourceFile、classDeclaration 等
 *
 * Note：这里只是存数据，它的创建由具体 parser 负责
 */
class ComponentInfoImpl {
    constructor(
    /**
     * 见 component-reference.ts 的说明
     */
    id, root, childComponents) {
        this.id = id;
        this.root = root;
        this.childComponents = childComponents;
    }
    hasDynamicComponent() {
        let found = false;
        anode_util_1.visitANodeRecursively(this.root, (node) => {
            if (node.directives && node.directives.is)
                found = true;
        });
        return found;
    }
}
class DynamicComponentInfo extends ComponentInfoImpl {
    constructor(id, root, childComponents, componentClass) {
        super(id, root, childComponents);
        this.componentClass = componentClass;
        this.proto = Object.assign(componentClass.prototype, componentClass);
    }
    initData() {
        return this.proto.initData ? this.proto.initData.call({}) : {};
    }
    hasMethod(name) {
        return !!this.proto[name];
    }
    getComputedNames() {
        return Object.keys(this.proto.computed || {});
    }
    getFilterNames() {
        return Object.keys(this.proto.filters || {});
    }
}
exports.DynamicComponentInfo = DynamicComponentInfo;
class JSComponentInfo extends ComponentInfoImpl {
    constructor(id, className, properties, sourceCode) {
        const template = properties.has('template') ? js_ast_util_1.getLiteralValue(properties.get('template')) : '';
        const trimWhitespace = properties.has('trimWhitespace') ? js_ast_util_1.getLiteralValue(properties.get('trimWhitespace')) : undefined;
        const delimiters = properties.has('delimiters') ? js_ast_util_1.getStringArrayValue(properties.get('delimiters')) : undefined;
        const root = parse_template_1.parseAndNormalizeTemplate(template, { trimWhitespace, delimiters });
        super(id, root, new Map());
        this.className = className;
        this.properties = properties;
        this.sourceCode = sourceCode;
    }
    hasMethod(name) {
        return this.properties.has(name);
    }
    getComputedNames() {
        return this.getObjectPropertyKeys('computed');
    }
    getFilterNames() {
        return this.getObjectPropertyKeys('filters');
    }
    *getComponentsDelcarations() {
        const expr = this.properties.get('components');
        if (!expr)
            return;
        js_ast_util_1.assertObjectExpression(expr);
        yield* js_ast_util_1.getPropertiesFromObject(expr);
    }
    getObjectPropertyKeys(propertyName) {
        const obj = this.properties.get(propertyName);
        if (!obj)
            return [];
        js_ast_util_1.assertObjectExpression(obj);
        return [...js_ast_util_1.getPropertiesFromObject(obj)].map(([key]) => key);
    }
}
exports.JSComponentInfo = JSComponentInfo;
class TypedComponentInfo extends ComponentInfoImpl {
    constructor(id, root, childComponents, classDeclaration) {
        super(id, root, childComponents);
        this.classDeclaration = classDeclaration;
        this.computedNames = ts_ast_util_1.getObjectLiteralPropertyKeys(this.classDeclaration, 'computed');
        this.filterNames = ts_ast_util_1.getObjectLiteralPropertyKeys(this.classDeclaration, 'filters');
    }
    hasMethod(name) {
        return !!this.classDeclaration.getMethod(name);
    }
    getComputedNames() {
        return this.computedNames;
    }
    getFilterNames() {
        return this.filterNames;
    }
}
exports.TypedComponentInfo = TypedComponentInfo;
//# sourceMappingURL=component-info.js.map