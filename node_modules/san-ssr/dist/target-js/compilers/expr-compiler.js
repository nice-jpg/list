"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.expr = exports.dataAccess = void 0;
const lang_1 = require("../../utils/lang");
const TypeGuards = __importStar(require("../../utils/type-guards"));
const underscore_1 = require("../../runtime/underscore");
const stringifier_1 = require("./stringifier");
// 二元表达式操作符映射表
const binaryOp = {
    43: '+',
    45: '-',
    42: '*',
    47: '/',
    60: '<',
    62: '>',
    76: '&&',
    94: '!=',
    121: '<=',
    122: '==',
    123: '>=',
    155: '!==',
    183: '===',
    248: '||'
};
function unary(e) {
    if (e.operator === 33)
        return '!' + expr(e.expr);
    if (e.operator === 45)
        return '-' + expr(e.expr);
    throw new Error(`unexpected unary operator "${String.fromCharCode(e.operator)}"`);
}
function binary(e) {
    const lhs = expr(e.segs[0]);
    const op = binaryOp[e.operator];
    const rhs = expr(e.segs[1]);
    return `${lhs} ${op} ${rhs}`;
}
function tertiary(e) {
    return `${expr(e.segs[0])} ? ${expr(e.segs[1])} : ${expr(e.segs[2])}`;
}
// 生成数据访问表达式代码
function dataAccess(accessorExpr, outputType, contextVariableName = 'ctx') {
    let code = `${contextVariableName}.data`;
    if (!accessorExpr)
        return code;
    for (const path of accessorExpr.paths) {
        code += TypeGuards.isExprStringNode(path) && lang_1.isValidIdentifier(path.value)
            ? `.${path.value}` : `[${expr(path)}]`;
    }
    return outputCode(code, outputType);
}
exports.dataAccess = dataAccess;
// 生成调用表达式代码
function callExpr(callExpr, outputType) {
    const paths = callExpr.name.paths;
    let code = 'ctx.instance';
    for (const path of paths) {
        code += TypeGuards.isExprStringNode(path) && lang_1.isValidIdentifier(path.value)
            ? `.${path.value}` : `[${expr(path)}]`;
    }
    code += '(';
    code += [...callExpr.args.map(arg => expr(arg)), 'ctx'].join(', ');
    code += ')';
    return outputCode(code, outputType);
}
function outputCode(code, outputType) {
    if (outputType === 'expr')
        return code;
    if (outputType === 'html')
        return `_.output(${code}, true)`;
    return `_.output(${code}, false)`;
}
// 生成插值代码
function interp(interpExpr, outputType) {
    let code = expr(interpExpr.expr);
    for (const filter of interpExpr.filters) {
        const filterName = filter.name.paths[0].value;
        switch (filterName) {
            case '_style':
            case '_class':
                code = `_.${filterName}Filter(${code})`;
                break;
            case '_xstyle':
            case '_xclass':
                code = `_.${filterName}Filter(${code}, ${expr(filter.args[0])})`;
                break;
            case 'url':
                code = `encodeURIComponent(${code})`;
                break;
            default:
                code = `ctx.instance.filters["${filterName}"].call(ctx.instance, ${code}, ${filter.args.map((arg) => expr(arg)).join(', ')})`;
        }
    }
    // {{ | raw }}
    if (outputType === 'html' && interpExpr.original) {
        return outputCode(code, 'rawhtml');
    }
    return outputCode(code, outputType);
}
function str(e, output) {
    if (output === 'html')
        return stringifier_1.stringifier.str(underscore_1._.escapeHTML(e.value));
    return stringifier_1.stringifier.str(e.value);
}
// 生成文本片段代码
function text(textExpr, output) {
    return textExpr.segs
        .map(seg => expr(seg, output))
        .map(seg => `${seg}`)
        .join(' + ') || '""';
}
// 生成数组字面量代码
function array(arrayExpr) {
    return '[' +
        arrayExpr.items
            .map(e => (e.spread ? '...' : '') + expr(e.expr))
            .join(', ') +
        ']';
}
// 生成对象字面量代码
function object(objExpr) {
    const code = [];
    for (const item of objExpr.items) {
        if (item.spread) {
            code.push('...' + expr(item.expr));
        }
        else {
            code.push(expr(item.name) + ':' + expr(item.expr));
        }
    }
    return '{\n' + code.join(',\n') + '\n}';
}
// expr 的 JavaScript 表达式
function expr(e, output = 'expr') {
    let s;
    if (TypeGuards.isExprUnaryNode(e))
        s = unary(e);
    else if (TypeGuards.isExprBinaryNode(e))
        s = binary(e);
    else if (TypeGuards.isExprTertiaryNode(e))
        s = tertiary(e);
    else if (TypeGuards.isExprStringNode(e))
        s = str(e, output);
    else if (TypeGuards.isExprNumberNode(e))
        s = '' + e.value;
    else if (TypeGuards.isExprBoolNode(e))
        s = e.value ? 'true' : 'false';
    else if (TypeGuards.isExprAccessorNode(e))
        s = dataAccess(e, output);
    else if (TypeGuards.isExprInterpNode(e))
        s = interp(e, output);
    else if (TypeGuards.isExprTextNode(e))
        s = text(e, output);
    else if (TypeGuards.isExprArrayNode(e))
        s = array(e);
    else if (TypeGuards.isExprObjectNode(e))
        s = object(e);
    else if (TypeGuards.isExprCallNode(e))
        s = callExpr(e, output);
    else if (TypeGuards.isExprNullNode(e))
        s = 'null';
    else
        throw new Error(`unexpected expression ${JSON.stringify(e)}`);
    return e.parenthesized ? `(${s})` : s;
}
exports.expr = expr;
//# sourceMappingURL=expr-compiler.js.map