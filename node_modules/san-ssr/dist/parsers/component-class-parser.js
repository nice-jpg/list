"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ComponentClassParser = void 0;
const san_1 = require("san");
const san_source_file_1 = require("../models/san-source-file");
const component_info_1 = require("../models/component-info");
const lang_1 = require("../utils/lang");
const component_1 = require("../models/component");
const parse_template_1 = require("./parse-template");
const component_reference_1 = require("../models/component-reference");
/*
 * 从根 ComponentClass 递归搜索和解析所有 ComponentClass，形成 ComponentInfo 列表，并放到单个 SanSourceFile 中。
 *
 * Note: 每个组件树对应一个 parser 实例，如果要解析新的组件树，请创建新的 parser 实例
 */
class ComponentClassParser {
    constructor(root, filePath) {
        this.root = root;
        this.filePath = filePath;
        this.id = 0;
        this.cids = new Map();
    }
    parse() {
        const componentInfos = [];
        const stack = [
            new component_reference_1.DynamicComponentReference('.', '' + this.id++, this.root)
        ];
        const parsed = new Set();
        while (stack.length) {
            const { id, componentClass } = stack.pop();
            if (parsed.has(componentClass))
                continue;
            else
                parsed.add(componentClass);
            const info = this.createComponentInfoFromComponentClass(componentClass, id);
            // 先序遍历，结果列表中第一个为根
            componentInfos.push(info);
            for (const child of info.childComponents.values())
                stack.push(child);
        }
        return new san_source_file_1.DynamicSanSourceFile(componentInfos, this.filePath, componentInfos[0]);
    }
    /**
     * 从组件 class 得到组件 component info
     */
    createComponentInfoFromComponentClass(componentClass, id) {
        if (component_1.isComponentLoader(componentClass)) {
            componentClass = componentClass.placeholder;
        }
        if (!componentClass)
            componentClass = san_1.defineComponent({ template: '' });
        const template = lang_1.getMember(componentClass, 'template', '');
        const trimWhitespace = lang_1.getMember(componentClass, 'trimWhitespace');
        const delimiters = lang_1.getMember(componentClass, 'delimiters');
        const rootANode = parse_template_1.parseAndNormalizeTemplate(template, { trimWhitespace, delimiters });
        const childComponents = this.getChildComponentClasses(componentClass);
        return new component_info_1.DynamicComponentInfo(id, rootANode, childComponents, componentClass);
    }
    /**
     * 从组件 class 得到子组件 class
     */
    getChildComponentClasses(parentComponentClass) {
        const children = new Map();
        const components = lang_1.getMember(parentComponentClass, 'components', {});
        for (const [tagName, componentClass] of Object.entries(components)) {
            // 可能是空，例如 var Foo = defineComponent({components: {foo: Foo}})
            children.set(tagName, new component_reference_1.DynamicComponentReference('.', component_reference_1.componentID(componentClass === this.root, () => this.getOrSetID(componentClass)), componentClass));
        }
        return children;
    }
    getOrSetID(componentClass) {
        if (!this.cids.has(componentClass))
            this.cids.set(componentClass, String(this.id++));
        return this.cids.get(componentClass);
    }
}
exports.ComponentClassParser = ComponentClassParser;
//# sourceMappingURL=component-class-parser.js.map